{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "date-range-picker",
  "type": "registry:ui",
  "title": "Date-range-picker",
  "description": "A date-range-picker component.",
  "dependencies": [
    "dayjs",
    "lucide-react",
    "react-day-picker"
  ],
  "registryDependencies": [
    "@cubby-ui/button",
    "@cubby-ui/calendar",
    "@cubby-ui/popover"
  ],
  "files": [
    {
      "path": "registry/default/date-range-picker/date-range-picker.tsx",
      "content": "import * as React from \"react\";\nimport dayjs from \"dayjs\";\nimport { CalendarIcon, ChevronsUpDownIcon } from \"lucide-react\";\n\nimport { Button } from \"@/registry/default/button/button\";\nimport { Calendar } from \"@/registry/default/calendar/calendar\";\nimport {\n  Popover,\n  PopoverContent,\n  PopoverTrigger,\n} from \"@/registry/default/popover/popover\";\nimport { cn } from \"@/lib/utils\";\n\nimport type { DateRange } from \"react-day-picker\";\n\nexport interface DateRangePickerProps {\n  value?: DateRange;\n  onSelect?: (range: DateRange | undefined) => void;\n  placeholder?: string;\n  className?: string;\n  disabled?: boolean;\n  format?: string;\n  numberOfMonths?: number;\n  fixedWeeks?: boolean;\n}\n\nexport function DateRangePicker({\n  value,\n  onSelect,\n  placeholder = \"Select date range\",\n  className,\n  disabled = false,\n  format = \"DD MMM YYYY\",\n  numberOfMonths = 1,\n  fixedWeeks = false,\n}: DateRangePickerProps) {\n  const [open, setOpen] = React.useState(false);\n  const [tempRange, setTempRange] = React.useState<DateRange | undefined>(\n    undefined,\n  );\n  const [hoverDate, setHoverDate] = React.useState<Date | undefined>(undefined);\n  const previousTempRangeRef = React.useRef<DateRange | undefined>(undefined);\n\n  // Initialize temp range with current value when popover opens\n  React.useEffect(() => {\n    if (open) {\n      setTempRange(value);\n      previousTempRangeRef.current = value;\n      setHoverDate(undefined);\n    }\n  }, [open, value]);\n\n  const formatDateRange = () => {\n    if (!value?.from) return placeholder;\n    if (!value.to) return dayjs(value.from).format(format);\n    return `${dayjs(value.from).format(format)} - ${dayjs(value.to).format(format)}`;\n  };\n\n  const displayRange = React.useMemo(() => {\n    // Show hover preview when selecting second date\n    if (tempRange?.from && !tempRange?.to && hoverDate) {\n      // Ensure proper range order\n      const start = tempRange.from;\n      const end = hoverDate;\n      if (start.getTime() <= end.getTime()) {\n        return { from: start, to: end };\n      } else {\n        return { from: end, to: start };\n      }\n    }\n    return tempRange;\n  }, [tempRange, hoverDate]);\n\n  const handleSelect = (range: DateRange | undefined) => {\n    const prevRange = previousTempRangeRef.current;\n\n    // Clear hover state when a selection is made\n    setHoverDate(undefined);\n\n    // Prevent deselecting all dates - if range is undefined or empty, ignore\n    if (!range?.from) {\n      return;\n    }\n\n    // Detect if user is starting a new selection\n    if (prevRange?.from && prevRange?.to) {\n      // Had a complete range before\n      if (range?.from && range?.to) {\n        // Still have a complete range\n        if (range.from.getTime() === range.to.getTime()) {\n          // Single date clicked - start new selection\n          setTempRange({ from: range.from, to: undefined });\n          previousTempRangeRef.current = { from: range.from, to: undefined };\n          return;\n        } else if (\n          // Check if it's just extending/modifying the existing range\n          range.from.getTime() === prevRange.from.getTime() ||\n          range.to.getTime() === prevRange.to.getTime()\n        ) {\n          // This is modifying the existing range, but we want to start fresh\n          // So we need to clear and start over with just the newly clicked date\n          const clickedDate =\n            range.from.getTime() !== prevRange.from.getTime()\n              ? range.from\n              : range.to;\n          setTempRange({ from: clickedDate, to: undefined });\n          previousTempRangeRef.current = { from: clickedDate, to: undefined };\n          return;\n        }\n      }\n\n      // Special case: if we had a single-day range and user clicks on a single date\n      // This happens when Calendar is in range mode but user clicks on the same date that was selected\n      if (range?.from && !range?.to) {\n        // Check if this is clicking on the same single-day range\n        if (\n          prevRange.from.getTime() === prevRange.to.getTime() &&\n          range.from.getTime() === prevRange.from.getTime()\n        ) {\n          // Clicking on the same single-day range - start new selection\n          setTempRange({ from: range.from, to: undefined });\n          previousTempRangeRef.current = { from: range.from, to: undefined };\n          return;\n        }\n      }\n    }\n\n    // If user is selecting a second date\n    if (range.from && !range.to && prevRange?.from && !prevRange?.to) {\n      // User clicked on the first date again - create single-day range\n      if (range.from.getTime() === prevRange.from.getTime()) {\n        const singleDayRange = { from: range.from, to: range.from };\n        setTempRange(singleDayRange);\n        previousTempRangeRef.current = singleDayRange;\n        onSelect?.(singleDayRange);\n        setOpen(false);\n        return;\n      }\n    }\n\n    setTempRange(range);\n    previousTempRangeRef.current = range;\n\n    // Update the actual value and close when both dates are selected\n    if (range?.from && range?.to) {\n      // Ensure proper range order - from should be earlier than to\n      const normalizedRange = {\n        from:\n          range.from.getTime() <= range.to.getTime() ? range.from : range.to,\n        to: range.from.getTime() <= range.to.getTime() ? range.to : range.from,\n      };\n      onSelect?.(normalizedRange);\n      setOpen(false);\n    }\n  };\n\n  return (\n    <Popover open={open} onOpenChange={setOpen}>\n      <PopoverTrigger\n        render={(props) => (\n          <Button\n            {...props}\n            variant=\"outline\"\n            className={cn(\"w-[300px] justify-between\", className)}\n            disabled={disabled}\n          >\n            <span className=\"flex w-full items-center\">\n              <CalendarIcon className=\"mr-2 size-4\" />\n              <span className={cn(!value?.from && \"text-muted-foreground\")}>\n                {formatDateRange()}\n              </span>\n            </span>\n            <ChevronsUpDownIcon className=\"ml-2 size-4 shrink-0 opacity-50\" />\n          </Button>\n        )}\n      />\n      <PopoverContent\n        className=\"w-auto border-none p-0 outline-none\"\n        sideOffset={4}\n        arrow={false}\n        onMouseLeave={() => {\n          // Clear hover when leaving the popover content\n          setHoverDate(undefined);\n        }}\n      >\n        <Calendar\n          className=\"border-0\"\n          mode=\"range\"\n          numberOfMonths={numberOfMonths}\n          showOutsideDays\n          fixedWeeks={fixedWeeks}\n          selected={displayRange}\n          onSelect={(range) => {\n            // Prevent auto-completion when starting fresh (no existing tempRange)\n            if (\n              !tempRange?.from &&\n              range?.from &&\n              range?.to &&\n              range.from.getTime() === range.to.getTime()\n            ) {\n              // This is a fresh selection where Calendar auto-set both dates - convert to single date selection\n              setTempRange({ from: range.from, to: undefined });\n              previousTempRangeRef.current = {\n                from: range.from,\n                to: undefined,\n              };\n              return;\n            }\n\n            // Important: when we have a hover preview active, we need to handle the selection differently\n            if (tempRange?.from && !tempRange?.to && hoverDate && range?.to) {\n              // This is the second date selection with hover preview\n              // Use the actual clicked date, not the hover preview\n              const actualRange = {\n                from:\n                  tempRange.from.getTime() <= range.to.getTime()\n                    ? tempRange.from\n                    : range.to,\n                to:\n                  tempRange.from.getTime() <= range.to.getTime()\n                    ? range.to\n                    : tempRange.from,\n              };\n              handleSelect(actualRange);\n            } else {\n              handleSelect(range);\n            }\n          }}\n          onDayClick={(date) => {\n            // Handle case where there's no existing selection - start new range selection\n            if (!tempRange?.from) {\n              setTempRange({ from: date, to: undefined });\n              previousTempRangeRef.current = { from: date, to: undefined };\n              return;\n            }\n\n            // Handle case where user clicks the same date while selecting\n            if (\n              tempRange?.from &&\n              !tempRange?.to &&\n              date.getTime() === tempRange.from.getTime()\n            ) {\n              handleSelect({ from: date, to: date });\n              return;\n            }\n\n            // Handle case where user clicks on a single-day range to start new selection\n            if (\n              tempRange?.from &&\n              tempRange?.to &&\n              tempRange.from.getTime() === tempRange.to.getTime() &&\n              date.getTime() === tempRange.from.getTime()\n            ) {\n              // Clicking on the same single-day range - start new selection\n              setTempRange({ from: date, to: undefined });\n              previousTempRangeRef.current = { from: date, to: undefined };\n              return;\n            }\n          }}\n          onDayMouseEnter={(date) => {\n            // Only show hover preview when selecting the second date\n            if (tempRange?.from && !tempRange?.to) {\n              setHoverDate(date);\n            }\n          }}\n          onDayMouseLeave={() => {\n            // Let the Calendar handle its own mouse leave\n          }}\n        />\n      </PopoverContent>\n    </Popover>\n  );\n}\n",
      "type": "registry:ui",
      "target": "components/ui/cubby-ui/date-range-picker.tsx"
    }
  ]
}