{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "drawer",
  "type": "registry:ui",
  "title": "Drawer",
  "description": "A drawer component.",
  "dependencies": [
    "class-variance-authority"
  ],
  "registryDependencies": [
    "@cubby-ui/scroll-area"
  ],
  "files": [
    {
      "path": "registry/default/drawer/drawer.tsx",
      "content": "\"use client\";\n\nimport * as React from \"react\";\nimport { Dialog as BaseDialog } from \"@base-ui/react/dialog\";\nimport { mergeProps } from \"@base-ui/react/merge-props\";\nimport { useRender } from \"@base-ui/react/use-render\";\nimport { cva } from \"class-variance-authority\";\n\nimport { cn } from \"@/lib/utils\";\nimport {\n  ScrollArea,\n  type ScrollAreaProps,\n} from \"@/registry/default/scroll-area/scroll-area\";\n\n// Drawer-specific CSS animations (scroll-driven animations for progressive enhancement)\nimport \"./drawer.css\";\n\nimport type { SnapPoint, DrawerDirection } from \"./lib/drawer-utils\";\nimport {\n  DIRECTION_CONFIG,\n  parsePixelValue,\n  findSnapPointIndex,\n  getSnapPointValue,\n  snapPointToRatio,\n  supportsScrollTimeline,\n  supportsScrollState,\n} from \"./lib/drawer-utils\";\nimport { useScrollSnap } from \"./hooks/use-scroll-snap\";\nimport { useVirtualKeyboard } from \"./hooks/use-virtual-keyboard\";\nimport { useVisualViewportHeight } from \"./hooks/use-visual-viewport-height\";\n\n// Re-export types for consumers\nexport type { SnapPoint, DrawerDirection };\n\n// Create handle for detached triggers (triggers outside the Drawer component)\nconst createDrawerHandle = BaseDialog.createHandle;\n\n/* -------------------------------------------------------------------------------------------------\n * CVA Variants\n * -------------------------------------------------------------------------------------------------*/\n\nconst drawerContentVariants = cva(\n  [\n    \"bg-popover text-popover-foreground flex flex-col\",\n    \"relative \",\n    \"ease-[cubic-bezier(0, 0, 0.58, 1)] transition-transform duration-350 will-change-transform\",\n    \"motion-reduce:transition-none\",\n  ],\n  {\n    variants: {\n      variant: {\n        default: \"\",\n        floating: [\n          \"m-4 rounded-2xl\",\n          \"ring-border ring-1\",\n          \"shadow-[0_16px_32px_0_oklch(0.18_0_0/0.16)]\",\n        ],\n      },\n      direction: {\n        bottom: \"\",\n        top: \"\",\n        right: \"\",\n        left: \"\",\n      },\n    },\n    compoundVariants: [\n      // Default variant - direction-specific sizing and rounding\n      {\n        variant: \"default\",\n        direction: \"bottom\",\n        class:\n          \"mx-auto max-h-[95dvh] w-full max-w-full rounded-t-xl [&[data-starting-style]]:translate-y-[var(--drawer-offset)] [&[data-ending-style]]:translate-y-[var(--drawer-offset)]\",\n      },\n      {\n        variant: \"default\",\n        direction: \"top\",\n        class:\n          \"mx-auto max-h-[95dvh] w-full max-w-full rounded-b-xl [&[data-starting-style]]:-translate-y-[var(--drawer-offset)] [&[data-ending-style]]:-translate-y-[var(--drawer-offset)]\",\n      },\n      {\n        variant: \"default\",\n        direction: \"right\",\n        class:\n          \"max-w-screen w-screen rounded-l-xl sm:max-w-sm [&[data-starting-style]]:translate-x-[var(--drawer-offset)] [&[data-ending-style]]:translate-x-[var(--drawer-offset)]\",\n      },\n      {\n        variant: \"default\",\n        direction: \"left\",\n        class:\n          \"max-w-screen w-screen  rounded-r-xl sm:max-w-sm [&[data-starting-style]]:-translate-x-[var(--drawer-offset)] [&[data-ending-style]]:-translate-x-[var(--drawer-offset)]\",\n      },\n      // Floating variant - direction-specific sizing and transforms\n      {\n        variant: \"floating\",\n        direction: \"bottom\",\n        class:\n          \"mx-auto max-h-[calc(100dvh-2rem)] w-[calc(100%-2rem)] max-w-[calc(100%-2rem)] [&[data-starting-style]]:translate-y-[var(--drawer-offset)] [&[data-ending-style]]:translate-y-[var(--drawer-offset)]\",\n      },\n      {\n        variant: \"floating\",\n        direction: \"top\",\n        class:\n          \"mx-auto max-h-[calc(100dvh-2rem)] w-[calc(100%-2rem)] max-w-[calc(100%-2rem)] [&[data-starting-style]]:-translate-y-[var(--drawer-offset)] [&[data-ending-style]]:-translate-y-[var(--drawer-offset)]\",\n      },\n      {\n        variant: \"floating\",\n        direction: \"right\",\n        class:\n          \"h-[calc(100dvh-2rem)] w-[calc(100vw-2rem)] max-w-[calc(100vw-2rem)] sm:max-w-sm [&[data-starting-style]]:translate-x-[var(--drawer-offset)] [&[data-ending-style]]:translate-x-[var(--drawer-offset)]\",\n      },\n      {\n        variant: \"floating\",\n        direction: \"left\",\n        class:\n          \"h-[calc(100dvh-2rem)] w-[calc(100vw-2rem)] max-w-[calc(100vw-2rem)] sm:max-w-sm [&[data-starting-style]]:-translate-x-[var(--drawer-offset)] [&[data-ending-style]]:-translate-x-[var(--drawer-offset)]\",\n      },\n    ],\n    defaultVariants: {\n      variant: \"default\",\n      direction: \"bottom\",\n    },\n  },\n);\n\nconst drawerTrackVariants = cva(\"pointer-events-none relative flex\", {\n  variants: {\n    direction: {\n      bottom: \"w-full flex-col justify-end\",\n      top: \"w-full flex-col justify-start\",\n      right: \"h-full flex-row justify-end\",\n      left: \"h-full flex-row justify-start\",\n    },\n  },\n  defaultVariants: {\n    direction: \"bottom\",\n  },\n});\n\n// Backdrop scroll-driven animation styles (used conditionally at runtime)\nconst backdropAnimationStyles: Record<DrawerDirection, string> = {\n  // Bottom/Right: drawer enters from below/right → use entry range (0→1 opacity)\n  bottom:\n    \"fill-mode-[both] [animation-name:drawer-backdrop-fade] [animation-range:entry_0%_entry_100%] [animation-timeline:--drawer-panel] [animation-timing-function:linear]\",\n  right:\n    \"fill-mode-[both] [animation-name:drawer-backdrop-fade] [animation-range:entry_0%_entry_100%] [animation-timeline:--drawer-panel] [animation-timing-function:linear]\",\n  // Top/Left: drawer exits toward top/left → use exit range with reversed keyframe (1→0 opacity)\n  top: \"fill-mode-[both] direction-[reverse] [animation-name:drawer-backdrop-fade] [animation-range:exit_0%_exit_100%] [animation-timeline:--drawer-panel] [animation-timing-function:linear]\",\n  left: \"fill-mode-[both] direction-[reverse] [animation-name:drawer-backdrop-fade] [animation-range:exit_0%_exit_100%] [animation-timeline:--drawer-panel] [animation-timing-function:linear]\",\n};\n\n/* -------------------------------------------------------------------------------------------------\n * Drawer Context\n * -------------------------------------------------------------------------------------------------*/\n\ntype DrawerVariant = \"default\" | \"floating\";\n\ninterface DrawerContextValue {\n  direction: DrawerDirection;\n  variant: DrawerVariant;\n  snapPoints: SnapPoint[];\n  activeSnapPoint: SnapPoint;\n  setActiveSnapPoint: (snapPoint: SnapPoint) => void;\n  dismissible: boolean;\n  /** Modal behavior passed to Base UI Dialog */\n  modal: boolean | \"trap-focus\";\n  isDragging: boolean;\n  setIsDragging: (dragging: boolean) => void;\n  dragProgress: number;\n  setDragProgress: (progress: number) => void;\n  /** Progress between snap points (0 = first snap, 1 = last snap) */\n  snapProgress: number;\n  setSnapProgress: (progress: number) => void;\n  open: boolean;\n  onOpenChange: (open: boolean, eventDetails?: { reason?: string }) => void;\n\n  contentSize: number | null;\n  setContentSize: (size: number | null) => void;\n  isVertical: boolean;\n  isAnimating: boolean;\n  immediateClose: boolean;\n  setImmediateClose: (value: boolean) => void;\n  sequentialSnap: boolean;\n  /** Whether to reposition drawer when virtual keyboard appears. */\n  repositionInputs: boolean;\n}\n\nconst DrawerContext = React.createContext<DrawerContextValue | null>(null);\n\nfunction useDrawer() {\n  const context = React.useContext(DrawerContext);\n  if (!context) {\n    throw new Error(\"Drawer components must be used within a <Drawer />\");\n  }\n  return context;\n}\n\n/* -------------------------------------------------------------------------------------------------\n * Drawer (Root)\n * -------------------------------------------------------------------------------------------------*/\n\n/** Props passed to render function children */\ninterface DrawerRenderProps {\n  /** Progress between snap points (0 = first snap, 1 = last snap) */\n  snapProgress: number;\n  /** Progress toward closed (0 = open, 1 = closed) */\n  dragProgress: number;\n  /** Whether currently being dragged/scrolled */\n  isDragging: boolean;\n  /** Current active snap point value */\n  activeSnapPoint: SnapPoint;\n}\n\ninterface DrawerProps extends Omit<\n  React.ComponentProps<typeof BaseDialog.Root>,\n  \"children\"\n> {\n  /** Direction the drawer opens from. Default: \"bottom\" */\n  direction?: DrawerDirection;\n  /** Visual variant of the drawer. Default: \"default\" */\n  variant?: DrawerVariant;\n  /** Snap points as percentages (0-1) or pixel values. Default: [1] (fully open) */\n  snapPoints?: SnapPoint[];\n  /** Initial snap point value when opened. Default: first snap point */\n  defaultSnapPoint?: SnapPoint;\n  /** Controlled snap point value (the actual value, not index) */\n  activeSnapPoint?: SnapPoint | null;\n  /** Callback when snap point changes - receives the actual value */\n  onActiveSnapPointChange?: (snapPoint: SnapPoint) => void;\n  /** Whether dismissible by swipe. Default: true */\n  dismissible?: boolean;\n  /**\n   * Modal behavior:\n   * - `true`: Focus trapped, outside pointer disabled, body scroll locked (default)\n   * - `\"trap-focus\"`: Focus trapped, outside pointer enabled, no scroll lock\n   * - `false`: Non-modal, no focus trapping\n   * @default true\n   */\n  modal?: boolean | \"trap-focus\";\n\n  /** When true, prevents skipping snap points during fast swipes. Default: false */\n  sequentialSnap?: boolean;\n  /** When true, repositions drawer when virtual keyboard appears (bottom direction only). Default: false */\n  repositionInputs?: boolean;\n  /** Children - can be ReactNode or render function for access to drag state */\n  children?: React.ReactNode | ((props: DrawerRenderProps) => React.ReactNode);\n}\n\nfunction Drawer({\n  direction = \"bottom\",\n  variant = \"default\",\n  snapPoints = [1],\n  defaultSnapPoint,\n  activeSnapPoint: controlledSnapPoint,\n  onActiveSnapPointChange,\n  dismissible = true,\n  modal = true,\n  sequentialSnap = false,\n  repositionInputs = false,\n  open: controlledOpen,\n  defaultOpen,\n  onOpenChange: controlledOnOpenChange,\n  children,\n  ...props\n}: DrawerProps) {\n  // Internal open state (uncontrolled mode)\n  const [uncontrolledOpen, setUncontrolledOpen] = React.useState(\n    defaultOpen ?? false,\n  );\n  const isOpenControlled = controlledOpen !== undefined;\n  const open = isOpenControlled ? controlledOpen : uncontrolledOpen;\n\n  // Convert default value to index (defaults to first snap point)\n  const defaultSnapPointIndex =\n    defaultSnapPoint !== undefined\n      ? findSnapPointIndex(snapPoints, defaultSnapPoint)\n      : 0;\n\n  // Internal snap point state (uses index internally)\n  const [internalSnapPointIndex, setInternalSnapPointIndex] = React.useState(\n    defaultSnapPointIndex,\n  );\n\n  // Controlled mode: convert value to index\n  const isSnapPointControlled = controlledSnapPoint !== undefined;\n  const activeSnapPointIndex = isSnapPointControlled\n    ? findSnapPointIndex(snapPoints, controlledSnapPoint)\n    : internalSnapPointIndex;\n\n  // The actual value for context\n  const activeSnapPointValue = getSnapPointValue(\n    snapPoints,\n    activeSnapPointIndex,\n  );\n\n  // Drag state (now represents scroll state)\n  const [isDragging, setIsDragging] = React.useState(false);\n  // Start at 1 (backdrop invisible) - will be updated by scroll events\n  const [dragProgress, setDragProgress] = React.useState(1);\n  // Progress between snap points (0 = first snap, 1 = last snap)\n  const [snapProgress, setSnapProgress] = React.useState(0);\n\n  // Content size for measurements (set by DrawerContent)\n  const [contentSize, setContentSize] = React.useState<number | null>(null);\n\n  // Track CSS animation state to prevent interaction during transitions\n  const [isAnimating, setIsAnimating] = React.useState(false);\n\n  // Track immediate close for swipe dismiss (skip exit animation)\n  const [immediateClose, setImmediateClose] = React.useState(false);\n\n  const { isVertical } = DIRECTION_CONFIG[direction];\n\n  // Clear animating when CSS animation completes\n  const handleOpenChangeComplete = React.useCallback(() => {\n    setIsAnimating(false);\n  }, []);\n\n  // Handle open change\n  const handleOpenChange = React.useCallback(\n    (nextOpen: boolean, eventDetails?: { reason?: string }) => {\n      // Prevent state changes during animations (user can't interrupt enter/exit)\n      if (isAnimating) return;\n      // Prevent closing while actively scrolling/dragging (swipe momentum)\n      // BUT allow swipe dismiss (which passes reason: \"swipe-dismiss\")\n      if (!nextOpen && isDragging && eventDetails?.reason !== \"swipe-dismiss\") {\n        return;\n      }\n\n      // Start animation state - will be cleared by onOpenChangeComplete\n      setIsAnimating(true);\n\n      if (!isOpenControlled) {\n        setUncontrolledOpen(nextOpen);\n      }\n      controlledOnOpenChange?.(nextOpen, eventDetails as never);\n\n      // Reset to default snap point when opening (only in uncontrolled mode)\n      if (nextOpen && !isSnapPointControlled) {\n        setInternalSnapPointIndex(defaultSnapPointIndex);\n        const defaultSnapValue = getSnapPointValue(\n          snapPoints,\n          defaultSnapPointIndex,\n        );\n        onActiveSnapPointChange?.(defaultSnapValue);\n      }\n\n      // Reset state when opening (these persist across drawer sessions since they're in the root)\n      if (nextOpen) {\n        setDragProgress(1); // 1 = closed/invisible, will animate to 0 = open/visible\n        setIsDragging(false); // Reset dragging state (may be stale from swipe dismiss)\n        setImmediateClose(false); // Reset immediate close flag\n        // Only reset snapProgress in uncontrolled mode\n        // Controlled mode: scroll handler will set correct value when drawer positions itself\n        if (!isSnapPointControlled) {\n          // Calculate snapProgress based on default snap point\n          const progress =\n            snapPoints.length > 1\n              ? defaultSnapPointIndex / (snapPoints.length - 1)\n              : 0;\n          setSnapProgress(progress);\n        }\n      }\n    },\n    [\n      isAnimating,\n      isDragging,\n      isOpenControlled,\n      controlledOnOpenChange,\n      snapPoints,\n      isSnapPointControlled,\n      onActiveSnapPointChange,\n      defaultSnapPointIndex,\n    ],\n  );\n\n  // Handle snap point change (accepts value, converts to index internally)\n  const setActiveSnapPoint = React.useCallback(\n    (value: SnapPoint) => {\n      const index = findSnapPointIndex(snapPoints, value);\n      if (!isSnapPointControlled) {\n        setInternalSnapPointIndex(index);\n      }\n      onActiveSnapPointChange?.(value);\n    },\n    [snapPoints, isSnapPointControlled, onActiveSnapPointChange],\n  );\n\n  const contextValue = React.useMemo(\n    () => ({\n      direction,\n      variant,\n      snapPoints,\n      activeSnapPoint: activeSnapPointValue,\n      setActiveSnapPoint,\n      dismissible,\n      modal,\n      isDragging,\n      setIsDragging,\n      dragProgress,\n      setDragProgress,\n      snapProgress,\n      setSnapProgress,\n      open,\n      onOpenChange: handleOpenChange,\n      contentSize,\n      setContentSize,\n      isVertical,\n      isAnimating,\n      immediateClose,\n      setImmediateClose,\n      sequentialSnap,\n      repositionInputs,\n    }),\n    [\n      direction,\n      variant,\n      snapPoints,\n      activeSnapPointValue,\n      setActiveSnapPoint,\n      modal,\n      dismissible,\n      isDragging,\n      dragProgress,\n      snapProgress,\n      open,\n      handleOpenChange,\n      contentSize,\n      isVertical,\n      isAnimating,\n      immediateClose,\n      sequentialSnap,\n      repositionInputs,\n    ],\n  );\n\n  // Resolve render function children\n  const resolvedChildren =\n    typeof children === \"function\"\n      ? children({\n          snapProgress,\n          dragProgress,\n          isDragging,\n          activeSnapPoint: activeSnapPointValue,\n        })\n      : children;\n\n  return (\n    <DrawerContext.Provider value={contextValue}>\n      <BaseDialog.Root\n        data-slot=\"drawer\"\n        open={open}\n        onOpenChange={handleOpenChange}\n        onOpenChangeComplete={handleOpenChangeComplete}\n        modal={modal}\n        // For non-modal modes, disable outside click dismissal so page interaction doesn't close drawer\n        disablePointerDismissal={modal !== true}\n        {...props}\n      >\n        {resolvedChildren}\n      </BaseDialog.Root>\n    </DrawerContext.Provider>\n  );\n}\n\n/* -------------------------------------------------------------------------------------------------\n * DrawerTrigger\n * -------------------------------------------------------------------------------------------------*/\n\nfunction DrawerTrigger({\n  ...props\n}: React.ComponentProps<typeof BaseDialog.Trigger>) {\n  return <BaseDialog.Trigger data-slot=\"drawer-trigger\" {...props} />;\n}\n\n/* -------------------------------------------------------------------------------------------------\n * DrawerClose\n * -------------------------------------------------------------------------------------------------*/\n\ninterface DrawerCloseProps extends useRender.ComponentProps<\"button\"> {\n  onClick?: (event: React.MouseEvent) => void;\n}\n\nfunction DrawerClose({\n  onClick,\n  className,\n  render,\n  ...props\n}: DrawerCloseProps) {\n  const { onOpenChange, isAnimating } = useDrawer();\n\n  const handleClick = React.useCallback(\n    (event: React.MouseEvent) => {\n      onClick?.(event);\n      if (event.defaultPrevented) return;\n      // Prevent closing during animations\n      if (isAnimating) return;\n\n      // Let Base UI handle the exit animation via data-ending-style\n      onOpenChange(false);\n    },\n    [onClick, onOpenChange, isAnimating],\n  );\n\n  // Don't use BaseDialog.Close - it has its own close handler that bypasses our animation\n  const defaultProps = {\n    \"data-slot\": \"drawer-close\",\n    type: \"button\" as const,\n    className,\n    onClick: handleClick,\n  };\n\n  const element = useRender({\n    defaultTagName: \"button\",\n    render,\n    props: mergeProps<\"button\">(defaultProps, props),\n  });\n\n  return element;\n}\n\n/* -------------------------------------------------------------------------------------------------\n * DrawerPortal\n * -------------------------------------------------------------------------------------------------*/\n\nfunction DrawerPortal({\n  ...props\n}: React.ComponentProps<typeof BaseDialog.Portal>) {\n  return <BaseDialog.Portal data-slot=\"drawer-portal\" {...props} />;\n}\n\n/* -------------------------------------------------------------------------------------------------\n * DrawerContent\n * -------------------------------------------------------------------------------------------------*/\n\ninterface DrawerContentProps extends BaseDialog.Popup.Props {\n  /** Visual style variant for the footer. */\n  footerVariant?: \"default\" | \"inset\";\n}\n\n/**\n * DrawerContent - Outer wrapper that renders the Portal.\n * The actual content is in DrawerContentInner, which only mounts when the Portal is visible.\n * This ensures useScrollSnap gets fresh state on each open (no stale state between sessions).\n *\n * @param initialFocus - Determines the element to focus when the drawer is opened.\n *   - `false`: Do not move focus.\n *   - `true`: Move focus to first tabbable element or popup (default).\n *   - `RefObject<HTMLElement>`: Move focus to the ref element.\n *   - `function`: Called with interaction type, returns element to focus or boolean.\n *\n * @param finalFocus - Determines the element to focus when the drawer is closed.\n *   - `false`: Do not move focus.\n *   - `true`: Move focus to trigger or previously focused element (default).\n *   - `RefObject<HTMLElement>`: Move focus to the ref element.\n *   - `function`: Called with interaction type, returns element to focus or boolean.\n */\nfunction DrawerContent({\n  initialFocus,\n  finalFocus,\n  footerVariant = \"default\",\n  ...props\n}: DrawerContentProps) {\n  return (\n    <DrawerPortal>\n      <DrawerContentInner\n        initialFocus={initialFocus}\n        finalFocus={finalFocus}\n        footerVariant={footerVariant}\n        {...props}\n      />\n    </DrawerPortal>\n  );\n}\n\n/**\n * DrawerContentInner - The actual drawer content that mounts/unmounts with the dialog.\n * Contains useScrollSnap hook which gets fresh state on each mount.\n */\nfunction DrawerContentInner({\n  className,\n  children,\n  footerVariant = \"default\",\n  initialFocus,\n  finalFocus,\n  ...props\n}: DrawerContentProps) {\n  const {\n    direction,\n    variant,\n    snapPoints,\n    activeSnapPoint,\n    setActiveSnapPoint,\n    dismissible,\n    modal,\n    contentSize,\n    setContentSize,\n    isVertical,\n    setIsDragging,\n    dragProgress,\n    setDragProgress,\n    snapProgress,\n    setSnapProgress,\n    onOpenChange,\n    open,\n    isAnimating,\n    immediateClose,\n    setImmediateClose,\n    isDragging,\n    sequentialSnap,\n    repositionInputs,\n  } = useDrawer();\n\n  // Derive index locally - single conversion point for hooks\n  const activeSnapPointIndex = findSnapPointIndex(snapPoints, activeSnapPoint);\n\n  // Handler converts index back to value for context\n  const handleSnapPointChange = React.useCallback(\n    (index: number) => {\n      setActiveSnapPoint(getSnapPointValue(snapPoints, index));\n    },\n    [snapPoints, setActiveSnapPoint],\n  );\n\n  // Virtual keyboard handling (for bottom drawers with form inputs)\n  const { keyboardHeight, isKeyboardVisible } = useVirtualKeyboard({\n    enabled: direction === \"bottom\",\n  });\n\n  // Visual viewport height tracking (for horizontal drawers in non-modal mode)\n  // This provides real-time viewport height that updates immediately with URL bar changes\n  const visualViewportHeight = useVisualViewportHeight({\n    enabled: !isVertical && modal !== true,\n  });\n\n  // Memoize dismiss handler to prevent effect re-runs\n  const handleDismiss = React.useCallback(() => {\n    onOpenChange(false, { reason: \"swipe-dismiss\" });\n  }, [onOpenChange]);\n\n  // Handler for immediate close (swipe dismiss - skip exit animation)\n  const handleImmediateClose = React.useCallback(() => {\n    setImmediateClose(true);\n  }, [setImmediateClose]);\n\n  // Wrap scroll progress callback to skip updates during enter/exit animations\n  // This lets CSS transitions control the backdrop opacity during animations\n  const handleScrollProgress = React.useCallback(\n    (progress: number) => {\n      if (!isAnimating) {\n        setDragProgress(progress);\n      }\n    },\n    [isAnimating, setDragProgress],\n  );\n\n  // Wrap snap progress callback to skip updates during enter/exit animations\n  const handleSnapProgress = React.useCallback(\n    (progress: number) => {\n      if (!isAnimating) {\n        setSnapProgress(progress);\n      }\n    },\n    [isAnimating, setSnapProgress],\n  );\n\n  // Scroll snap hook - containerRef now attaches to Viewport\n  const {\n    containerRef,\n    isScrolling,\n    setSnapTargetRef,\n    trackSize,\n    isInitialized,\n    isClosing,\n  } = useScrollSnap({\n    direction,\n    snapPoints,\n    activeSnapPointIndex,\n    onSnapPointChange: handleSnapPointChange,\n    onDismiss: handleDismiss,\n    dismissible,\n    contentSize,\n    open,\n    onScrollProgress: handleScrollProgress,\n    onSnapProgress: handleSnapProgress,\n    onImmediateClose: handleImmediateClose,\n    isAnimating,\n    onScrollingChange: setIsDragging,\n  });\n\n  // Calculate snap point ratio (0-1) for backdrop opacity\n  // This represents how \"open\" the drawer is at the target snap point\n  const snapPointRatio = React.useMemo(() => {\n    if (typeof activeSnapPoint === \"number\") {\n      return activeSnapPoint;\n    }\n    // Pixel value - need contentSize to calculate ratio\n    const pixels = parsePixelValue(activeSnapPoint);\n    if (!pixels || !contentSize) return 1;\n    return pixels / contentSize;\n  }, [activeSnapPoint, contentSize]);\n\n  // Calculate first and last snap ratios for CSS animation-range\n  // These are used in calc() expressions instead of pre-calculated pixel values\n  const firstSnapRatio =\n    contentSize != null\n      ? snapPointToRatio(snapPoints[0], contentSize)\n      : typeof snapPoints[0] === \"number\"\n        ? snapPoints[0]\n        : 1;\n  const lastSnapRatio =\n    contentSize != null\n      ? snapPointToRatio(snapPoints[snapPoints.length - 1], contentSize)\n      : typeof snapPoints[snapPoints.length - 1] === \"number\"\n        ? snapPoints[snapPoints.length - 1]\n        : 1;\n\n  // Animation offset based on active snap point\n  // For pixel snap points, use the value directly (e.g., \"92px\")\n  // For percentage snap points, convert to percentage (e.g., 0.25 -> \"25%\")\n  const baseOffset =\n    typeof activeSnapPoint === \"number\"\n      ? `${activeSnapPoint * 100}%`\n      : activeSnapPoint;\n  const animationOffset =\n    variant === \"floating\" ? `calc(${baseOffset} + 1rem)` : baseOffset;\n\n  // Target backdrop opacity based on snap point (0.25 snap = 0.25 opacity)\n  const targetBackdropOpacity = snapPointRatio;\n\n  // Measure the drawer content size (now measures the Popup element)\n  // For floating variant, add margin to size so scroll calculations account for it\n  const observerRef = React.useRef<ResizeObserver | null>(null);\n  const floatingMargin = variant === \"floating\" ? 16 : 0; // m-4 = 1rem = 16px\n\n  const measureRef = React.useCallback(\n    (node: HTMLDivElement | null) => {\n      // Cleanup previous observer\n      observerRef.current?.disconnect();\n      observerRef.current = null;\n\n      if (!node) return;\n\n      const measure = () => {\n        const baseSize = isVertical ? node.offsetHeight : node.offsetWidth;\n        // Add margin for floating variant so drawer scrolls fully off-screen\n        setContentSize(baseSize + floatingMargin);\n      };\n\n      measure();\n      observerRef.current = new ResizeObserver(measure);\n      observerRef.current.observe(node);\n    },\n    [isVertical, setContentSize, floatingMargin],\n  );\n\n  // Cleanup on unmount\n  React.useEffect(() => () => observerRef.current?.disconnect(), []);\n\n  // Determine if scroll-driven animations should be active\n  // Requires: browser support + initialized + not during enter/exit animation\n  const useScrollDrivenAnimation =\n    supportsScrollTimeline && isInitialized && !isAnimating && !immediateClose;\n\n  return (\n    // Timeline scope wrapper - enables cross-element timeline references\n    // Required for backdrop to reference drawer panel's view timeline\n    <div\n      data-slot=\"drawer-timeline-scope\"\n      style={\n        supportsScrollTimeline\n          ? ({ timelineScope: \"--drawer-panel\" } as React.CSSProperties)\n          : undefined\n      }\n    >\n      {/* Backdrop - view-driven opacity (Chrome 115+) with JS fallback */}\n      {/* Only render backdrop when modal={true} - other modes allow page interaction */}\n      {modal === true && (\n        <BaseDialog.Backdrop\n          data-slot=\"drawer-overlay\"\n          className={cn(\n            \"absolute inset-0 z-50 bg-black/35\",\n            // Force GPU layer to prevent repaint flicker\n            \"[transform:translateZ(0)] will-change-[opacity]\",\n            // Disable pointer events during closing to avoid interfering with swipe dismiss\n            isClosing ? \"pointer-events-none\" : \"pointer-events-auto\",\n            // Prevent touch-drag on backdrop from scrolling the page underneath\n            \"touch-none\",\n            // Transition for smooth enter/exit (skip on immediate close or while dragging)\n            immediateClose || (isDragging && !isAnimating)\n              ? \"transition-none\"\n              : \"ease-[cubic-bezier(0, 0, 0.58, 1)] transition-opacity duration-350\",\n            // Enter: start at opacity 0, transition animates to target\n            \"[&[data-starting-style]]:opacity-0!\",\n            // Exit: use animation to override scroll-driven animation (transition can't interpolate from animation-held values)\n            // \"[&[data-ending-style]]:[animation:drawer-backdrop-exit_450ms_cubic-bezier(0,0,0.58,1)_forwards]\",\n            \"[&[data-ending-style]]:opacity-0\",\n\n            isInitialized && !isAnimating && isDragging && dismissible\n              ? useScrollDrivenAnimation\n                ? // Scroll-driven backdrop animation (Chrome 115+)\n                  backdropAnimationStyles[direction]\n                : `opacity-(--drawer-backdrop-dynamic-opacity)`\n              : `opacity-(--drawer-backdrop-static-opacity)`,\n          )}\n          style={\n            {\n              \"--drawer-backdrop-dynamic-opacity\": 1 - dragProgress,\n              \"--drawer-backdrop-static-opacity\": targetBackdropOpacity,\n            } as React.CSSProperties\n          }\n        />\n      )}\n\n      {/* Viewport - scroll container for scroll-snap gestures */}\n      <BaseDialog.Viewport\n        ref={containerRef}\n        data-slot=\"drawer-viewport\"\n        data-direction={direction}\n        data-scrolling={isScrolling || undefined}\n        data-keyboard-visible={\n          direction === \"bottom\" && repositionInputs && isKeyboardVisible\n            ? \"true\"\n            : undefined\n        }\n        className={cn(\n          // Group for propagating data-starting-style/data-ending-style to children\n          \"group/drawer\",\n          // Fixed positioning\n          \"fixed inset-x-0 z-50 outline-hidden\",\n          // Bottom drawer: anchor to bottom edge\n          // Modal mode: -60px top buffer + dynamic height to prevent URL bar collapse on drag\n          // Non-modal modes: anchor to bottom with fixed lvh height extending upward\n          // (top-auto unsets the top:0 from inset-0, so container anchors from bottom)\n          direction === \"bottom\" &&\n            (modal === true\n              ? \"top-[-60px] bottom-[env(keyboard-inset-height,var(--keyboard-height,0))]\"\n              : \"top-auto! bottom-[env(keyboard-inset-height,var(--keyboard-height,0))] h-lvh\"),\n          // Top drawer: anchor top, extend below for scroll space\n          direction === \"top\" && \"top-0! bottom-[-60px]!\",\n          // Horizontal drawers: full viewport height\n          !isVertical &&\n            (modal === true\n              ? \"top-0! bottom-0! h-dvh\"\n              : \"top-0! bottom-0 h-lvh\"),\n\n          // Disable all interaction when animating, closing, or non-modal\n          // (non-modal modes allow page interaction - Popup has its own pointer-events-auto)\n          isAnimating || isClosing || modal !== true\n            ? \"pointer-events-none\"\n            : \"pointer-events-auto\",\n          // Prevent Base UI's default animation and ensure transparent background\n          \"bg-transparent opacity-100! [&[data-ending-style]]:opacity-100! [&[data-starting-style]]:opacity-100!\",\n\n          // Hide scrollbar\n          \"[scrollbar-width:none_!important] [&::-webkit-scrollbar]:hidden!\",\n          // Scroll snap configuration - disable scrolling when animating or closing\n          isAnimating || isClosing\n            ? \"touch-none overflow-hidden\"\n            : isVertical\n              ? \"touch-pan-y overflow-x-hidden overflow-y-auto overscroll-y-none\"\n              : \"touch-pan-x overflow-x-auto overflow-y-hidden overscroll-x-none\",\n          // Constrain touch gestures to drawer scroll direction only (prevents URL bar collapse/expand)\n          isVertical ? \"touch-pan-y\" : \"touch-pan-x\",\n          // Reduced motion: instant behavior\n          \"motion-reduce:[scroll-behavior:auto]\",\n        )}\n        style={\n          {\n            ...(visualViewportHeight != null && {\n              \"--visual-viewport-height\": `${visualViewportHeight}px`,\n            }),\n            ...(repositionInputs && {\n              \"--keyboard-height\": `${keyboardHeight}px`,\n            }),\n            // CSS variables for scroll-driven animation calc() expressions\n            // These enable animation-range to be computed in CSS instead of JS\n            ...{\n              \"--content-size\": `${contentSize ?? 0}px`,\n              \"--dismiss-buffer\": dismissible\n                ? `${(contentSize ?? 0) * 0.3}px`\n                : \"0px\",\n              \"--first-snap-ratio\": firstSnapRatio,\n              \"--last-snap-ratio\": lastSnapRatio,\n            },\n            // Disable scroll-snap until initialized to prevent browser snapping to wrong position\n            // For inverted directions (top/left), scroll 0 = fully open, which causes incorrect initial state\n            scrollSnapType: isInitialized\n              ? isVertical\n                ? \"y mandatory\"\n                : \"x mandatory\"\n              : \"none\",\n            scrollBehavior: isInitialized ? \"smooth\" : \"auto\",\n            // Reposition drawer when virtual keyboard appears (bottom direction only)\n            // Uses transform (not bottom) to avoid resizing the scroll container\n            // which would mess with scroll positions and snap behavior\n            // transform:\n            //   direction === \"bottom\" &&\n            //   repositionInputs &&\n            //   isKeyboardVisible &&\n            //   keyboardHeight > 0\n            //     ? `translateY(-${keyboardHeight}px)`\n            //     : undefined,\n            // Animate --drawer-snap-progress CSS custom property\n            // Consumers can use: opacity: var(--drawer-snap-progress) for crossfades\n            // Chrome 115+: uses CSS scroll-driven animation\n            // Fallback: sets variable via JS snapProgress state\n            ...(useScrollDrivenAnimation\n              ? {\n                  animationName: \"drawer-snap-progress\",\n                  animationTimingFunction: \"linear\",\n                  animationFillMode: \"both\",\n                  // Horizontal drawers need scroll(self x) to track horizontal scroll\n                  animationTimeline: isVertical\n                    ? \"scroll(self)\"\n                    : \"scroll(self x)\",\n                  // For inverted directions (top/left), scroll decreases as drawer opens\n                  // animation-range requires start < end, so swap values and reverse animation\n                  // Formula: dismissBuffer + ratio * contentSize (non-inverted)\n                  // Or: contentSize * (1 - ratio) (inverted, with reversed animation)\n                  ...(direction === \"top\" || direction === \"left\"\n                    ? {\n                        animationRange: `calc(var(--content-size) * (1 - var(--last-snap-ratio))) calc(var(--content-size) * (1 - var(--first-snap-ratio)))`,\n                        animationDirection: \"reverse\",\n                      }\n                    : {\n                        animationRange: `calc(var(--dismiss-buffer) + var(--first-snap-ratio) * var(--content-size)) calc(var(--dismiss-buffer) + var(--last-snap-ratio) * var(--content-size))`,\n                      }),\n                }\n              : {\n                  \"--drawer-snap-progress\": snapProgress,\n                }),\n          } as React.CSSProperties\n        }\n      >\n        {/* Scroll track - creates the scrollable area */}\n        <div\n          data-slot=\"drawer-track\"\n          className={drawerTrackVariants({ direction })}\n          style={\n            {\n              // Track size: creates the scrollable space\n              [isVertical ? \"height\" : \"width\"]: `${trackSize}px`,\n              // CSS variables for snap target positioning (see drawer.css)\n              \"--content-size\": `${contentSize ?? 0}px`,\n              \"--dismiss-buffer\": dismissible\n                ? `${(contentSize ?? 0) * 0.3}px`\n                : \"0px\",\n            } as React.CSSProperties\n          }\n        >\n          {/* Snap targets - invisible elements for scroll-snap-align */}\n          {/* Positioning handled by CSS using --snap-ratio variable (see drawer.css) */}\n          {/* Also serve as scroll-state containers for CSS queries (Chrome 133+) */}\n          {/* Only render when contentSize is measured - drawer is hidden until then anyway */}\n          {contentSize != null && (\n            <>\n              {/* Dismiss snap target (if dismissible) */}\n              {dismissible && (\n                <div\n                  ref={(el) => setSnapTargetRef(0, el)}\n                  data-slot=\"drawer-snap-target\"\n                  data-snap-index={0}\n                  data-snap-type=\"dismiss\"\n                  className={cn(\n                    \"pointer-events-none absolute\",\n                    isVertical ? \"inset-x-0 h-px\" : \"inset-y-0 w-px\",\n                  )}\n                  style={\n                    {\n                      scrollSnapAlign: \"start\",\n                      scrollSnapStop: sequentialSnap ? \"always\" : undefined,\n                      ...(supportsScrollState && {\n                        containerType: \"scroll-state\",\n                      }),\n                    } as React.CSSProperties\n                  }\n                  aria-hidden=\"true\"\n                />\n              )}\n\n              {/* Snap point targets */}\n              {snapPoints.map((snapPoint, index) => {\n                const snapIndex = dismissible ? index + 1 : index;\n                const ratio = snapPointToRatio(snapPoint, contentSize);\n\n                return (\n                  <div\n                    key={snapIndex}\n                    ref={(el) => setSnapTargetRef(snapIndex, el)}\n                    data-slot=\"drawer-snap-target\"\n                    data-snap-index={snapIndex}\n                    className={cn(\n                      \"pointer-events-none absolute\",\n                      isVertical ? \"inset-x-0 h-px\" : \"inset-y-0 w-px\",\n                    )}\n                    style={\n                      {\n                        \"--snap-ratio\": ratio,\n                        scrollSnapAlign: \"start\",\n                        scrollSnapStop: sequentialSnap ? \"always\" : undefined,\n                        ...(supportsScrollState && {\n                          containerType: \"scroll-state\",\n                        }),\n                      } as React.CSSProperties\n                    }\n                    aria-hidden=\"true\"\n                  />\n                );\n              })}\n            </>\n          )}\n\n          {/* Popup - the actual drawer panel (dialog element with accessibility) */}\n          <BaseDialog.Popup\n            ref={measureRef}\n            data-slot=\"drawer-content\"\n            data-footer-variant={footerVariant}\n            initialFocus={initialFocus}\n            finalFocus={finalFocus}\n            className={cn(\n              drawerContentVariants({ variant, direction }),\n              // Hide until scroll is initialized to prevent flash at wrong position\n              open && !isInitialized && \"opacity-0\",\n              // Disable pointer events during enter/exit animations to prevent interruption\n              isAnimating || isClosing\n                ? \"pointer-events-none\"\n                : \"pointer-events-auto\",\n              // Skip transition on immediate close (swipe dismiss)\n              immediateClose && \"transition-none\",\n              // Safari iOS touch fix: 1px cross-axis overflow (WebKit bug #183870)\n              // Only needed for non-modal modes where viewport has pointer-events:none\n              modal !== true && [\n                \"[@supports(-webkit-touch-callout:none)]:relative [@supports(-webkit-touch-callout:none)]:[scrollbar-width:none]\",\n                isVertical\n                  ? \"[@supports(-webkit-touch-callout:none)]:overflow-x-scroll [@supports(-webkit-touch-callout:none)]:overscroll-x-none [@supports(-webkit-touch-callout:none)]:after:pointer-events-none [@supports(-webkit-touch-callout:none)]:after:absolute [@supports(-webkit-touch-callout:none)]:after:inset-0 [@supports(-webkit-touch-callout:none)]:after:w-[calc(100%+0.5px)] [@supports(-webkit-touch-callout:none)]:after:content-['']\"\n                  : \"[@supports(-webkit-touch-callout:none)]:overflow-y-scroll [@supports(-webkit-touch-callout:none)]:overscroll-y-none [@supports(-webkit-touch-callout:none)]:after:pointer-events-none [@supports(-webkit-touch-callout:none)]:after:absolute [@supports(-webkit-touch-callout:none)]:after:inset-0 [@supports(-webkit-touch-callout:none)]:after:h-[calc(100%+1px)] [@supports(-webkit-touch-callout:none)]:after:content-['']\",\n              ],\n              className,\n            )}\n            style={\n              {\n                // Note: scroll-snap-align is NOT set here - we use dedicated invisible\n                // snap targets instead. Setting it on the Popup creates conflicting\n                // snap points for floating variant (due to margin offset).\n\n                // Dynamic offset for enter/exit animations\n                \"--drawer-offset\": animationOffset,\n\n                // View timeline for backdrop animation (Chrome 115+)\n                // Backdrop opacity tracks how much of drawer is visible\n                ...(supportsScrollTimeline && {\n                  viewTimelineName: \"--drawer-panel\",\n                  viewTimelineAxis: isVertical ? \"block\" : \"inline\",\n                }),\n              } as React.CSSProperties\n            }\n            {...props}\n          >\n            {children}\n          </BaseDialog.Popup>\n        </div>\n\n        {/* iOS 26 Safari: Fixed element at bottom for nav bar color detection */}\n        {/* Must be: within 3px of bottom, ≥80% wide, ≥3px tall */}\n        {/* Only visible on Safari; slides with drawer during exit */}\n\n        <>\n          <div\n            aria-hidden=\"true\"\n            className={cn(\n              \"bg-popover pointer-events-none fixed inset-x-0 bottom-0 hidden h-10 bg-clip-text [@supports(-webkit-touch-callout:none)]:block\",\n            )}\n          />\n          <div\n            aria-hidden=\"true\"\n            className={cn(\n              \"bg-popover pointer-events-none fixed inset-x-0 top-0 hidden h-10 bg-clip-text [@supports(-webkit-touch-callout:none)]:block\",\n            )}\n          />\n        </>\n      </BaseDialog.Viewport>\n    </div>\n  );\n}\n\n/* -------------------------------------------------------------------------------------------------\n * DrawerHandle\n * -------------------------------------------------------------------------------------------------*/\n\ninterface DrawerHandleProps extends Omit<\n  React.ComponentProps<\"button\">,\n  \"children\"\n> {\n  /** Hide the handle visually */\n  hidden?: boolean;\n  /** Disable click-to-close behavior (visual-only mode). Default: false */\n  preventClose?: boolean;\n}\n\n/**\n * DrawerHandle - Interactive handle that closes the drawer when clicked.\n * On touch devices, users typically swipe the drawer to dismiss.\n * On non-touch devices, clicking the handle provides an intuitive close action.\n */\nfunction DrawerHandle({\n  className,\n  hidden,\n  preventClose = false,\n  onClick,\n  ...props\n}: DrawerHandleProps) {\n  const { direction, onOpenChange, isAnimating } = useDrawer();\n  const { isVertical } = DIRECTION_CONFIG[direction];\n\n  if (hidden) return null;\n\n  const handleClick = (event: React.MouseEvent<HTMLButtonElement>) => {\n    onClick?.(event);\n    if (event.defaultPrevented) return;\n    if (isAnimating || preventClose) return;\n    onOpenChange(false);\n  };\n\n  return (\n    <button\n      type=\"button\"\n      data-slot=\"drawer-handle\"\n      aria-label=\"Close drawer\"\n      onClick={handleClick}\n      className={cn(\n        // Reset button styles\n        \"appearance-none border-0 bg-transparent p-0\",\n        // Focus ring for keyboard users\n        \"focus-visible:ring-ring/50 rounded-sm outline-none focus-visible:ring-2 focus-visible:ring-offset-2\",\n        // Visual handle styles\n        \"bg-muted-foreground/30 shrink-0 cursor-pointer rounded-full\",\n        isVertical ? \"mx-auto my-3 h-1.5 w-12\" : \"mx-3 my-auto h-12 w-1.5\",\n        // Hover state\n        \"hover:bg-muted-foreground/50 transition-colors\",\n        className,\n      )}\n      {...props}\n    />\n  );\n}\n\n/* -------------------------------------------------------------------------------------------------\n * DrawerHeader\n * -------------------------------------------------------------------------------------------------*/\n\nfunction DrawerHeader({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"drawer-header\"\n      className={cn(\n        \"flex flex-col gap-1.5 px-5 pt-5 pb-3\",\n        // Reduce bottom padding when header is directly before footer (no body)\n        \"not-has-[+[data-slot=drawer-body]]:has-[+[data-slot=drawer-footer]]:pb-1\",\n        // Add extra bottom padding when header is alone (no body or footer)\n        \"not-has-[+[data-slot=drawer-body]]:not-has-[+[data-slot=drawer-footer]]:pb-5\",\n        // Inset footer variant: add extra bottom padding when header is directly before footer (no body)\n        \"in-data-[footer-variant=inset]:not-has-[+[data-slot=drawer-body]]:has-[+[data-slot=drawer-footer]]:pb-5\",\n        className,\n      )}\n      {...props}\n    />\n  );\n}\n\n/* -------------------------------------------------------------------------------------------------\n * DrawerFooter\n * -------------------------------------------------------------------------------------------------*/\n\nfunction DrawerFooter({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"drawer-footer\"\n      className={cn(\n        \"bg-popover mt-auto flex flex-col gap-2 px-5 pt-3 pb-5\",\n        // Add extra top padding when footer is first (no header or body before it)\n        // Note: first: works when no Handle precedes; for Handle-first layouts\n        // without header/body, add className=\"pt-5\" manually\n        \"first:pt-5\",\n        // Inset variant: muted background with top border for separation\n        \"in-data-[footer-variant=inset]:border-border in-data-[footer-variant=inset]:bg-muted in-data-[footer-variant=inset]:border-t in-data-[footer-variant=inset]:pt-4 in-data-[footer-variant=inset]:pb-4\",\n        className,\n      )}\n      {...props}\n    />\n  );\n}\n\n/* -------------------------------------------------------------------------------------------------\n * DrawerTitle\n * -------------------------------------------------------------------------------------------------*/\n\nfunction DrawerTitle({\n  className,\n  ...props\n}: React.ComponentProps<typeof BaseDialog.Title>) {\n  return (\n    <BaseDialog.Title\n      data-slot=\"drawer-title\"\n      className={cn(\"text-foreground text-lg font-semibold\", className)}\n      {...props}\n    />\n  );\n}\n\n/* -------------------------------------------------------------------------------------------------\n * DrawerDescription\n * -------------------------------------------------------------------------------------------------*/\n\nfunction DrawerDescription({\n  className,\n  ...props\n}: React.ComponentProps<typeof BaseDialog.Description>) {\n  return (\n    <BaseDialog.Description\n      data-slot=\"drawer-description\"\n      className={cn(\"text-muted-foreground text-sm\", className)}\n      {...props}\n    />\n  );\n}\n\n/* -------------------------------------------------------------------------------------------------\n * DrawerBody\n * -------------------------------------------------------------------------------------------------*/\n\nfunction DrawerBody({\n  className,\n  nativeScroll = false,\n  fadeEdges = false,\n  scrollbarGutter = false,\n  persistScrollbar,\n  hideScrollbar,\n  children,\n  ...props\n}: React.ComponentProps<\"div\"> & {\n  nativeScroll?: boolean;\n} & Pick<\n    ScrollAreaProps,\n    \"fadeEdges\" | \"scrollbarGutter\" | \"persistScrollbar\" | \"hideScrollbar\"\n  >) {\n  const { direction } = useDrawer();\n  const { isVertical } = DIRECTION_CONFIG[direction];\n\n  return (\n    <div\n      data-slot=\"drawer-body\"\n      className={cn(\n        \"flex min-h-0 flex-1 flex-col overflow-hidden\",\n        \"first:pt-4\",\n        \"not-has-[+[data-slot=drawer-footer]]:pb-4\",\n        \"in-data-[footer-variant=inset]:has-[+[data-slot=drawer-footer]]:pb-4\",\n      )}\n    >\n      <ScrollArea\n        className=\"flex-1\"\n        // fadedges is false by default since it can cause issues with the drawer animation on mobile devices\n        fadeEdges={fadeEdges}\n        scrollbarGutter={scrollbarGutter}\n        persistScrollbar={persistScrollbar}\n        hideScrollbar={hideScrollbar}\n        nativeScroll={nativeScroll}\n        overscrollBehavior=\"auto\"\n        viewportClassName={isVertical ? \"touch-pan-y\" : \"touch-pan-x\"}\n      >\n        <div className={cn(\"px-5 py-1\", className)} {...props}>\n          {children}\n        </div>\n      </ScrollArea>\n    </div>\n  );\n}\n\n/* -------------------------------------------------------------------------------------------------\n * Exports\n * -------------------------------------------------------------------------------------------------*/\n\nexport {\n  Drawer,\n  DrawerTrigger,\n  DrawerClose,\n  DrawerPortal,\n  DrawerContent,\n  DrawerHandle,\n  DrawerHeader,\n  DrawerFooter,\n  DrawerTitle,\n  DrawerDescription,\n  DrawerBody,\n  useDrawer,\n  createDrawerHandle,\n};\n\nexport type { DrawerRenderProps, DrawerVariant };\n\n// Re-export feature detection for consumers who want to check browser support\nexport { supportsScrollTimeline, supportsScrollState };\n",
      "type": "registry:ui",
      "target": "components/ui/cubby-ui/drawer/drawer.tsx"
    },
    {
      "path": "registry/default/drawer/lib/drawer-utils.ts",
      "content": "/* -------------------------------------------------------------------------------------------------\r\n * Types\r\n * -------------------------------------------------------------------------------------------------*/\r\n\r\nexport type DrawerDirection = \"top\" | \"right\" | \"bottom\" | \"left\";\r\n\r\n/**\r\n * Snap point value:\r\n * - number (0-1): percentage of drawer visible (0 = closed, 1 = fully open)\r\n * - `${number}px`: fixed pixel height visible (e.g., \"200px\")\r\n */\r\nexport type SnapPoint = number | `${number}px`;\r\n\r\n/**\r\n * Direction configuration for drawer behavior.\r\n * Eliminates repeated conditionals throughout the codebase.\r\n */\r\nexport const DIRECTION_CONFIG = {\r\n  top: { isVertical: true, isInverted: true },\r\n  bottom: { isVertical: true, isInverted: false },\r\n  left: { isVertical: false, isInverted: true },\r\n  right: { isVertical: false, isInverted: false },\r\n} as const;\r\n\r\nexport type DirectionConfig = (typeof DIRECTION_CONFIG)[DrawerDirection];\r\n\r\n/**\r\n * Scroll geometry for drawer positioning calculations.\r\n */\r\nexport interface ScrollGeometry {\r\n  /** Total track size (viewport + content + dismiss buffer) */\r\n  trackSize: number;\r\n  /** Buffer space for dismiss gesture */\r\n  dismissBuffer: number;\r\n  /** Maximum scroll position */\r\n  maxScroll: number;\r\n  /** Whether scroll direction is inverted (top/left) */\r\n  isInverted: boolean;\r\n}\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * Browser Support Detection\r\n * -------------------------------------------------------------------------------------------------*/\r\n\r\nexport const supportsScrollEnd =\r\n  typeof window !== \"undefined\" && \"onscrollend\" in window;\r\n\r\n/**\r\n * Feature detection for scroll-driven animations (animation-timeline: scroll())\r\n * Chrome 115+, Safari 26+ (future), Firefox flag-only\r\n */\r\nexport const supportsScrollTimeline =\r\n  typeof CSS !== \"undefined\" &&\r\n  CSS.supports(\"animation-timeline\", \"scroll()\") &&\r\n  CSS.supports(\"timeline-scope\", \"--test\");\r\n\r\n/**\r\n * Feature detection for scroll snap events (scrollsnapchange, scrollsnapchanging)\r\n * Chrome 129+ only\r\n */\r\nexport const supportsScrollSnapChange =\r\n  typeof window !== \"undefined\" && \"onscrollsnapchange\" in window;\r\n\r\n/**\r\n * Feature detection for CSS scroll-state() container queries\r\n * Chrome 133+ only\r\n */\r\nexport const supportsScrollState =\r\n  typeof CSS !== \"undefined\" && CSS.supports(\"container-type\", \"scroll-state\");\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * Utility Functions\r\n * -------------------------------------------------------------------------------------------------*/\r\n\r\n/**\r\n * Parse a pixel value string (e.g., \"200px\") and return the number\r\n */\r\nexport function parsePixelValue(value: string): number | null {\r\n  const match = value.match(/^(\\d+(?:\\.\\d+)?)px$/);\r\n  return match ? parseFloat(match[1]) : null;\r\n}\r\n\r\n/**\r\n * Convert a snap point to a ratio (0-1).\r\n * For percentage snap points, returns the value directly.\r\n * For pixel snap points, divides by contentSize.\r\n */\r\nexport function snapPointToRatio(\r\n  snapPoint: SnapPoint,\r\n  contentSize: number,\r\n): number {\r\n  if (typeof snapPoint === \"number\") {\r\n    return snapPoint;\r\n  }\r\n  const pixels = parsePixelValue(snapPoint);\r\n  return pixels != null ? pixels / contentSize : 1;\r\n}\r\n\r\n/**\r\n * Find the index of a snap point value in the array\r\n * Returns the last index if value is null or not found\r\n */\r\nexport function findSnapPointIndex(\r\n  snapPoints: SnapPoint[],\r\n  value: SnapPoint | null,\r\n): number {\r\n  if (value === null) return snapPoints.length - 1;\r\n  const index = snapPoints.findIndex((sp) => sp === value);\r\n  return index === -1 ? snapPoints.length - 1 : index;\r\n}\r\n\r\n/**\r\n * Get the snap point value at a given index (clamped to valid range)\r\n */\r\nexport function getSnapPointValue(\r\n  snapPoints: SnapPoint[],\r\n  index: number,\r\n): SnapPoint {\r\n  return snapPoints[Math.max(0, Math.min(index, snapPoints.length - 1))];\r\n}\r\n\r\n/**\r\n * Wait for scroll to end on an element\r\n */\r\nexport function waitForScrollEnd(element: HTMLElement): Promise<void> {\r\n  return new Promise((resolve) => {\r\n    if (supportsScrollEnd) {\r\n      element.addEventListener(\"scrollend\", () => resolve(), { once: true });\r\n    } else {\r\n      // Fallback: debounced scroll detection\r\n      let timeout: ReturnType<typeof setTimeout>;\r\n      const handler = () => {\r\n        clearTimeout(timeout);\r\n        timeout = setTimeout(() => {\r\n          element.removeEventListener(\"scroll\", handler);\r\n          resolve();\r\n        }, 0);\r\n      };\r\n      element.addEventListener(\"scroll\", handler, { passive: true });\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Check if user prefers reduced motion\r\n */\r\nexport function prefersReducedMotion(): boolean {\r\n  if (typeof window === \"undefined\") return false;\r\n  return window.matchMedia(\"(prefers-reduced-motion: reduce)\").matches;\r\n}\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * Scroll Geometry Calculations\r\n * -------------------------------------------------------------------------------------------------*/\r\n\r\n/**\r\n * Calculate scroll geometry for drawer positioning.\r\n * These values determine track size and scroll positions for snap points.\r\n */\r\nexport function calculateScrollGeometry(\r\n  viewportSize: number,\r\n  contentSize: number,\r\n  dismissible: boolean,\r\n  isInverted: boolean,\r\n): ScrollGeometry {\r\n  // Caller is responsible for ensuring contentSize is valid (> 0)\r\n  const dismissBuffer = dismissible ? contentSize * 0.3 : 0;\r\n  const trackSize = viewportSize + contentSize + dismissBuffer;\r\n  const maxScroll = trackSize - viewportSize;\r\n\r\n  return {\r\n    trackSize,\r\n    dismissBuffer,\r\n    maxScroll,\r\n    isInverted,\r\n  };\r\n}\r\n\r\n/**\r\n * Calculate scroll positions for each snap point.\r\n * Returns an array where index 0 is dismiss position (if dismissible),\r\n * followed by positions for each snap point.\r\n */\r\nexport function calculateSnapScrollPositions(\r\n  snapPoints: SnapPoint[],\r\n  geometry: ScrollGeometry,\r\n  dismissible: boolean,\r\n  contentSize: number,\r\n): number[] {\r\n  const { maxScroll, dismissBuffer, isInverted } = geometry;\r\n  const positions: number[] = [];\r\n\r\n  // Add dismiss position first if dismissible\r\n  if (dismissible) {\r\n    positions.push(isInverted ? maxScroll : 0);\r\n  }\r\n\r\n  // Calculate positions for each snap point\r\n  // Note: contentSize here is effectiveSize (with fallback applied)\r\n  for (const snapPoint of snapPoints) {\r\n    const visibleRatio =\r\n      typeof snapPoint === \"string\"\r\n        ? (parsePixelValue(snapPoint) ?? contentSize) / contentSize\r\n        : snapPoint;\r\n\r\n    // Calculate scroll position based on direction\r\n    // Formula: dismissBuffer + visibleRatio * contentSize (non-inverted)\r\n    // Or: maxScroll - dismissBuffer - visibleRatio * contentSize (inverted)\r\n    const scrollPos = isInverted\r\n      ? maxScroll - dismissBuffer - visibleRatio * contentSize\r\n      : dismissBuffer + visibleRatio * contentSize;\r\n\r\n    positions.push(Math.min(maxScroll, Math.max(0, scrollPos)));\r\n  }\r\n\r\n  return positions;\r\n}\r\n\r\n/**\r\n * Calculate progress from scroll position (0 = fully open, 1 = fully closed).\r\n * Used for backdrop opacity animation.\r\n */\r\nexport function calculateScrollProgress(\r\n  scrollPos: number,\r\n  geometry: ScrollGeometry,\r\n  contentSize: number,\r\n): number {\r\n  const { dismissBuffer, isInverted } = geometry;\r\n\r\n  let progress: number;\r\n  if (isInverted) {\r\n    // Top/Left: scroll 0 = open (0), maxScroll = closed (1)\r\n    // openScrollPos simplifies to 0 (maxScroll - dismissBuffer - contentSize = 0)\r\n    progress = scrollPos / contentSize;\r\n  } else {\r\n    // Bottom/Right: 0 = closed (1), maxScroll = open (0)\r\n    progress = 1 - (scrollPos - dismissBuffer) / contentSize;\r\n  }\r\n\r\n  return Math.min(1, Math.max(0, progress));\r\n}\r\n\r\n/**\r\n * Calculate snap progress from scroll position (0 = first snap, 1 = last snap).\r\n * Used for crossfade effects between snap points.\r\n */\r\nexport function calculateSnapProgress(\r\n  scrollPos: number,\r\n  snapScrollPositions: number[],\r\n  dismissible: boolean,\r\n): number {\r\n  const firstSnapIndex = dismissible ? 1 : 0;\r\n  const lastSnapIndex = snapScrollPositions.length - 1;\r\n\r\n  // Handle edge cases\r\n  if (firstSnapIndex >= lastSnapIndex) return 0;\r\n\r\n  const firstSnapPos = snapScrollPositions[firstSnapIndex];\r\n  const lastSnapPos = snapScrollPositions[lastSnapIndex];\r\n\r\n  if (firstSnapPos === lastSnapPos) return 0;\r\n\r\n  const progress =\r\n    (scrollPos - firstSnapPos) / (lastSnapPos - firstSnapPos);\r\n  return Math.min(1, Math.max(0, progress));\r\n}\r\n",
      "type": "registry:lib",
      "target": "components/ui/cubby-ui/drawer/lib/drawer-utils.ts"
    },
    {
      "path": "registry/default/drawer/hooks/use-scroll-snap.ts",
      "content": "import * as React from \"react\";\n\nimport type {\n  DrawerDirection,\n  SnapPoint,\n  ScrollGeometry,\n} from \"../lib/drawer-utils\";\nimport {\n  DIRECTION_CONFIG,\n  supportsScrollEnd,\n  supportsScrollTimeline,\n  supportsScrollState,\n  supportsScrollSnapChange,\n  prefersReducedMotion,\n  waitForScrollEnd,\n  calculateScrollGeometry,\n  calculateSnapScrollPositions,\n  calculateScrollProgress,\n  calculateSnapProgress,\n} from \"../lib/drawer-utils\";\n\n/* -------------------------------------------------------------------------------------------------\n * Types\n * -------------------------------------------------------------------------------------------------*/\n\nexport interface UseScrollSnapOptions {\n  /** Direction the drawer opens from */\n  direction: DrawerDirection;\n  /** Snap points configuration */\n  snapPoints: SnapPoint[];\n  /** Current active snap point index */\n  activeSnapPointIndex: number;\n  /** Callback when snap point changes */\n  onSnapPointChange: (index: number) => void;\n  /** Callback when drawer should be dismissed */\n  onDismiss: () => void;\n  /** Whether drawer can be dismissed by swiping */\n  dismissible: boolean;\n  /** Size of the drawer content */\n  contentSize: number | null;\n  /** Whether the drawer is open */\n  open: boolean;\n  /** Callback during scroll with progress (0-1, where 0 = open, 1 = closed) */\n  onScrollProgress?: (progress: number) => void;\n  /** Callback during scroll with snap progress (0 = first snap, 1 = last snap) */\n  onSnapProgress?: (progress: number) => void;\n  /** Callback to signal immediate close (skip exit animation) for swipe dismiss */\n  onImmediateClose?: () => void;\n  /** Whether the drawer is currently animating (enter/exit CSS transition) */\n  isAnimating?: boolean;\n  /** Callback when scrolling state changes */\n  onScrollingChange?: (isScrolling: boolean) => void;\n}\n\nexport interface UseScrollSnapReturn {\n  /** Ref for the scroll container */\n  containerRef: React.RefObject<HTMLDivElement | null>;\n  /** Whether currently scrolling/dragging */\n  isScrolling: boolean;\n  /** Callback to set snap target ref at a given index */\n  setSnapTargetRef: (index: number, el: HTMLDivElement | null) => void;\n  /** Track size for the scroll container */\n  trackSize: number;\n  /** Whether the initial scroll positioning is complete */\n  isInitialized: boolean;\n  /** Whether the drawer is in the process of closing (pointer events should be disabled) */\n  isClosing: boolean;\n}\n\n/* -------------------------------------------------------------------------------------------------\n * Consolidated Ref Types\n * -------------------------------------------------------------------------------------------------*/\n\ninterface ScrollControlState {\n  /** Whether currently in a programmatic scroll (not user-initiated) */\n  isProgrammatic: boolean;\n  /** Last detected snap index to avoid duplicate callbacks */\n  lastDetectedSnapIndex: number;\n  /** Whether state change came from detection (CSS snap) vs external */\n  isFromDetection: boolean;\n}\n\ninterface InteractionState {\n  /** Whether drawer is closing (disables pointer events) */\n  isClosing: boolean;\n  /** Whether user is actively touching/pressing */\n  isPointerDown: boolean;\n  /** Previous scroll position for movement detection */\n  prevScrollPos: number | null;\n  /** Whether scrollend fired while pointer was down (Firefox: click stops momentum) */\n  scrollEndedWhilePointerDown: boolean;\n}\n\ninterface InitState {\n  /** Whether initial scroll positioning is complete */\n  hasInitialized: boolean;\n  /** Timeout for DOM ready retry */\n  retryTimeout: ReturnType<typeof setTimeout> | null;\n  /** RAF ID for stability check */\n  rafId: number | null;\n  /** Last scroll position for RAF check */\n  rafLastPos: number | null;\n  /** Count of stable frames */\n  rafStableCount: number;\n}\n\n/* -------------------------------------------------------------------------------------------------\n * Hook Implementation\n * -------------------------------------------------------------------------------------------------*/\n\n// Re-export browser support detection for consumers\nexport { supportsScrollTimeline, supportsScrollState };\n\nexport function useScrollSnap(\n  options: UseScrollSnapOptions,\n): UseScrollSnapReturn {\n  const {\n    direction,\n    snapPoints,\n    activeSnapPointIndex,\n    dismissible,\n    contentSize,\n    open,\n    onScrollProgress,\n    onSnapProgress,\n    onScrollingChange,\n  } = options;\n\n  // Get direction config (replaces repeated conditionals)\n  const { isVertical, isInverted } = DIRECTION_CONFIG[direction];\n\n  // DOM refs\n  const containerRef = React.useRef<HTMLDivElement | null>(null);\n  const snapTargetRefs = React.useRef<(HTMLDivElement | null)[]>([]);\n\n  // Consolidated refs (instead of 8+ scattered refs)\n  const scrollControlRef = React.useRef<ScrollControlState>({\n    isProgrammatic: false,\n    lastDetectedSnapIndex: activeSnapPointIndex,\n    isFromDetection: false,\n  });\n\n  // Ref for self-referential RAF callback (avoids ESLint react-hooks/immutability error)\n  const checkScrollStabilityRef = React.useRef<() => void>(() => {});\n\n  const interactionRef = React.useRef<InteractionState>({\n    isClosing: false,\n    isPointerDown: false,\n    prevScrollPos: null,\n    scrollEndedWhilePointerDown: false,\n  });\n\n  const initRef = React.useRef<InitState>({\n    hasInitialized: false,\n    retryTimeout: null,\n    rafId: null,\n    rafLastPos: null,\n    rafStableCount: 0,\n  });\n\n  // Options ref for stable callbacks (avoids effect dependency changes)\n  const optionsRef = React.useRef(options);\n  React.useLayoutEffect(() => {\n    optionsRef.current = options;\n  });\n\n  // React state (only what needs to trigger re-renders)\n  const [isScrolling, setIsScrolling] = React.useState(false);\n  const [isClosing, setIsClosingState] = React.useState(false);\n  const [isInitialized, setIsInitialized] = React.useState(false);\n  const [viewportSize, setViewportSize] = React.useState(() => {\n    if (typeof window === \"undefined\") return 800;\n    return isVertical ? window.innerHeight : window.innerWidth;\n  });\n\n  // Wrapper that updates both ref and state synchronously\n  const setIsClosing = React.useCallback((value: boolean) => {\n    interactionRef.current.isClosing = value;\n    setIsClosingState(value);\n  }, []);\n\n  // Wrapper that updates scrolling state and notifies parent\n  const updateIsScrolling = React.useCallback(\n    (value: boolean) => {\n      setIsScrolling(value);\n      onScrollingChange?.(value);\n    },\n    [onScrollingChange],\n  );\n\n  // Calculate geometry using pure functions (memoized)\n  // Only calculate when contentSize is measured - drawer is hidden until then anyway\n  const hasValidSize = contentSize != null && contentSize > 0;\n\n  const geometry = React.useMemo<ScrollGeometry | null>(\n    () =>\n      hasValidSize\n        ? calculateScrollGeometry(\n            viewportSize,\n            contentSize,\n            dismissible,\n            isInverted,\n          )\n        : null,\n    [viewportSize, contentSize, dismissible, isInverted, hasValidSize],\n  );\n\n  const snapScrollPositions = React.useMemo(\n    () =>\n      geometry && hasValidSize\n        ? calculateSnapScrollPositions(\n            snapPoints,\n            geometry,\n            dismissible,\n            contentSize,\n          )\n        : [],\n    [snapPoints, geometry, dismissible, contentSize, hasValidSize],\n  );\n\n  // Get scroll position for a snap point index\n  const getScrollPositionForSnapPoint = React.useCallback(\n    (index: number): number => {\n      const adjustedIndex = dismissible ? index + 1 : index;\n      return snapScrollPositions[adjustedIndex] ?? 0;\n    },\n    [snapScrollPositions, dismissible],\n  );\n\n  // Find nearest snap point from scroll position\n  const findNearestSnapIndex = React.useCallback(\n    (scrollPos: number): { index: number; isDismiss: boolean } => {\n      let closestIndex = 0;\n      let closestDistance = Infinity;\n\n      snapScrollPositions.forEach((pos, i) => {\n        const distance = Math.abs(scrollPos - pos);\n        if (distance < closestDistance) {\n          closestDistance = distance;\n          closestIndex = i;\n        }\n      });\n\n      if (dismissible && closestIndex === 0) {\n        return { index: 0, isDismiss: true };\n      }\n\n      const snapIndex = dismissible ? closestIndex - 1 : closestIndex;\n      return { index: Math.max(0, snapIndex), isDismiss: false };\n    },\n    [snapScrollPositions, dismissible],\n  );\n\n  // Helper to detect snap point changes and notify (used by scrollend and RAF fallback)\n  const detectAndNotifySnapChange = React.useCallback(\n    (scrollPos: number) => {\n      if (\n        scrollControlRef.current.isProgrammatic ||\n        interactionRef.current.isClosing\n      ) {\n        return;\n      }\n\n      const { index, isDismiss } = findNearestSnapIndex(scrollPos);\n      if (\n        !isDismiss &&\n        index !== scrollControlRef.current.lastDetectedSnapIndex\n      ) {\n        scrollControlRef.current.lastDetectedSnapIndex = index;\n        scrollControlRef.current.isFromDetection = true;\n        optionsRef.current.onSnapPointChange(index);\n      }\n    },\n    [findNearestSnapIndex],\n  );\n\n  // Scroll to a specific snap point\n  const scrollToSnapPoint = React.useCallback(\n    (index: number, behavior: ScrollBehavior = \"smooth\") => {\n      const container = containerRef.current;\n      if (!container) return;\n\n      const scrollPos = getScrollPositionForSnapPoint(index);\n      const actualBehavior = prefersReducedMotion() ? \"auto\" : behavior;\n\n      scrollControlRef.current.isProgrammatic = true;\n      container.scrollTo({\n        [isVertical ? \"top\" : \"left\"]: scrollPos,\n        behavior: actualBehavior,\n      });\n\n      if (actualBehavior === \"auto\") {\n        scrollControlRef.current.isProgrammatic = false;\n      } else {\n        waitForScrollEnd(container).then(() => {\n          scrollControlRef.current.isProgrammatic = false;\n        });\n      }\n    },\n    [getScrollPositionForSnapPoint, isVertical],\n  );\n\n  /* -------------------------------------------------------------------------------------------------\n   * Event Handlers (defined outside effects for stability)\n   * -------------------------------------------------------------------------------------------------*/\n\n  // Helper to trigger dismiss when drawer exits viewport\n  const triggerImmediateDismiss = React.useCallback(() => {\n    if (interactionRef.current.isClosing) return;\n\n    const container = containerRef.current;\n    if (container) {\n      container.style.overflow = \"hidden\";\n      container.style.pointerEvents = \"none\";\n      container.style.touchAction = \"none\";\n    }\n\n    setIsClosing(true);\n    scrollControlRef.current.isProgrammatic = true;\n\n    optionsRef.current.onImmediateClose?.();\n    optionsRef.current.onDismiss();\n  }, [setIsClosing]);\n\n  // RAF-based scroll end detection (fallback for browsers without scrollend)\n  const checkScrollStability = React.useCallback(() => {\n    const container = containerRef.current;\n    if (!container) return;\n\n    const { isVertical: isVert } =\n      DIRECTION_CONFIG[optionsRef.current.direction];\n    const currentPos = isVert ? container.scrollTop : container.scrollLeft;\n    const { rafLastPos } = initRef.current;\n\n    if (rafLastPos !== null && Math.abs(currentPos - rafLastPos) < 0.5) {\n      initRef.current.rafStableCount++;\n      // After 3 stable frames (~50ms), consider scroll ended\n      // But only if user is not actively touching\n      if (\n        initRef.current.rafStableCount >= 3 &&\n        !interactionRef.current.isPointerDown\n      ) {\n        updateIsScrolling(false);\n        detectAndNotifySnapChange(currentPos);\n\n        initRef.current.rafId = null;\n        initRef.current.rafLastPos = null;\n        initRef.current.rafStableCount = 0;\n        return;\n      }\n    } else {\n      initRef.current.rafStableCount = 0;\n    }\n\n    initRef.current.rafLastPos = currentPos;\n    // Use ref to avoid self-reference in useCallback (ESLint react-hooks/immutability)\n    initRef.current.rafId = requestAnimationFrame(\n      checkScrollStabilityRef.current,\n    );\n  }, [updateIsScrolling, detectAndNotifySnapChange]);\n\n  // Keep ref in sync with latest callback\n  React.useLayoutEffect(() => {\n    checkScrollStabilityRef.current = checkScrollStability;\n  });\n\n  const startScrollStabilityCheck = React.useCallback(() => {\n    if (initRef.current.rafId === null) {\n      initRef.current.rafLastPos = null;\n      initRef.current.rafStableCount = 0;\n      initRef.current.rafId = requestAnimationFrame(checkScrollStability);\n    }\n  }, [checkScrollStability]);\n\n  // Main scroll handler\n  const handleScroll = React.useCallback(() => {\n    if (!initRef.current.hasInitialized) return;\n\n    const container = containerRef.current;\n    if (!container) return;\n\n    const { isVertical: isVert } =\n      DIRECTION_CONFIG[optionsRef.current.direction];\n    const scrollPos = isVert ? container.scrollTop : container.scrollLeft;\n\n    // Calculate progress (null if geometry not ready)\n    const progress =\n      geometry && contentSize\n        ? calculateScrollProgress(scrollPos, geometry, contentSize)\n        : null;\n\n    // Emit progress via callbacks (skip if not ready)\n    if (progress !== null) {\n      optionsRef.current.onScrollProgress?.(progress);\n    }\n\n    const snapProg = calculateSnapProgress(\n      scrollPos,\n      snapScrollPositions,\n      optionsRef.current.dismissible,\n    );\n    optionsRef.current.onSnapProgress?.(snapProg);\n\n    // Only mark as scrolling for user-initiated scrolls\n    // When pointer is down (user actively touching), use low threshold so slow drags register\n    // When pointer is up, use higher threshold to filter scroll-snap settling micro-adjustments\n    const scrollDelta =\n      interactionRef.current.prevScrollPos !== null\n        ? Math.abs(scrollPos - interactionRef.current.prevScrollPos)\n        : 0;\n    const threshold = interactionRef.current.isPointerDown ? 0.5 : 2;\n    const positionChanged = scrollDelta > threshold;\n\n    interactionRef.current.prevScrollPos = scrollPos;\n\n    if (!scrollControlRef.current.isProgrammatic && positionChanged) {\n      updateIsScrolling(true);\n      // Start RAF-based stability check only for browsers without native scrollend\n      if (!supportsScrollEnd) {\n        startScrollStabilityCheck();\n      }\n    }\n\n    // Trigger dismiss when drawer exits viewport\n    if (!scrollControlRef.current.isProgrammatic) {\n      if (\n        optionsRef.current.dismissible &&\n        !interactionRef.current.isClosing &&\n        progress !== null &&\n        progress >= 1\n      ) {\n        triggerImmediateDismiss();\n      }\n    }\n  }, [\n    geometry,\n    contentSize,\n    snapScrollPositions,\n    updateIsScrolling,\n    startScrollStabilityCheck,\n    triggerImmediateDismiss,\n  ]);\n\n  // Scroll end handler\n  const handleScrollEnd = React.useCallback(() => {\n    // Firefox: clicking/touching stops momentum scroll and fires scrollend immediately.\n    // If pointer is down, don't clear isScrolling yet - let touchend handler do it\n    // so that click events can see we were scrolling and block the close.\n    if (interactionRef.current.isPointerDown) {\n      interactionRef.current.scrollEndedWhilePointerDown = true;\n    } else {\n      updateIsScrolling(false);\n    }\n\n    // Detect snap point change\n    const container = containerRef.current;\n    if (container) {\n      const { isVertical: isVert } =\n        DIRECTION_CONFIG[optionsRef.current.direction];\n      const scrollPos = isVert ? container.scrollTop : container.scrollLeft;\n      detectAndNotifySnapChange(scrollPos);\n    }\n  }, [updateIsScrolling, detectAndNotifySnapChange]);\n\n  // Native scroll snap change handler (Chrome 129+)\n  const handleScrollSnapChange = React.useCallback((event: Event) => {\n    if (interactionRef.current.isClosing) return;\n\n    const snapEvent = event as Event & {\n      snapTargetBlock?: Element | null;\n      snapTargetInline?: Element | null;\n    };\n\n    const { isVertical: isVert } =\n      DIRECTION_CONFIG[optionsRef.current.direction];\n    const snapTarget = isVert\n      ? snapEvent.snapTargetBlock\n      : snapEvent.snapTargetInline;\n\n    if (!snapTarget) return;\n\n    const snapIndexAttr = snapTarget.getAttribute(\"data-snap-index\");\n    if (snapIndexAttr === null) return;\n\n    const rawIndex = parseInt(snapIndexAttr, 10);\n    if (isNaN(rawIndex)) return;\n\n    const actualIndex = optionsRef.current.dismissible\n      ? rawIndex - 1\n      : rawIndex;\n    if (actualIndex < 0) return;\n\n    if (actualIndex !== scrollControlRef.current.lastDetectedSnapIndex) {\n      scrollControlRef.current.lastDetectedSnapIndex = actualIndex;\n      scrollControlRef.current.isFromDetection = true;\n      optionsRef.current.onSnapPointChange(actualIndex);\n    }\n  }, []);\n\n  // Touch handlers to track if user is actively touching (touch only, not mouse)\n  // (Used by RAF stability check to distinguish \"holding still\" from \"released\")\n  // Note: We use touch events only (not mouse) because:\n  // 1. iOS Safari has quirky behavior with pointer events that causes flickering\n  // 2. Mouse clicks on desktop can cause tiny scroll jitter that falsely triggers isScrolling\n  const handleTouchStart = React.useCallback(() => {\n    interactionRef.current.isPointerDown = true;\n  }, []);\n\n  const handleTouchEnd = React.useCallback(() => {\n    interactionRef.current.isPointerDown = false;\n    // Reset stable count so we don't immediately fire handleScrollEnd\n    // from counts accumulated while user was holding still\n    // This gives momentum scroll time to start\n    initRef.current.rafStableCount = 0;\n\n    // Firefox: if scrollend fired while pointer was down (click stopped momentum),\n    // start stability check to clear isScrolling once scroll position stabilizes.\n    // This handles both cases:\n    // - If snap animation occurs: scroll events keep firing, natural scrollend clears isScrolling\n    // - If already at snap point: stability check detects no movement and clears isScrolling\n    if (interactionRef.current.scrollEndedWhilePointerDown) {\n      interactionRef.current.scrollEndedWhilePointerDown = false;\n      startScrollStabilityCheck();\n    }\n  }, [startScrollStabilityCheck]);\n\n  /* -------------------------------------------------------------------------------------------------\n   * Effects (reduced from 5 to 4)\n   * -------------------------------------------------------------------------------------------------*/\n\n  // Effect 1: Initialization\n  // Note: State/ref resets are unnecessary since DrawerContentInner unmounts on close,\n  // giving us fresh state on remount. We only need to cancel pending callbacks.\n  React.useEffect(() => {\n    if (!open) {\n      // Cancel pending callbacks during exit animation\n      if (initRef.current.rafId !== null) {\n        cancelAnimationFrame(initRef.current.rafId);\n        initRef.current.rafId = null;\n      }\n      if (initRef.current.retryTimeout) {\n        clearTimeout(initRef.current.retryTimeout);\n        initRef.current.retryTimeout = null;\n      }\n      return;\n    }\n\n    // Wait for contentSize to be measured before positioning\n    if (contentSize === null) return;\n\n    // Perform initial scroll positioning (only once per open)\n    if (!initRef.current.hasInitialized) {\n      const performInitialScroll = () => {\n        const container = containerRef.current;\n        if (!container) {\n          initRef.current.retryTimeout = setTimeout(performInitialScroll, 0);\n          return;\n        }\n\n        const size = isVertical\n          ? container.clientHeight\n          : container.clientWidth;\n        if (size === 0) {\n          initRef.current.retryTimeout = setTimeout(performInitialScroll, 0);\n          return;\n        }\n\n        initRef.current.hasInitialized = true;\n\n        if (size !== viewportSize) {\n          setViewportSize(size);\n        }\n\n        // Calculate target scroll position\n        const targetIndex = dismissible\n          ? activeSnapPointIndex + 1\n          : activeSnapPointIndex;\n        const targetScrollPos = snapScrollPositions[targetIndex] ?? 0;\n\n        // Mark as programmatic scroll\n        scrollControlRef.current.isProgrammatic = true;\n        scrollControlRef.current.lastDetectedSnapIndex = activeSnapPointIndex;\n\n        // Set initial scroll position\n        // scroll-snap is disabled via React state until setIsInitialized(true)\n        if (isVertical) {\n          container.scrollTop = targetScrollPos;\n        } else {\n          container.scrollLeft = targetScrollPos;\n        }\n\n        // Calculate and emit initial progress via callbacks\n        if (geometry && contentSize) {\n          const initialProgress = calculateScrollProgress(\n            targetScrollPos,\n            geometry,\n            contentSize,\n          );\n          onScrollProgress?.(initialProgress);\n        }\n\n        const initialSnapProgress = calculateSnapProgress(\n          targetScrollPos,\n          snapScrollPositions,\n          dismissible,\n        );\n        onSnapProgress?.(initialSnapProgress);\n\n        // Clear programmatic flag after a tick\n        setTimeout(() => {\n          scrollControlRef.current.isProgrammatic = false;\n        }, 0);\n\n        setIsInitialized(true);\n      };\n\n      // Use setTimeout to give browser time to compute snap target positions\n      initRef.current.retryTimeout = setTimeout(performInitialScroll, 0);\n    }\n\n    // Capture ref value for cleanup (avoids stale ref warning)\n    const currentInit = initRef.current;\n    return () => {\n      if (currentInit.retryTimeout) {\n        clearTimeout(currentInit.retryTimeout);\n        currentInit.retryTimeout = null;\n      }\n    };\n  }, [\n    open,\n    contentSize,\n    isVertical,\n    viewportSize,\n    dismissible,\n    activeSnapPointIndex,\n    snapScrollPositions,\n    geometry,\n    onScrollProgress,\n    onSnapProgress,\n  ]);\n\n  // Effect 2: Keep lastDetectedSnapIndex in sync with activeSnapPointIndex\n  // This prevents handleScrollSnapChange from setting isFromDetection=true after programmatic scrolls\n  React.useEffect(() => {\n    if (open) {\n      scrollControlRef.current.lastDetectedSnapIndex = activeSnapPointIndex;\n    }\n  }, [open, activeSnapPointIndex]);\n\n  // Effect 3: Handle controlled snap point changes (from external sources like buttons)\n  const prevSnapPointRef = React.useRef(activeSnapPointIndex);\n  React.useEffect(() => {\n    if (prevSnapPointRef.current !== activeSnapPointIndex && open) {\n      // Skip if this change came from detection (CSS scroll-snap already handled it)\n      if (scrollControlRef.current.isFromDetection) {\n        scrollControlRef.current.isFromDetection = false;\n        prevSnapPointRef.current = activeSnapPointIndex;\n        return;\n      }\n\n      // Only scroll if we're not already at the target position\n      const container = containerRef.current;\n      if (container) {\n        const currentScrollPos = isVertical\n          ? container.scrollTop\n          : container.scrollLeft;\n        const targetScrollPos =\n          getScrollPositionForSnapPoint(activeSnapPointIndex);\n        const tolerance = 10; // pixels\n\n        if (Math.abs(currentScrollPos - targetScrollPos) > tolerance) {\n          scrollToSnapPoint(activeSnapPointIndex, \"smooth\");\n        }\n      }\n    }\n    prevSnapPointRef.current = activeSnapPointIndex;\n  }, [\n    activeSnapPointIndex,\n    open,\n    scrollToSnapPoint,\n    isVertical,\n    getScrollPositionForSnapPoint,\n  ]);\n\n  // Effect 4: Re-position when geometry changes (e.g., keyboard appears on Android)\n  // This ensures the drawer stays at the correct snap point when viewport/content size changes\n  const prevTrackSizeRef = React.useRef(0);\n  React.useEffect(() => {\n    if (!open || !initRef.current.hasInitialized || !geometry) return;\n\n    const { trackSize } = geometry;\n\n    // Re-snap when track size changes (skip first run when prev is 0)\n    if (\n      prevTrackSizeRef.current !== 0 &&\n      prevTrackSizeRef.current !== trackSize\n    ) {\n      const container = containerRef.current;\n      if (container && !scrollControlRef.current.isProgrammatic) {\n        const targetScrollPos =\n          getScrollPositionForSnapPoint(activeSnapPointIndex);\n        const prevScrollBehavior = container.style.scrollBehavior;\n\n        // Use instant scroll to avoid visible animation\n        container.style.scrollBehavior = \"auto\";\n        if (isVertical) {\n          container.scrollTop = targetScrollPos;\n        } else {\n          container.scrollLeft = targetScrollPos;\n        }\n        container.style.scrollBehavior = prevScrollBehavior;\n      }\n    }\n\n    prevTrackSizeRef.current = trackSize;\n  }, [\n    open,\n    geometry,\n    isVertical,\n    activeSnapPointIndex,\n    getScrollPositionForSnapPoint,\n  ]);\n\n  // Effect 5: Event listeners (stable handlers, minimal dependencies)\n  React.useEffect(() => {\n    const container = containerRef.current;\n    if (!container || !open) return;\n\n    // Attach event listeners\n    container.addEventListener(\"scroll\", handleScroll, { passive: true });\n\n    // Touch tracking to distinguish \"holding still\" from \"released with momentum\"\n    // Note: We use touch events only (not mouse) to avoid false positives from\n    // mouse click jitter on desktop triggering scroll events\n    container.addEventListener(\"touchstart\", handleTouchStart, {\n      passive: true,\n    });\n    container.addEventListener(\"touchend\", handleTouchEnd, { passive: true });\n    container.addEventListener(\"touchcancel\", handleTouchEnd, {\n      passive: true,\n    });\n\n    if (supportsScrollEnd) {\n      container.addEventListener(\"scrollend\", handleScrollEnd);\n    }\n\n    if (supportsScrollSnapChange) {\n      container.addEventListener(\"scrollsnapchange\", handleScrollSnapChange);\n    }\n\n    // Viewport resize handling\n    const updateViewportSize = () => {\n      const size = isVertical ? container.clientHeight : container.clientWidth;\n      setViewportSize(size);\n    };\n    window.addEventListener(\"resize\", updateViewportSize);\n\n    return () => {\n      container.removeEventListener(\"scroll\", handleScroll);\n      container.removeEventListener(\"touchstart\", handleTouchStart);\n      container.removeEventListener(\"touchend\", handleTouchEnd);\n      container.removeEventListener(\"touchcancel\", handleTouchEnd);\n\n      if (supportsScrollEnd) {\n        container.removeEventListener(\"scrollend\", handleScrollEnd);\n      }\n\n      if (supportsScrollSnapChange) {\n        container.removeEventListener(\n          \"scrollsnapchange\",\n          handleScrollSnapChange,\n        );\n      }\n\n      window.removeEventListener(\"resize\", updateViewportSize);\n    };\n  }, [\n    open,\n    isVertical,\n    handleScroll,\n    handleScrollEnd,\n    handleScrollSnapChange,\n    handleTouchStart,\n    handleTouchEnd,\n  ]);\n\n  // Callback to set snap target refs (avoids exposing mutable ref to consumers)\n  const setSnapTargetRef = React.useCallback(\n    (index: number, el: HTMLDivElement | null) => {\n      snapTargetRefs.current[index] = el;\n    },\n    [],\n  );\n\n  return {\n    containerRef,\n    isScrolling,\n    setSnapTargetRef,\n    trackSize: geometry?.trackSize ?? 0,\n    isInitialized,\n    isClosing,\n  };\n}\n",
      "type": "registry:hook",
      "target": "components/ui/cubby-ui/drawer/hooks/use-scroll-snap.ts"
    },
    {
      "path": "registry/default/drawer/hooks/use-virtual-keyboard.ts",
      "content": "import * as React from \"react\";\r\n\r\nexport interface UseVirtualKeyboardOptions {\r\n  /** Whether keyboard handling is enabled */\r\n  enabled?: boolean;\r\n}\r\n\r\nexport interface UseVirtualKeyboardReturn {\r\n  /** Current keyboard height in pixels (0 when closed) */\r\n  keyboardHeight: number;\r\n  /** Whether the virtual keyboard is currently visible */\r\n  isKeyboardVisible: boolean;\r\n}\r\n\r\n/**\r\n * Helper to check if element is an input that would trigger a virtual keyboard.\r\n */\r\nfunction isInput(element: HTMLElement | null): boolean {\r\n  if (!element) return false;\r\n  const tagName = element.tagName.toLowerCase();\r\n  return (\r\n    tagName === \"input\" ||\r\n    tagName === \"textarea\" ||\r\n    tagName === \"select\" ||\r\n    element.isContentEditable\r\n  );\r\n}\r\n\r\n/**\r\n * Detect Firefox mobile which natively handles keyboard repositioning.\r\n * We skip our custom transform on Firefox to avoid double-repositioning.\r\n */\r\nconst isFirefoxMobile =\r\n  typeof navigator !== \"undefined\" &&\r\n  /Firefox/i.test(navigator.userAgent) &&\r\n  /Android|Mobile/i.test(navigator.userAgent);\r\n\r\n/**\r\n * Hook to detect virtual keyboard visibility and height using the Visual Viewport API.\r\n *\r\n * On mobile devices, when a virtual keyboard appears, it reduces the visual viewport height.\r\n * This hook tracks that change so components can adjust their layout accordingly.\r\n *\r\n * Simplified approach:\r\n * - Keyboard is visible if viewport is significantly smaller (>100px) AND an input is focused\r\n * - No complex toggle state that can get out of sync\r\n */\r\nexport function useVirtualKeyboard({\r\n  enabled = true,\r\n}: UseVirtualKeyboardOptions = {}): UseVirtualKeyboardReturn {\r\n  const [keyboardHeight, setKeyboardHeight] = React.useState(0);\r\n\r\n  React.useEffect(() => {\r\n    // Firefox mobile natively handles keyboard repositioning, so we skip\r\n    // our custom detection to avoid double-repositioning the drawer\r\n    if (!enabled || typeof window === \"undefined\" || isFirefoxMobile) return;\r\n\r\n    // Enable Virtual Keyboard API to get env(keyboard-inset-*) CSS variables\r\n    // This tells the browser that we'll handle the virtual keyboard geometry ourselves\r\n    if (\"virtualKeyboard\" in navigator) {\r\n      (navigator as Navigator & { virtualKeyboard: { overlaysContent: boolean } })\r\n        .virtualKeyboard.overlaysContent = true;\r\n    }\r\n\r\n    const visualViewport = window.visualViewport;\r\n    if (!visualViewport) return;\r\n\r\n    const handleResize = () => {\r\n      const focusedElement = document.activeElement as HTMLElement;\r\n      const isInputFocused = isInput(focusedElement);\r\n\r\n      // If no input is focused, keyboard can't be open for our purposes\r\n      if (!isInputFocused) {\r\n        setKeyboardHeight(0);\r\n        return;\r\n      }\r\n\r\n      const visualViewportHeight = visualViewport.height;\r\n      const totalHeight = window.innerHeight;\r\n      const diff = totalHeight - visualViewportHeight;\r\n\r\n      // Keyboard is visible if viewport is significantly smaller (>100px threshold)\r\n      // This avoids false positives from address bar changes\r\n      if (diff > 100) {\r\n        setKeyboardHeight(diff);\r\n      } else {\r\n        setKeyboardHeight(0);\r\n      }\r\n    };\r\n\r\n    visualViewport.addEventListener(\"resize\", handleResize);\r\n\r\n    // Initial check in case keyboard is already open\r\n    handleResize();\r\n\r\n    return () => visualViewport.removeEventListener(\"resize\", handleResize);\r\n  }, [enabled]);\r\n\r\n  return {\r\n    keyboardHeight,\r\n    isKeyboardVisible: keyboardHeight > 0,\r\n  };\r\n}\r\n",
      "type": "registry:hook",
      "target": "components/ui/cubby-ui/drawer/hooks/use-virtual-keyboard.ts"
    },
    {
      "path": "registry/default/drawer/hooks/use-visual-viewport-height.ts",
      "content": "import * as React from \"react\";\r\n\r\nexport interface UseVisualViewportHeightOptions {\r\n  /** Whether tracking is enabled */\r\n  enabled?: boolean;\r\n}\r\n\r\n/**\r\n * Hook to track the visual viewport height using the Visual Viewport API.\r\n *\r\n * On mobile devices, the visual viewport height changes when the URL bar\r\n * collapses/expands. This hook provides real-time tracking of the actual\r\n * visible viewport height, which can be used to size elements that need\r\n * to fill the visible area regardless of URL bar state.\r\n *\r\n * @returns The current visual viewport height in pixels, or null if not available\r\n */\r\nexport function useVisualViewportHeight({\r\n  enabled = true,\r\n}: UseVisualViewportHeightOptions = {}): number | null {\r\n  const [height, setHeight] = React.useState<number | null>(() => {\r\n    if (typeof window === \"undefined\") return null;\r\n    return window.visualViewport?.height ?? null;\r\n  });\r\n\r\n  React.useEffect(() => {\r\n    if (!enabled || typeof window === \"undefined\") return;\r\n\r\n    const visualViewport = window.visualViewport;\r\n    if (!visualViewport) return;\r\n\r\n    const handleResize = () => {\r\n      setHeight(visualViewport.height);\r\n    };\r\n\r\n    // Set initial value\r\n    handleResize();\r\n\r\n    visualViewport.addEventListener(\"resize\", handleResize);\r\n    return () => visualViewport.removeEventListener(\"resize\", handleResize);\r\n  }, [enabled]);\r\n\r\n  return height;\r\n}\r\n",
      "type": "registry:hook",
      "target": "components/ui/cubby-ui/drawer/hooks/use-visual-viewport-height.ts"
    },
    {
      "path": "registry/default/drawer/drawer.css",
      "content": "/* -------------------------------------------------------------------------------------------------\r\n * Drawer Scroll-Driven Animations (Progressive Enhancement)\r\n * Chrome 115+, Safari 26+ (future), Firefox flag-only\r\n * -------------------------------------------------------------------------------------------------*/\r\n\r\n/**\r\n * CSS Custom Property for scroll-driven drawer animations\r\n * Allows consumers to animate content based on snap progress:\r\n * .mini-player { opacity: calc(1 - var(--drawer-snap-progress, 0)); }\r\n * .full-player { opacity: var(--drawer-snap-progress, 0); }\r\n */\r\n@property --drawer-snap-progress {\r\n  syntax: \"<number>\";\r\n  inherits: true;\r\n  initial-value: 0;\r\n}\r\n\r\n/**\r\n * Animates --drawer-snap-progress from 0 to 1 based on scroll position\r\n * Applied to drawer viewport with animation-timeline: scroll()\r\n */\r\n@keyframes drawer-snap-progress {\r\n  from {\r\n    --drawer-snap-progress: 0;\r\n  }\r\n  to {\r\n    --drawer-snap-progress: 1;\r\n  }\r\n}\r\n\r\n/**\r\n * Animates backdrop opacity based on drawer panel visibility (view timeline)\r\n * Uses view() timeline - opacity naturally scales with how much drawer is visible\r\n * Applied to drawer backdrop with animation-timeline: --drawer-panel\r\n */\r\n@keyframes drawer-backdrop-fade {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n/**\r\n * Exit animation for drawer backdrop\r\n * Animates from current opacity to 0 (no 'from' = starts from computed value)\r\n * Used to override scroll-driven animations which transitions can't interpolate from\r\n */\r\n@keyframes drawer-backdrop-exit {\r\n  to {\r\n    opacity: 0;\r\n  }\r\n}\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * CSS-Based Snap Target Positioning\r\n * Snap targets use CSS custom properties for positioning instead of JavaScript calculations\r\n *\r\n * Required CSS variables (set on track element):\r\n * --content-size: drawer content size in pixels\r\n * --dismiss-buffer: dismiss buffer in pixels (30% of content when dismissible, 0 otherwise)\r\n *\r\n * Required CSS variables (set on each snap target):\r\n * --snap-ratio: 0-1 value representing how much of drawer is visible\r\n * -------------------------------------------------------------------------------------------------*/\r\n\r\n/**\r\n * Non-inverted directions (bottom/right):\r\n * - Scroll from 0 (closed) to max (fully open)\r\n * - Dismiss at position 0\r\n * - Snap position = dismissBuffer + ratio * contentSize\r\n *\r\n * Inverted directions (top/left):\r\n * - Scroll from max (closed) to 0 (fully open)\r\n * - Dismiss at position maxScroll\r\n * - Snap position = contentSize * (1 - ratio)\r\n */\r\n\r\n/* Bottom drawer (non-inverted): position from top */\r\n[data-direction=\"bottom\"] [data-slot=\"drawer-snap-target\"]:not([data-snap-type=\"dismiss\"]) {\r\n  top: calc(var(--dismiss-buffer, 0px) + var(--snap-ratio, 1) * var(--content-size, 0px));\r\n}\r\n\r\n/* Top drawer (inverted): position from top, inverted formula */\r\n[data-direction=\"top\"] [data-slot=\"drawer-snap-target\"]:not([data-snap-type=\"dismiss\"]) {\r\n  top: calc(var(--content-size, 0px) * (1 - var(--snap-ratio, 1)));\r\n}\r\n\r\n/* Right drawer (non-inverted): position from left */\r\n[data-direction=\"right\"] [data-slot=\"drawer-snap-target\"]:not([data-snap-type=\"dismiss\"]) {\r\n  left: calc(var(--dismiss-buffer, 0px) + var(--snap-ratio, 1) * var(--content-size, 0px));\r\n}\r\n\r\n/* Left drawer (inverted): position from left, inverted formula */\r\n[data-direction=\"left\"] [data-slot=\"drawer-snap-target\"]:not([data-snap-type=\"dismiss\"]) {\r\n  left: calc(var(--content-size, 0px) * (1 - var(--snap-ratio, 1)));\r\n}\r\n\r\n/* Dismiss snap targets - positioned at scroll boundary */\r\n/* Non-inverted: position 0, Inverted: position = maxScroll = contentSize + dismissBuffer */\r\n[data-direction=\"bottom\"] [data-slot=\"drawer-snap-target\"][data-snap-type=\"dismiss\"] {\r\n  top: 0;\r\n}\r\n\r\n[data-direction=\"right\"] [data-slot=\"drawer-snap-target\"][data-snap-type=\"dismiss\"] {\r\n  left: 0;\r\n}\r\n\r\n[data-direction=\"top\"] [data-slot=\"drawer-snap-target\"][data-snap-type=\"dismiss\"] {\r\n  top: calc(var(--content-size, 0px) + var(--dismiss-buffer, 0px));\r\n}\r\n\r\n[data-direction=\"left\"] [data-slot=\"drawer-snap-target\"][data-snap-type=\"dismiss\"] {\r\n  left: calc(var(--content-size, 0px) + var(--dismiss-buffer, 0px));\r\n}\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * Direction-Specific Overrides\r\n * -------------------------------------------------------------------------------------------------*/\r\n\r\nhtml:has([data-slot=\"drawer-viewport\"][data-direction=\"left\"]),\r\nhtml:has([data-slot=\"drawer-viewport\"][data-direction=\"right\"]) {\r\n  overscroll-behavior: none;\r\n  scrollbar-width: none;\r\n}\r\n\r\nhtml:has(\r\n    [data-slot=\"drawer-viewport\"][data-direction=\"left\"]\r\n  )::-webkit-scrollbar,\r\nhtml:has(\r\n    [data-slot=\"drawer-viewport\"][data-direction=\"right\"]\r\n  )::-webkit-scrollbar {\r\n  display: none !important;\r\n}\r\n",
      "type": "registry:file",
      "target": "components/ui/cubby-ui/drawer/drawer.css"
    }
  ]
}