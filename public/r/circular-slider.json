{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "circular-slider",
  "type": "registry:ui",
  "title": "Circular Slider",
  "description": "A circular-slider component.",
  "dependencies": [
    "class-variance-authority"
  ],
  "files": [
    {
      "path": "registry/default/circular-slider/circular-slider.tsx",
      "content": "\"use client\";\n\nimport * as React from \"react\";\nimport { cva, type VariantProps } from \"class-variance-authority\";\nimport { mergeProps } from \"@base-ui-components/react/merge-props\";\nimport { useRender } from \"@base-ui-components/react/use-render\";\nimport { cn } from \"@/lib/utils\";\nimport {\n  valueToAngle,\n  angleToValue,\n  getThumbPosition,\n  describeArc,\n  roundToStep,\n  clamp,\n} from \"./lib/angle-calculations\";\nimport {\n  SVG_CONFIG,\n  RADIUS_CONFIG,\n  SLOT_NAMES,\n  VARIANT_COLOR_MAP,\n} from \"./lib/svg-constants\";\nimport {\n  pixelsToSvgUnits,\n  createSvgOverlayProps,\n  strokeWidthToSvgUnits,\n  getTrackInnerEdge,\n} from \"./lib/svg-utils\";\nimport { getValueFromPointerPosition } from \"./lib/pointer-utils\";\n\n// ============================================================================\n// Types\n// ============================================================================\n\nexport type ChangeReason = \"drag\" | \"keyboard\" | \"click\";\n\ninterface CircularSliderContextValue {\n  value: number;\n  min: number;\n  max: number;\n  step: number;\n  startAngle: number;\n  direction: \"clockwise\" | \"counterclockwise\";\n  continuous: boolean;\n  disabled: boolean;\n  size: number;\n  variant: \"default\" | \"filled\";\n  isDragging: boolean;\n  isFocused: boolean;\n  handleValueChange: (newValue: number, reason: ChangeReason) => void;\n  handleValueCommitted: (value: number) => void;\n}\n\nconst CircularSliderContext = React.createContext<\n  CircularSliderContextValue | undefined\n>(undefined);\n\nfunction useCircularSliderContext() {\n  const context = React.useContext(CircularSliderContext);\n  if (!context) {\n    throw new Error(\n      \"CircularSlider components must be used within CircularSliderRoot\",\n    );\n  }\n  return context;\n}\n\n// ============================================================================\n// Variants\n// ============================================================================\n\nconst circularSliderVariants = cva(\n  \"group relative inline-block touch-none select-none outline-none\",\n  {\n    variants: {\n      variant: {\n        default: \"\",\n        filled: \"\",\n      },\n      disabled: {\n        true: \"opacity-50 cursor-not-allowed pointer-events-none\",\n        false: \"\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      disabled: false,\n    },\n  },\n);\n\nconst thumbVariants = cva(\n  \"absolute outline-0 outline-offset-0 outline-transparent transition-[outline-width,outline-offset,outline-color] duration-100 ease-out outline-solid\",\n  {\n    variants: {\n      variant: {\n        default:\n          \"rounded-full border-3 border-primary dark:bg-black bg-white group-data-focused:outline-ring group-data-focused:outline-2 group-data-focused:outline-offset-2\",\n        filled: \"rounded-none bg-foreground\",\n      },\n      dragging: {\n        true: \"cursor-grabbing\",\n        false: \"cursor-grab\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      dragging: false,\n    },\n  },\n);\n\n// ============================================================================\n// Helper Functions\n// ============================================================================\n\n/**\n * Wrap value for continuous mode with direction tracking (max inclusive)\n * Detects boundary crossings to determine if position should show min or max\n */\nfunction wrapValueWithDirection(\n  value: number,\n  min: number,\n  max: number,\n  previousValue: number | null,\n): number {\n  const range = max - min;\n\n  // If we have a previous value, detect boundary crossing\n  if (previousValue !== null) {\n    // Check if we crossed the boundary (value jumped more than half the range)\n    const diff = value - previousValue;\n    const absDiff = Math.abs(diff);\n\n    if (absDiff > range / 2) {\n      // Boundary crossing detected\n      // If previous was near max and new is near min → crossing clockwise → allow max\n      if (previousValue > min + range * 0.75 && value < min + range * 0.25) {\n        // User is incrementing past max, wrap to min\n        return min;\n      }\n      // If previous was near min and new is near max → crossing counterclockwise → wrap to max\n      if (previousValue < min + range * 0.25 && value > min + range * 0.75) {\n        // User is decrementing past min, wrap to max\n        return max;\n      }\n    }\n  }\n\n  // Standard wrapping when not crossing boundary\n  if (value > max) {\n    return min + (value - max);\n  }\n  if (value < min) {\n    return max - (min - value);\n  }\n\n  return value;\n}\n\n// ============================================================================\n// Root Component\n// ============================================================================\n\nexport interface CircularSliderRootProps\n  extends\n    Omit<\n      useRender.ComponentProps<\"div\">,\n      \"onChange\" | \"defaultValue\" | \"aria-valuetext\"\n    >,\n    VariantProps<typeof circularSliderVariants> {\n  value?: number;\n  defaultValue?: number;\n  onValueChange?: (value: number, reason: ChangeReason) => void;\n  onValueCommitted?: (value: number) => void;\n  min?: number;\n  max?: number;\n  step?: number;\n  largeStep?: number;\n  startAngle?: number;\n  endAngle?: number;\n  direction?: \"clockwise\" | \"counterclockwise\";\n  continuous?: boolean;\n  disabled?: boolean;\n  size?: number;\n  // Form integration props\n  name?: string;\n  id?: string;\n  required?: boolean;\n  form?: string;\n  // Accessibility props\n  \"aria-label\"?: string;\n  \"aria-labelledby\"?: string;\n  \"aria-describedby\"?: string;\n  \"aria-valuetext\"?: string | ((value: number) => string);\n}\n\nexport function CircularSliderRoot({\n  className,\n  render,\n  value: valueProp,\n  defaultValue = 0,\n  onValueChange,\n  onValueCommitted,\n  min = 0,\n  max = 100,\n  step = 1,\n  largeStep = 10,\n  startAngle = 0,\n  endAngle,\n  direction = \"clockwise\",\n  continuous = true,\n  disabled = false,\n  size = 96,\n  variant = \"default\",\n  // Form integration props\n  name,\n  id,\n  required,\n  form: formProp,\n  // Accessibility props\n  \"aria-label\": ariaLabel,\n  \"aria-labelledby\": ariaLabelledby,\n  \"aria-describedby\": ariaDescribedby,\n  \"aria-valuetext\": ariaValuetext,\n  ...props\n}: CircularSliderRootProps) {\n  const isControlled = valueProp !== undefined;\n  const [internalValue, setInternalValue] = React.useState(defaultValue);\n  const value = isControlled ? valueProp : internalValue;\n\n  const [isDragging, setIsDragging] = React.useState(false);\n  const [isFocused, setIsFocused] = React.useState(false);\n  const containerRef = React.useRef<HTMLDivElement>(null);\n  const inputRef = React.useRef<HTMLInputElement>(null);\n  const previousValue = React.useRef<number | null>(null);\n\n  const handleValueChange = React.useCallback(\n    (newValue: number, reason: ChangeReason) => {\n      if (disabled) return;\n\n      // Apply step rounding\n      let processedValue = roundToStep(newValue, step, min);\n\n      // Handle wrapping and clamping\n      if (continuous) {\n        // Wrapping for continuous mode with direction tracking (max is inclusive)\n        processedValue = wrapValueWithDirection(\n          processedValue,\n          min,\n          max,\n          previousValue.current,\n        );\n      } else {\n        // Clamp to min/max in non-continuous mode\n        processedValue = clamp(processedValue, min, max);\n      }\n\n      // Update previous value for direction tracking\n      previousValue.current = processedValue;\n\n      if (!isControlled) {\n        setInternalValue(processedValue);\n      }\n\n      onValueChange?.(processedValue, reason);\n    },\n    [disabled, step, min, max, continuous, isControlled, onValueChange],\n  );\n\n  const handleValueCommitted = React.useCallback(\n    (committedValue: number) => {\n      if (disabled) return;\n      onValueCommitted?.(committedValue);\n    },\n    [disabled, onValueCommitted],\n  );\n\n  // Handle pointer events\n  const handlePointerDown = React.useCallback(\n    (e: React.PointerEvent) => {\n      if (disabled) return;\n\n      const container = containerRef.current;\n      if (!container) return;\n\n      const newValue = getValueFromPointerPosition(\n        e,\n        container,\n        min,\n        max,\n        startAngle,\n        direction,\n        continuous,\n      );\n\n      // Initialize previous value for direction tracking\n      previousValue.current = value;\n\n      setIsDragging(true);\n      (e.target as HTMLElement).setPointerCapture(e.pointerId);\n\n      // Update value immediately\n      handleValueChange(newValue, \"drag\");\n    },\n    [\n      disabled,\n      value,\n      min,\n      max,\n      startAngle,\n      direction,\n      continuous,\n      handleValueChange,\n    ],\n  );\n\n  const handlePointerMove = React.useCallback(\n    (e: React.PointerEvent) => {\n      if (!isDragging || disabled) return;\n\n      const container = containerRef.current;\n      if (!container) return;\n\n      const newValue = getValueFromPointerPosition(\n        e,\n        container,\n        min,\n        max,\n        startAngle,\n        direction,\n        continuous,\n      );\n\n      handleValueChange(newValue, \"drag\");\n    },\n    [\n      isDragging,\n      disabled,\n      min,\n      max,\n      startAngle,\n      direction,\n      continuous,\n      handleValueChange,\n    ],\n  );\n\n  const handlePointerUp = React.useCallback(\n    (e: React.PointerEvent) => {\n      if (!isDragging) return;\n\n      setIsDragging(false);\n      (e.target as HTMLElement).releasePointerCapture(e.pointerId);\n      handleValueCommitted(value);\n    },\n    [isDragging, value, handleValueCommitted],\n  );\n\n  // Handle input change from native range input\n  const handleInputChange = React.useCallback(\n    (e: React.ChangeEvent<HTMLInputElement>) => {\n      previousValue.current = value;\n      handleValueChange(parseFloat(e.target.value), \"keyboard\");\n    },\n    [value, handleValueChange],\n  );\n\n  // Handle keyboard navigation for largeStep (PageUp/PageDown)\n  // Native input handles arrows, Home, End automatically\n  const handleInputKeyDown = React.useCallback(\n    (e: React.KeyboardEvent<HTMLInputElement>) => {\n      if (disabled) return;\n\n      previousValue.current = value;\n\n      if (e.key === \"PageUp\") {\n        e.preventDefault();\n        handleValueChange(value + largeStep, \"keyboard\");\n      } else if (e.key === \"PageDown\") {\n        e.preventDefault();\n        handleValueChange(value - largeStep, \"keyboard\");\n      }\n    },\n    [disabled, value, largeStep, handleValueChange],\n  );\n\n  const contextValue: CircularSliderContextValue = React.useMemo(\n    () => ({\n      value,\n      min,\n      max,\n      step,\n      startAngle,\n      direction,\n      continuous,\n      disabled,\n      size,\n      variant: variant ?? \"default\",\n      isDragging,\n      isFocused,\n      handleValueChange,\n      handleValueCommitted,\n    }),\n    [\n      value,\n      min,\n      max,\n      step,\n      startAngle,\n      direction,\n      continuous,\n      disabled,\n      size,\n      variant,\n      isDragging,\n      isFocused,\n      handleValueChange,\n      handleValueCommitted,\n    ],\n  );\n\n  const defaultProps = {\n    ref: containerRef,\n    \"data-slot\": SLOT_NAMES.ROOT,\n    \"data-size\": size,\n    \"data-variant\": variant,\n    \"data-dragging\": isDragging || undefined,\n    \"data-disabled\": disabled || undefined,\n    \"data-continuous\": continuous || undefined,\n    \"data-focused\": isFocused || undefined,\n    className: cn(circularSliderVariants({ disabled }), className),\n    style: {\n      width: `${size}px`,\n      height: `${size}px`,\n    },\n    onPointerDown: handlePointerDown,\n    onPointerMove: handlePointerMove,\n    onPointerUp: handlePointerUp,\n  };\n\n  const element = useRender({\n    defaultTagName: \"div\",\n    render: render,\n    props: mergeProps<\"div\">(defaultProps, props),\n  });\n\n  const resolvedAriaValuetext =\n    typeof ariaValuetext === \"function\" ? ariaValuetext(value) : ariaValuetext;\n\n  return (\n    <CircularSliderContext.Provider value={contextValue}>\n      {/* Hidden native input for accessibility and form integration */}\n      <input\n        ref={inputRef}\n        type=\"range\"\n        min={min}\n        max={max}\n        step={step}\n        value={value}\n        onChange={handleInputChange}\n        onKeyDown={handleInputKeyDown}\n        onFocus={() => setIsFocused(true)}\n        onBlur={() => {\n          setIsFocused(false);\n          handleValueCommitted(value);\n        }}\n        disabled={disabled}\n        name={name}\n        id={id}\n        required={required}\n        form={formProp}\n        aria-label={ariaLabel}\n        aria-labelledby={ariaLabelledby}\n        aria-describedby={ariaDescribedby}\n        aria-valuetext={resolvedAriaValuetext}\n        className=\"sr-only\"\n      />\n      {element}\n    </CircularSliderContext.Provider>\n  );\n}\n\n// ============================================================================\n// Track Component\n// ============================================================================\n\nexport interface CircularSliderTrackProps extends useRender.ComponentProps<\"svg\"> {\n  strokeWidth?: number;\n}\n\nexport function CircularSliderTrack({\n  className,\n  render,\n  strokeWidth,\n  ...props\n}: CircularSliderTrackProps) {\n  const { continuous, size, variant } = useCircularSliderContext();\n\n  const svgStrokeWidth = strokeWidthToSvgUnits(strokeWidth, size);\n\n  // For non-continuous mode, render 270° arc from 225° to 135° (gap at bottom)\n  const trackArcPath = continuous\n    ? null\n    : describeArc(\n        SVG_CONFIG.CENTER_X,\n        SVG_CONFIG.CENTER_Y,\n        RADIUS_CONFIG.TRACK,\n        225,\n        135,\n      );\n\n  const trackElement = (\n    <>\n      {/* Filled background circle for filled variant */}\n      {variant === \"filled\" && (\n        <circle\n          cx={SVG_CONFIG.CENTER_X}\n          cy={SVG_CONFIG.CENTER_Y}\n          r={RADIUS_CONFIG.FILLED_BACKGROUND}\n          className=\"fill-muted group-data-focused:stroke-ring/50 stroke-transparent outline-0 outline-offset-0 outline-transparent transition-[outline-width,outline-offset,outline-color,stroke,fill] duration-100 ease-out outline-solid group-data-focused:stroke-4\"\n          strokeWidth=\"2\"\n        />\n      )}\n\n      {continuous ? (\n        // Full circle for continuous mode\n        <circle\n          cx={SVG_CONFIG.CENTER_X}\n          cy={SVG_CONFIG.CENTER_Y}\n          r={RADIUS_CONFIG.TRACK}\n          fill=\"none\"\n          strokeWidth={svgStrokeWidth}\n          className={cn(\n            VARIANT_COLOR_MAP.track[\n              variant as keyof typeof VARIANT_COLOR_MAP.track\n            ],\n            \"transition-colors\",\n          )}\n        />\n      ) : (\n        // 270° arc for non-continuous mode (gap centered at bottom)\n        <path\n          d={trackArcPath || \"\"}\n          fill=\"none\"\n          strokeWidth={svgStrokeWidth}\n          strokeLinecap=\"round\"\n          className={cn(\n            VARIANT_COLOR_MAP.track[\n              variant as keyof typeof VARIANT_COLOR_MAP.track\n            ],\n            \"transition-colors\",\n          )}\n        />\n      )}\n    </>\n  );\n\n  const defaultProps = createSvgOverlayProps(SLOT_NAMES.TRACK, className);\n\n  const element = useRender({\n    defaultTagName: \"svg\",\n    render: render,\n    props: mergeProps<\"svg\">(defaultProps, {\n      ...props,\n      children: trackElement,\n    }),\n  });\n\n  return element;\n}\n\n// ============================================================================\n// Indicator Component\n// ============================================================================\n\nexport interface CircularSliderIndicatorProps extends useRender.ComponentProps<\"svg\"> {\n  strokeWidth?: number;\n}\n\nexport function CircularSliderIndicator({\n  className,\n  render,\n  strokeWidth,\n  ...props\n}: CircularSliderIndicatorProps) {\n  const { value, min, max, startAngle, direction, continuous, size, variant } =\n    useCircularSliderContext();\n\n  const svgStrokeWidth = strokeWidthToSvgUnits(strokeWidth, size);\n\n  // In continuous mode, when value equals max, show full circle instead of arc\n  const isFullCircle = continuous && value === max;\n\n  let indicatorElement: React.ReactNode = null;\n\n  if (isFullCircle) {\n    // Draw full circle when at max in continuous mode\n    indicatorElement = (\n      <circle\n        cx={SVG_CONFIG.CENTER_X}\n        cy={SVG_CONFIG.CENTER_Y}\n        r={RADIUS_CONFIG.TRACK}\n        fill=\"none\"\n        strokeWidth={svgStrokeWidth}\n        strokeLinecap=\"round\"\n        className={cn(\n          VARIANT_COLOR_MAP.indicator[\n            variant as keyof typeof VARIANT_COLOR_MAP.indicator\n          ],\n          \"transition-colors\",\n        )}\n      />\n    );\n  } else {\n    // Draw arc for normal cases\n    const arcStartAngle = valueToAngle(\n      min,\n      min,\n      max,\n      startAngle,\n      direction,\n      continuous,\n    );\n    const arcEndAngle = valueToAngle(\n      value,\n      min,\n      max,\n      startAngle,\n      direction,\n      continuous,\n    );\n    const arcPath = describeArc(\n      SVG_CONFIG.CENTER_X,\n      SVG_CONFIG.CENTER_Y,\n      RADIUS_CONFIG.TRACK,\n      arcStartAngle,\n      arcEndAngle,\n      direction,\n    );\n\n    indicatorElement = arcPath ? (\n      <path\n        d={arcPath}\n        fill=\"none\"\n        strokeWidth={svgStrokeWidth}\n        strokeLinecap=\"round\"\n        className={cn(\n          VARIANT_COLOR_MAP.indicator[\n            variant as keyof typeof VARIANT_COLOR_MAP.indicator\n          ],\n          \"transition-colors\",\n        )}\n      />\n    ) : null;\n  }\n\n  const defaultProps = createSvgOverlayProps(\n    SLOT_NAMES.INDICATOR,\n    className,\n    false,\n  );\n\n  const element = useRender({\n    defaultTagName: \"svg\",\n    render: render,\n    props: mergeProps<\"svg\">(defaultProps, {\n      ...props,\n      children: indicatorElement,\n    }),\n  });\n\n  return element;\n}\n\n// ============================================================================\n// Thumb Component\n// ============================================================================\n\nexport interface CircularSliderThumbProps extends useRender.ComponentProps<\"div\"> {\n  size?: number;\n}\n\nexport function CircularSliderThumb({\n  className,\n  render,\n  size: thumbSize = 16,\n  ...props\n}: CircularSliderThumbProps) {\n  const {\n    value,\n    min,\n    max,\n    startAngle,\n    direction,\n    continuous,\n    isDragging,\n    size: containerSize,\n    variant,\n  } = useCircularSliderContext();\n\n  const angle = valueToAngle(\n    value,\n    min,\n    max,\n    startAngle,\n    direction,\n    continuous,\n  );\n\n  // Calculate position on circle\n  // Default variant: position at track edge\n  // Filled variant: position so outer tip is at background circle edge\n  let radius = RADIUS_CONFIG.TRACK;\n  if (variant === \"filled\") {\n    // Convert thumbSize pixels to SVG units\n    const thumbSizeInSvgUnits = pixelsToSvgUnits(thumbSize, containerSize);\n    // Position center so outer tip is at background circle edge\n    radius = RADIUS_CONFIG.FILLED_BACKGROUND - thumbSizeInSvgUnits / 2;\n  }\n\n  const thumbPos = getThumbPosition(\n    angle,\n    radius,\n    SVG_CONFIG.CENTER_X,\n    SVG_CONFIG.CENTER_Y,\n  );\n  const leftPercent = (thumbPos.x / SVG_CONFIG.VIEWBOX_SIZE) * 100;\n  const topPercent = (thumbPos.y / SVG_CONFIG.VIEWBOX_SIZE) * 100;\n\n  // For filled variant, the thumb is a line that points toward the center\n  // We rotate it by the angle to make it radial (pointing inward)\n  const transform =\n    variant === \"filled\"\n      ? `translate(-50%, -50%) rotate(${angle}deg)`\n      : \"translate(-50%, -50%)\";\n\n  // Dynamic sizing styles\n  const thumbStyles: React.CSSProperties = {\n    left: `${leftPercent}%`,\n    top: `${topPercent}%`,\n    transform,\n    ...(variant === \"default\"\n      ? {\n          width: `${thumbSize}px`,\n          height: `${thumbSize}px`,\n        }\n      : {\n          width: \"2px\",\n          height: `${thumbSize}px`,\n        }),\n  };\n\n  const defaultProps = {\n    \"data-slot\": SLOT_NAMES.THUMB,\n    className: cn(thumbVariants({ variant, dragging: isDragging }), className),\n    style: thumbStyles,\n    role: \"presentation\",\n    \"aria-hidden\": true,\n  };\n\n  const element = useRender({\n    defaultTagName: \"div\",\n    render: render,\n    props: mergeProps<\"div\">(defaultProps, props),\n  });\n\n  return element;\n}\n\n// ============================================================================\n// Value Component\n// ============================================================================\n\nexport interface CircularSliderValueProps extends useRender.ComponentProps<\"div\"> {\n  formatValue?: (value: number) => string;\n}\n\nexport function CircularSliderValue({\n  className,\n  render,\n  formatValue: formatValueProp,\n  ...props\n}: CircularSliderValueProps) {\n  const { value } = useCircularSliderContext();\n\n  const displayValue = formatValueProp\n    ? formatValueProp(value)\n    : Math.round(value).toString();\n\n  const defaultProps = {\n    \"data-slot\": SLOT_NAMES.VALUE,\n    className: cn(\n      \"absolute inset-0 flex items-center justify-center font-medium tabular-nums text-sm\",\n      className,\n    ),\n  };\n\n  const element = useRender({\n    defaultTagName: \"div\",\n    render: render,\n    props: mergeProps<\"div\">(defaultProps, {\n      ...props,\n      children: displayValue,\n    }),\n  });\n\n  return element;\n}\n\n// ============================================================================\n// Markers Component\n// ============================================================================\n\nexport interface CircularSliderMarkersProps extends useRender.ComponentProps<\"svg\"> {\n  count?: number;\n  showLabels?: boolean;\n  length?: number;\n}\n\nexport function CircularSliderMarkers({\n  className,\n  render,\n  count = 12,\n  showLabels = false,\n  length,\n  ...props\n}: CircularSliderMarkersProps) {\n  const { min, max, startAngle, direction, continuous, size, variant } =\n    useCircularSliderContext();\n\n  // Convert marker length from pixels to SVG units\n  // Default length: 10px for filled variant, 5px for default variant\n  const defaultLength = variant === \"filled\" ? 10 : 5;\n  const markerLengthInPixels = length ?? defaultLength;\n  const markerLengthInSvgUnits = pixelsToSvgUnits(markerLengthInPixels, size);\n\n  const markers = Array.from({ length: count }, (_, i) => {\n    const value = min + (i / count) * (max - min);\n    const angle = valueToAngle(\n      value,\n      min,\n      max,\n      startAngle,\n      direction,\n      continuous,\n    );\n\n    let outerRadius: number;\n    let innerRadius: number;\n\n    if (variant === \"filled\") {\n      // For filled variant, position outer end at background circle edge\n      outerRadius = RADIUS_CONFIG.FILLED_BACKGROUND;\n      innerRadius = RADIUS_CONFIG.FILLED_BACKGROUND - markerLengthInSvgUnits;\n    } else {\n      // For default variant, position outer end at track inner edge\n      const trackInnerEdge = getTrackInnerEdge(16, size);\n      outerRadius = trackInnerEdge;\n      innerRadius = trackInnerEdge - markerLengthInSvgUnits;\n    }\n\n    const outerPos = getThumbPosition(\n      angle,\n      outerRadius,\n      SVG_CONFIG.CENTER_X,\n      SVG_CONFIG.CENTER_Y,\n    );\n    const innerPos = getThumbPosition(\n      angle,\n      innerRadius,\n      SVG_CONFIG.CENTER_X,\n      SVG_CONFIG.CENTER_Y,\n    );\n\n    return {\n      value,\n      angle,\n      outerPos,\n      innerPos,\n    };\n  });\n\n  // Calculate dynamic marker strokeWidth: scales from md baseline (1.5 at 96px)\n  const markerStrokeWidth = (size / 96) * 1.5;\n\n  const markerElements = (\n    <g className=\"stroke-muted-foreground/50\">\n      {markers.map((marker, i) => (\n        <line\n          key={i}\n          x1={marker.innerPos.x}\n          y1={marker.innerPos.y}\n          x2={marker.outerPos.x}\n          y2={marker.outerPos.y}\n          strokeWidth={markerStrokeWidth}\n          strokeLinecap=\"round\"\n        />\n      ))}\n    </g>\n  );\n\n  const defaultProps = createSvgOverlayProps(\n    SLOT_NAMES.MARKERS,\n    className,\n    false,\n  );\n\n  const element = useRender({\n    defaultTagName: \"svg\",\n    render: render,\n    props: mergeProps<\"svg\">(defaultProps, {\n      ...props,\n      children: markerElements,\n    }),\n  });\n\n  return element;\n}\n",
      "type": "registry:ui",
      "target": "components/ui/cubby-ui/circular-slider.tsx"
    },
    {
      "path": "registry/default/circular-slider/lib/angle-calculations.ts",
      "content": "/**\r\n * Utility functions for circular slider angle and position calculations\r\n */\r\n\r\n/**\r\n * Normalize an angle to 0-360 range\r\n */\r\nexport function normalizeAngle(angle: number): number {\r\n  const normalized = angle % 360;\r\n  return normalized < 0 ? normalized + 360 : normalized;\r\n}\r\n\r\n/**\r\n * Convert a value to an angle based on min/max range\r\n * @param value - The value to convert\r\n * @param min - Minimum value\r\n * @param max - Maximum value\r\n * @param startAngle - Starting angle in degrees (0 = top)\r\n * @param direction - Direction of rotation\r\n * @param continuous - Whether the slider is in continuous mode (360° arc) or non-continuous mode (270° arc)\r\n * @returns Angle in degrees\r\n */\r\nexport function valueToAngle(\r\n  value: number,\r\n  min: number,\r\n  max: number,\r\n  startAngle: number = 0,\r\n  direction: \"clockwise\" | \"counterclockwise\" = \"clockwise\",\r\n  continuous: boolean = true,\r\n): number {\r\n  const range = max - min;\r\n  // Use 270° arc for non-continuous mode so min and max are visually separated\r\n  // Use 360° arc for continuous mode (full circle)\r\n  const arcDegrees = continuous ? 360 : 270;\r\n  // For non-continuous mode, offset by 225° to center the gap at bottom (180°)\r\n  // Gap will be from 135° to 225° (90° gap centered at 180° = bottom)\r\n  const offset = continuous ? 0 : 225;\r\n  const normalizedValue = ((value - min) / range) * arcDegrees;\r\n  const angle =\r\n    direction === \"clockwise\"\r\n      ? startAngle + normalizedValue + offset\r\n      : startAngle - normalizedValue + offset;\r\n  return normalizeAngle(angle);\r\n}\r\n\r\n/**\r\n * Convert an angle to a value based on min/max range\r\n * @param angle - Angle in degrees\r\n * @param min - Minimum value\r\n * @param max - Maximum value\r\n * @param startAngle - Starting angle in degrees\r\n * @param direction - Direction of rotation\r\n * @param continuous - Whether the slider is in continuous mode (360° arc) or non-continuous mode (270° arc)\r\n * @returns The calculated value\r\n */\r\nexport function angleToValue(\r\n  angle: number,\r\n  min: number,\r\n  max: number,\r\n  startAngle: number = 0,\r\n  direction: \"clockwise\" | \"counterclockwise\" = \"clockwise\",\r\n  continuous: boolean = true,\r\n): number {\r\n  // For non-continuous mode, clamp angles that fall in the gap area\r\n  if (!continuous) {\r\n    const normalizedAngle = normalizeAngle(angle);\r\n\r\n    // Gap is centered at 180° (bottom), spanning 135° to 225° (90° gap)\r\n    if (normalizedAngle >= 135 && normalizedAngle <= 225) {\r\n      // Clamp to nearest edge of the gap\r\n      // 135° to 180° → clamp to 135° (max value position)\r\n      // 180° to 225° → clamp to 225° (min value position)\r\n      angle = normalizedAngle <= 180 ? 135 : 225;\r\n    }\r\n  }\r\n\r\n  // For non-continuous mode, subtract the 225° offset to account for gap positioning\r\n  const offset = continuous ? 0 : 225;\r\n  const adjustedAngle = angle - offset;\r\n  const normalizedAngle = normalizeAngle(adjustedAngle);\r\n  const normalizedStart = normalizeAngle(startAngle);\r\n\r\n  let diff =\r\n    direction === \"clockwise\"\r\n      ? normalizedAngle - normalizedStart\r\n      : normalizedStart - normalizedAngle;\r\n\r\n  if (diff < 0) diff += 360;\r\n\r\n  const range = max - min;\r\n  // Use 270° arc for non-continuous mode so min and max are visually separated\r\n  // Use 360° arc for continuous mode (full circle)\r\n  const arcDegrees = continuous ? 360 : 270;\r\n  const value = min + (diff / arcDegrees) * range;\r\n\r\n  return value;\r\n}\r\n\r\n/**\r\n * Calculate angle from mouse/touch position relative to circle center\r\n * @param x - X coordinate\r\n * @param y - Y coordinate\r\n * @param centerX - Circle center X\r\n * @param centerY - Circle center Y\r\n * @returns Angle in degrees (0 = top, increases clockwise)\r\n */\r\nexport function positionToAngle(\r\n  x: number,\r\n  y: number,\r\n  centerX: number,\r\n  centerY: number,\r\n): number {\r\n  const radians = Math.atan2(y - centerY, x - centerX);\r\n  // Convert to degrees and adjust so 0° is at top (subtract 90°)\r\n  const degrees = radians * (180 / Math.PI) + 90;\r\n  return normalizeAngle(degrees);\r\n}\r\n\r\n/**\r\n * Calculate thumb position on circle based on angle\r\n * @param angle - Angle in degrees (0 = top)\r\n * @param radius - Circle radius\r\n * @param centerX - Circle center X\r\n * @param centerY - Circle center Y\r\n * @returns Object with x and y coordinates\r\n */\r\nexport function getThumbPosition(\r\n  angle: number,\r\n  radius: number,\r\n  centerX: number = 100,\r\n  centerY: number = 100,\r\n): { x: number; y: number } {\r\n  // Subtract 90° because 0° should be at top\r\n  const radians = ((angle - 90) * Math.PI) / 180;\r\n  // Round to 4 decimal places to avoid hydration errors from floating-point precision\r\n  const round = (n: number) => Math.round(n * 10000) / 10000;\r\n  return {\r\n    x: round(centerX + radius * Math.cos(radians)),\r\n    y: round(centerY + radius * Math.sin(radians)),\r\n  };\r\n}\r\n\r\n/**\r\n * Create SVG arc path for the indicator\r\n * @param centerX - Circle center X\r\n * @param centerY - Circle center Y\r\n * @param radius - Circle radius\r\n * @param startAngle - Start angle in degrees (0 = top)\r\n * @param endAngle - End angle in degrees\r\n * @param direction - Direction to draw the arc (clockwise or counterclockwise)\r\n * @returns SVG path string\r\n */\r\nexport function describeArc(\r\n  centerX: number,\r\n  centerY: number,\r\n  radius: number,\r\n  startAngle: number,\r\n  endAngle: number,\r\n  direction: \"clockwise\" | \"counterclockwise\" = \"clockwise\",\r\n): string {\r\n  const start = getThumbPosition(startAngle, radius, centerX, centerY);\r\n  const end = getThumbPosition(endAngle, radius, centerX, centerY);\r\n\r\n  const normalizedStart = normalizeAngle(startAngle);\r\n  const normalizedEnd = normalizeAngle(endAngle);\r\n\r\n  let arcAngle =\r\n    direction === \"clockwise\"\r\n      ? normalizedEnd - normalizedStart\r\n      : normalizedStart - normalizedEnd;\r\n  if (arcAngle < 0) arcAngle += 360;\r\n\r\n  const largeArcFlag = arcAngle > 180 ? 1 : 0;\r\n  // Sweep flag: 1 for clockwise, 0 for counterclockwise\r\n  const sweepFlag = direction === \"clockwise\" ? 1 : 0;\r\n\r\n  if (arcAngle === 0) {\r\n    return \"\";\r\n  }\r\n\r\n  return [\r\n    \"M\",\r\n    start.x,\r\n    start.y,\r\n    \"A\",\r\n    radius,\r\n    radius,\r\n    0,\r\n    largeArcFlag,\r\n    sweepFlag,\r\n    end.x,\r\n    end.y,\r\n  ].join(\" \");\r\n}\r\n\r\n/**\r\n * Round a value to the nearest step\r\n * @param value - Value to round\r\n * @param step - Step size\r\n * @param min - Minimum value (for precision)\r\n * @returns Rounded value\r\n */\r\nexport function roundToStep(value: number, step: number, min: number): number {\r\n  const steps = Math.round((value - min) / step);\r\n  return min + steps * step;\r\n}\r\n\r\n/**\r\n * Clamp a value between min and max\r\n */\r\nexport function clamp(value: number, min: number, max: number): number {\r\n  return Math.min(Math.max(value, min), max);\r\n}\r\n\r\n/**\r\n * Check if angle is within a range (handles wraparound)\r\n */\r\nexport function isAngleInRange(\r\n  angle: number,\r\n  startAngle: number,\r\n  endAngle: number,\r\n): boolean {\r\n  const normalizedAngle = normalizeAngle(angle);\r\n  const normalizedStart = normalizeAngle(startAngle);\r\n  const normalizedEnd = normalizeAngle(endAngle);\r\n\r\n  if (normalizedStart <= normalizedEnd) {\r\n    return (\r\n      normalizedAngle >= normalizedStart && normalizedAngle <= normalizedEnd\r\n    );\r\n  } else {\r\n    return (\r\n      normalizedAngle >= normalizedStart || normalizedAngle <= normalizedEnd\r\n    );\r\n  }\r\n}\r\n",
      "type": "registry:lib",
      "target": "lib/cubby-ui/angle-calculations.ts"
    },
    {
      "path": "registry/default/circular-slider/lib/pointer-utils.ts",
      "content": "import * as React from \"react\";\r\nimport { positionToAngle, angleToValue } from \"./angle-calculations\";\r\n\r\n/**\r\n * Get the center coordinates of a circle container\r\n */\r\nexport function getCircleCenter(container: HTMLElement): {\r\n  x: number;\r\n  y: number;\r\n} {\r\n  const rect = container.getBoundingClientRect();\r\n  return {\r\n    x: rect.left + rect.width / 2,\r\n    y: rect.top + rect.height / 2,\r\n  };\r\n}\r\n\r\n/**\r\n * Convert pointer position to slider value\r\n * Consolidates the angle and value calculation logic\r\n */\r\nexport function getValueFromPointerPosition(\r\n  e: React.PointerEvent,\r\n  container: HTMLElement,\r\n  min: number,\r\n  max: number,\r\n  startAngle: number,\r\n  direction: \"clockwise\" | \"counterclockwise\",\r\n  continuous: boolean,\r\n): number {\r\n  const { x: centerX, y: centerY } = getCircleCenter(container);\r\n  const angle = positionToAngle(e.clientX, e.clientY, centerX, centerY);\r\n  return angleToValue(angle, min, max, startAngle, direction, continuous);\r\n}\r\n",
      "type": "registry:lib",
      "target": "lib/cubby-ui/pointer-utils.ts"
    },
    {
      "path": "registry/default/circular-slider/lib/svg-constants.ts",
      "content": "/**\r\n * SVG Constants for Circular Slider\r\n * Centralized configuration for SVG coordinates, dimensions, and styling\r\n */\r\n\r\nexport const SVG_VIEWBOX_SIZE = 200;\r\nexport const DEFAULT_STROKE_WIDTH = 16;\r\n\r\nexport const SVG_CONFIG = {\r\n  VIEWBOX_SIZE: 200,\r\n  CENTER_X: 100,\r\n  CENTER_Y: 100,\r\n  VIEWBOX_STRING: \"0 0 200 200\",\r\n} as const;\r\n\r\nexport const RADIUS_CONFIG = {\r\n  TRACK: 80,\r\n  FILLED_BACKGROUND: 90,\r\n} as const;\r\n\r\nexport const SLOT_NAMES = {\r\n  ROOT: \"circular-slider\",\r\n  TRACK: \"circular-slider-track\",\r\n  INDICATOR: \"circular-slider-indicator\",\r\n  THUMB: \"circular-slider-thumb\",\r\n  VALUE: \"circular-slider-value\",\r\n  MARKERS: \"circular-slider-markers\",\r\n} as const;\r\n\r\nexport const VARIANT_COLOR_MAP = {\r\n  track: {\r\n    default: \"stroke-border\",\r\n    filled: \"stroke-transparent\",\r\n  },\r\n  indicator: {\r\n    default: \"stroke-primary\",\r\n    filled: \"stroke-transparent\",\r\n  },\r\n} as const;\r\n",
      "type": "registry:lib",
      "target": "lib/cubby-ui/svg-constants.ts"
    },
    {
      "path": "registry/default/circular-slider/lib/svg-utils.ts",
      "content": "import { cn } from \"@/lib/utils\";\r\nimport {\r\n  SVG_VIEWBOX_SIZE,\r\n  SVG_CONFIG,\r\n  RADIUS_CONFIG,\r\n  DEFAULT_STROKE_WIDTH,\r\n} from \"./svg-constants\";\r\n\r\n/**\r\n * Convert pixels to SVG viewBox units\r\n */\r\nexport function pixelsToSvgUnits(\r\n  pixels: number,\r\n  containerSize: number,\r\n): number {\r\n  return pixels * (SVG_VIEWBOX_SIZE / containerSize);\r\n}\r\n\r\n/**\r\n * Calculate the inner edge of the track based on stroke width\r\n */\r\nexport function getTrackInnerEdge(\r\n  strokeWidthInPixels: number,\r\n  containerSize: number,\r\n): number {\r\n  const strokeWidthInSvgUnits = pixelsToSvgUnits(\r\n    strokeWidthInPixels,\r\n    containerSize,\r\n  );\r\n  return RADIUS_CONFIG.TRACK - strokeWidthInSvgUnits / 2;\r\n}\r\n\r\n/**\r\n * Create common props for SVG overlay elements\r\n */\r\nexport function createSvgOverlayProps(\r\n  slot: string,\r\n  className?: string,\r\n  pointerEvents: boolean = true,\r\n) {\r\n  return {\r\n    \"data-slot\": slot,\r\n    viewBox: SVG_CONFIG.VIEWBOX_STRING,\r\n    className: cn(\r\n      \"absolute inset-0 w-full h-full\",\r\n      !pointerEvents && \"pointer-events-none\",\r\n      className,\r\n    ),\r\n  };\r\n}\r\n\r\n/**\r\n * Convert strokeWidth prop (in pixels) to SVG units\r\n * Returns the converted value or default if not provided\r\n */\r\nexport function strokeWidthToSvgUnits(\r\n  strokeWidth: number | undefined,\r\n  size: number,\r\n): number {\r\n  const pixels = strokeWidth ?? DEFAULT_STROKE_WIDTH;\r\n  return pixelsToSvgUnits(pixels, size);\r\n}\r\n",
      "type": "registry:lib",
      "target": "lib/cubby-ui/svg-utils.ts"
    }
  ]
}