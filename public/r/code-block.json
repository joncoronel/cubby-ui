{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "code-block",
  "type": "registry:ui",
  "title": "Code-block",
  "description": "A code-block component.",
  "dependencies": [
    "lucide-react",
    "@icons-pack/react-simple-icons",
    "shiki",
    "hast-util-to-jsx-runtime"
  ],
  "registryDependencies": [
    "@cubby-ui/copy-button",
    "@cubby-ui/tabs",
    "@cubby-ui/scroll-area"
  ],
  "files": [
    {
      "path": "registry/default/code-block/code-block.tsx",
      "content": "\"use client\";\n\nimport {\n  useLayoutEffect,\n  useState,\n  useMemo,\n  ComponentType,\n  createContext,\n  useContext,\n} from \"react\";\nimport * as React from \"react\";\nimport { mergeProps } from \"@base-ui/react/merge-props\";\nimport { useRender } from \"@base-ui/react/use-render\";\nimport { highlight } from \"@/registry/default/code-block/lib/shiki-shared\";\nimport { stripDiffMarker } from \"@/registry/default/code-block/lib/transformers/utils\";\nimport { cn } from \"@/lib/utils\";\nimport { Terminal } from \"lucide-react\";\nimport { CopyButton } from \"@/registry/default/copy-button/copy-button\";\nimport {\n  SiTypescript,\n  SiJavascript,\n  SiPython,\n} from \"@icons-pack/react-simple-icons\";\nimport type { BundledLanguage } from \"shiki/langs\";\nimport { Tabs, TabsList, TabsTrigger } from \"@/registry/default/tabs/tabs\";\nimport {\n  ScrollArea,\n  type FadeEdges,\n} from \"@/registry/default/scroll-area/scroll-area\";\n\n// Context for sharing code block state\ninterface CodeBlockContextValue {\n  code: string;\n  language: string;\n  nodes: React.ReactElement | undefined;\n  lines: string[];\n  hasFocus: boolean;\n  showDiff: boolean;\n  floatingCopy: boolean;\n}\n\nconst CodeBlockContext = createContext<CodeBlockContextValue | null>(null);\n\nfunction useCodeBlock() {\n  const context = useContext(CodeBlockContext);\n  if (!context) {\n    throw new Error(\n      \"CodeBlock subcomponents must be used within a CodeBlock component\",\n    );\n  }\n  return context;\n}\n\n// Language icon mapping\nconst LANGUAGE_ICONS: Record<\n  string,\n  ComponentType<{ size: number; className: string }>\n> = {\n  typescript: SiTypescript,\n  ts: SiTypescript,\n  tsx: SiTypescript,\n  javascript: SiJavascript,\n  js: SiJavascript,\n  jsx: SiJavascript,\n  bash: Terminal,\n  sh: Terminal,\n  shell: Terminal,\n  python: SiPython,\n  py: SiPython,\n};\n\nfunction getLanguageIcon(language: string) {\n  const normalized = language.toLowerCase();\n  const Icon = LANGUAGE_ICONS[normalized];\n\n  if (Icon) {\n    return <Icon size={16} className=\"text-muted-foreground\" />;\n  }\n\n  return <span className=\"text-muted-foreground text-sm\">{language}</span>;\n}\n\n// Root component\ninterface CodeBlockProps extends Omit<\n  useRender.ComponentProps<\"div\">,\n  \"children\"\n> {\n  code: string;\n  language?: string;\n  initial?: React.ReactElement;\n  floatingCopy?: boolean;\n  highlightLines?: number[] | string;\n  showDiff?: boolean;\n  focusLines?: number[] | string;\n  children: React.ReactNode;\n}\n\nfunction CodeBlock({\n  code,\n  language = \"javascript\",\n  initial,\n  floatingCopy = false,\n  highlightLines,\n  showDiff,\n  focusLines,\n  className,\n  render,\n  children,\n  ...props\n}: CodeBlockProps) {\n  const [nodes, setNodes] = useState(initial);\n\n  // Memoize line calculations\n  const lines = useMemo(() => code.split(\"\\n\"), [code]);\n\n  useLayoutEffect(() => {\n    // Set initial content or highlight code\n    if (initial) {\n      setNodes(initial);\n    } else {\n      const normalizedLanguage = (language as BundledLanguage) || \"javascript\";\n      void highlight(code, normalizedLanguage, {\n        highlightLines,\n        showDiff,\n        focusLines,\n      }).then(setNodes);\n    }\n  }, [code, language, initial, highlightLines, showDiff, focusLines]);\n\n  // Memoize context value to prevent unnecessary re-renders\n  const contextValue = useMemo(\n    () => ({\n      language,\n      code,\n      nodes,\n      lines,\n      hasFocus: !!focusLines,\n      showDiff: !!showDiff,\n      floatingCopy,\n    }),\n    [language, code, nodes, lines, focusLines, showDiff, floatingCopy],\n  );\n\n  // Wrap children with context\n  const content = (\n    <CodeBlockContext.Provider value={contextValue}>\n      {children}\n    </CodeBlockContext.Provider>\n  );\n\n  const defaultProps = {\n    \"data-slot\": \"code-block\",\n    className: cn(\n      \"group bg-muted border border-border/60 max-w-full w-full rounded-2xl p-1 pt-0 relative\",\n      // Restore top padding when there's no header\n      \"has-[[data-slot='code-block-pre']:first-child]:pt-1\",\n      className,\n    ),\n    children: content,\n  };\n\n  return useRender({\n    defaultTagName: \"div\",\n    render,\n    props: mergeProps<\"div\">(defaultProps, props),\n  });\n}\n\n// Header component\ninterface CodeBlockHeaderProps\n  extends useRender.ComponentProps<\"div\">, Partial<BaseTabsProps> {\n  filename?: string;\n  tabVariant?: React.ComponentProps<typeof TabsList>[\"variant\"];\n  customIcon?: React.ReactNode;\n  showCopy?: boolean;\n}\n\nfunction CodeBlockHeader({\n  className,\n  render,\n  children,\n  filename,\n  tabs,\n  activeTab,\n  onTabChange,\n  tabVariant,\n  customIcon,\n  showCopy = true,\n  ...props\n}: CodeBlockHeaderProps) {\n  const context = useCodeBlock();\n  const language = context.language;\n  const code = context.code;\n\n  // If children provided, use custom layout\n  if (children) {\n    const defaultProps = {\n      \"data-slot\": \"code-block-header\",\n      className: cn(\n        \"flex items-center justify-between bg-transparent px-3 py-1\",\n        className,\n      ),\n      children,\n    };\n\n    return useRender({\n      defaultTagName: \"div\",\n      render,\n      props: mergeProps<\"div\">(defaultProps, props),\n    });\n  }\n\n  // Auto-layout based on props\n  const startContent = (\n    <div className=\"flex min-w-0 items-center gap-2\">\n      {language && (\n        <CodeBlockLanguage language={language} customIcon={customIcon} />\n      )}\n      {filename && <CodeBlockFilename>{filename}</CodeBlockFilename>}\n      {tabs && activeTab && onTabChange && (\n        <CodeBlockTabs\n          tabs={tabs}\n          activeTab={activeTab}\n          onTabChange={onTabChange}\n          variant={tabVariant}\n        />\n      )}\n    </div>\n  );\n\n  const endContent = showCopy && code && (\n    <div className=\"flex items-center gap-2\">\n      <CopyButton data-slot=\"code-block-copy-button\" content={code} />\n    </div>\n  );\n\n  const defaultProps = {\n    \"data-slot\": \"code-block-header\",\n    className: cn(\n      \"flex items-center justify-between bg-transparent px-3 py-1\",\n      className,\n    ),\n    children: (\n      <>\n        {startContent}\n        {endContent}\n      </>\n    ),\n  };\n\n  return useRender({\n    defaultTagName: \"div\",\n    render,\n    props: mergeProps<\"div\">(defaultProps, props),\n  });\n}\n\n// Language icon component\ninterface CodeBlockLanguageProps extends useRender.ComponentProps<\"div\"> {\n  language: string;\n  customIcon?: React.ReactNode;\n}\n\nfunction CodeBlockLanguage({\n  language,\n  customIcon,\n  className,\n  render,\n  ...props\n}: CodeBlockLanguageProps) {\n  // Use custom icon if provided, otherwise get default language icon\n  const icon = customIcon ?? getLanguageIcon(language);\n\n  const defaultProps = {\n    \"data-slot\": \"code-block-language\",\n    className: cn(\"flex items-center gap-1.5\", className),\n    children: icon,\n  };\n\n  return useRender({\n    defaultTagName: \"div\",\n    render,\n    props: mergeProps<\"div\">(defaultProps, props),\n  });\n}\n\n// Filename component\ninterface CodeBlockFilenameProps extends useRender.ComponentProps<\"span\"> {}\n\nfunction CodeBlockFilename({\n  className,\n  render,\n  children,\n  ...props\n}: CodeBlockFilenameProps) {\n  const defaultProps = {\n    \"data-slot\": \"code-block-filename\",\n    className: cn(\"text-sm font-medium\", className),\n    children,\n  };\n\n  return useRender({\n    defaultTagName: \"span\",\n    render,\n    props: mergeProps<\"span\">(defaultProps, props),\n  });\n}\n\n// Tabs component\ninterface HeaderTab {\n  value: string;\n  label: string;\n}\n\n// Shared base type for tabs configuration\ninterface BaseTabsProps {\n  tabs: HeaderTab[];\n  activeTab: React.ComponentProps<typeof Tabs>[\"value\"];\n  onTabChange: React.ComponentProps<typeof Tabs>[\"onValueChange\"];\n}\n\ninterface CodeBlockTabsProps\n  extends useRender.ComponentProps<\"div\">, BaseTabsProps {\n  variant?: React.ComponentProps<typeof TabsList>[\"variant\"];\n}\n\nfunction CodeBlockTabs({\n  tabs,\n  activeTab,\n  onTabChange,\n  variant = \"capsule\",\n  className,\n  render,\n  ...props\n}: CodeBlockTabsProps) {\n  const tabsElement = (\n    <Tabs value={activeTab} onValueChange={onTabChange} className=\"gap-1\">\n      <div className=\"scrollbar-hide max-w-full overflow-x-auto\">\n        <TabsList\n          variant={variant}\n          size=\"small\"\n          className=\"w-max bg-transparent p-0 shadow-none! ring-0\"\n        >\n          {tabs.map((tab) => (\n            <TabsTrigger key={tab.value} value={tab.value}>\n              {tab.label}\n            </TabsTrigger>\n          ))}\n        </TabsList>\n      </div>\n    </Tabs>\n  );\n\n  const defaultProps = {\n    \"data-slot\": \"code-block-tabs\",\n    className: cn(\"ml-2 min-w-0 overflow-hidden\", className),\n    children: tabsElement,\n  };\n\n  return useRender({\n    defaultTagName: \"div\",\n    render,\n    props: mergeProps<\"div\">(defaultProps, props),\n  });\n}\n\n// Floating copy button component (wrapper with positioning)\ninterface CodeBlockFloatingCopyProps extends useRender.ComponentProps<\"div\"> {}\n\nfunction CodeBlockFloatingCopy({\n  className,\n  render,\n  ...props\n}: CodeBlockFloatingCopyProps) {\n  const context = useCodeBlock();\n  const code = context.code;\n\n  const defaultProps = {\n    \"data-slot\": \"code-block-floating-copy\",\n    className: cn(\"absolute pointer-events-none z-1 top-2 right-2\", className),\n    children: (\n      <CopyButton\n        data-slot=\"code-block-floating-copy\"\n        content={code}\n        className=\"pointer-events-auto backdrop-blur-sm\"\n      />\n    ),\n  };\n\n  return useRender({\n    defaultTagName: \"div\",\n    render,\n    props: mergeProps<\"div\">(defaultProps, props),\n  });\n}\n\n// Pre component (wrapper for content)\ninterface CodeBlockPreProps extends useRender.ComponentProps<\"pre\"> {\n  /** Show line numbers in the gutter */\n  lineNumbers?: boolean;\n  /** Configure fade edges to indicate scrollable content. Defaults to true. */\n  fadeEdges?: FadeEdges;\n  /** Hide scrollbars while keeping scroll functionality */\n  hideScrollbar?: boolean;\n  /** Use native browser scrolling instead of Base UI ScrollArea */\n  nativeScroll?: boolean;\n}\n\nfunction CodeBlockPre({\n  className,\n  render,\n  children,\n  lineNumbers = false,\n  fadeEdges = true,\n  hideScrollbar = false,\n  nativeScroll = false,\n  ...props\n}: CodeBlockPreProps) {\n  const context = useCodeBlock();\n  const lines = context.lines;\n  const hasFocus = context.hasFocus;\n  const floatingCopy = context.floatingCopy;\n\n  // If lineNumbers is enabled, wrap children in flex layout\n  const content =\n    lineNumbers && lines.length > 0 ? (\n      <div className=\"flex\">\n        <CodeBlockLineNumbers lines={lines} />\n        <div className=\"min-w-0 flex-1\">{children}</div>\n      </div>\n    ) : (\n      children\n    );\n\n  const defaultProps = {\n    \"data-slot\": \"code-block-pre\",\n    \"data-has-focus\": hasFocus ? \"true\" : undefined,\n    className: cn(\n      \"relative bg-card border border-border/60 rounded-lg whitespace-pre overflow-hidden max-h-96 flex flex-col\",\n      // Focus mode: blur and dim non-focused lines\n      \"[&[data-has-focus]_.line:not([data-focused])]:opacity-50 [&[data-has-focus]_.line:not([data-focused])]:blur-[1px] [&[data-has-focus]_.line:not([data-focused])]:transition-all\",\n      className,\n    ),\n    children: (\n      <>\n        {floatingCopy && <CodeBlockFloatingCopy />}\n        <ScrollArea\n          fadeEdges={fadeEdges}\n          hideScrollbar={hideScrollbar}\n          nativeScroll={nativeScroll}\n          viewportClassName=\"py-3\"\n          className=\"min-h-0 flex-1\"\n        >\n          {content}\n        </ScrollArea>\n      </>\n    ),\n  };\n\n  return useRender({\n    defaultTagName: \"pre\",\n    render,\n    props: mergeProps<\"pre\">(defaultProps, props),\n  });\n}\n\n// Line numbers component\ninterface CodeBlockLineNumbersProps extends useRender.ComponentProps<\"div\"> {\n  lines: string[];\n}\n\nfunction CodeBlockLineNumbers({\n  className,\n  render,\n  lines,\n  ...props\n}: CodeBlockLineNumbersProps) {\n  const lineNumbers = lines.map((_, index) => (\n    <div\n      key={index}\n      className=\"text-right text-[.8125rem] leading-normal tabular-nums\"\n    >\n      {index + 1}\n    </div>\n  ));\n\n  const defaultProps = {\n    \"data-slot\": \"code-block-line-numbers\",\n    \"data-line-numbers\": \"true\",\n    className: cn(\"text-muted-foreground pl-3 select-none\", className),\n    children: lineNumbers,\n  };\n\n  return useRender({\n    defaultTagName: \"div\",\n    render,\n    props: mergeProps<\"div\">(defaultProps, props),\n  });\n}\n\n// Code component (the highlighted code)\ninterface CodeBlockCodeProps extends useRender.ComponentProps<\"div\"> {}\n\nfunction CodeBlockCode({ className, render, ...props }: CodeBlockCodeProps) {\n  const context = useCodeBlock();\n  const code = context.code;\n  const nodes = context.nodes;\n  const showDiff = context.showDiff;\n\n  const prehighlightedCode = useMemo(() => {\n    const originalLines = code.split(\"\\n\");\n    let lines = [...originalLines];\n\n    // Strip diff markers if showDiff is enabled (match Shiki behavior)\n    if (showDiff) {\n      lines = lines.map((line) => stripDiffMarker(line));\n    }\n\n    // Create structure matching Shiki: spans with newlines between them\n    const elements: React.ReactNode[] = [];\n    lines.forEach((line, index) => {\n      elements.push(\n        <span key={`line-${index}`} className=\"line\">\n          {line || \" \"}\n        </span>,\n      );\n      // Add newline after each line except the last\n      if (index < lines.length - 1) {\n        elements.push(\"\\n\");\n      }\n    });\n    return <code>{elements}</code>;\n  }, [code, showDiff]);\n\n  const defaultProps = {\n    \"data-slot\": \"code-block-code\",\n    className: cn(\n      \"block text-[.8125rem] leading-normal whitespace-pre w-fit min-w-full\",\n      // Base padding\n      \"[&:not(:has(.line))]:px-3 [&_.line]:!px-3 [&:not(:has(.line))]:pr-8 [&_.line]:!pr-8\",\n      // Make lines span full width with inline-block and 100% width\n      \"[&_.line]:inline-block [&_.line]:min-w-full\",\n      // Highlighted lines - match pre-highlighted padding so border fits in the space\n      \"[&_.line[data-highlighted]]:bg-primary/10 [&_.line[data-highlighted]]:border-l-2 [&_.line[data-highlighted]]:border-primary/50 [&_.line[data-highlighted]]:!pl-[calc(0.75rem-2px)]\",\n      // Diff: added lines\n      \"[&_.line[data-diff='added']]:bg-green-500/10 [&_.line[data-diff='added']]:border-l-2 [&_.line[data-diff='added']]:border-green-500/70 [&_.line[data-diff='added']]:!pl-[calc(0.75rem-2px)]\",\n      // Diff: removed lines\n      \"[&_.line[data-diff='removed']]:bg-red-500/10 [&_.line[data-diff='removed']]:border-l-2 [&_.line[data-diff='removed']]:border-red-500/70 [&_.line[data-diff='removed']]:!pl-[calc(0.75rem-2px)]\",\n      // Diff: modified lines\n      \"[&_.line[data-diff='modified']]:bg-yellow-500/10 [&_.line[data-diff='modified']]:border-l-2 [&_.line[data-diff='modified']]:border-yellow-500/70 [&_.line[data-diff='modified']]:!pl-[calc(0.75rem-2px)]\",\n      className,\n    ),\n    children: nodes || prehighlightedCode,\n  };\n\n  return useRender({\n    defaultTagName: \"div\",\n    render,\n    props: mergeProps<\"div\">(defaultProps, props),\n  });\n}\n\nexport {\n  CodeBlock,\n  CodeBlockHeader,\n  CodeBlockFloatingCopy,\n  CodeBlockPre,\n  CodeBlockLineNumbers,\n  CodeBlockCode,\n  useCodeBlock,\n};\nexport type { FadeEdges };\n",
      "type": "registry:ui",
      "target": "components/ui/cubby-ui/code-block/code-block.tsx"
    },
    {
      "path": "registry/default/code-block/lib/shiki-shared.ts",
      "content": "import type { JSX } from \"react\";\r\nimport type { HighlighterCore, ShikiTransformer } from \"shiki/core\";\r\nimport type { BundledLanguage } from \"shiki/langs\";\r\nimport { toJsxRuntime } from \"hast-util-to-jsx-runtime\";\r\nimport { Fragment } from \"react\";\r\nimport { jsx, jsxs } from \"react/jsx-runtime\";\r\nimport { createHighlighterCore } from \"shiki/core\";\r\nimport { createJavaScriptRegexEngine } from \"shiki/engine/javascript\";\r\nimport { createHighlightLinesTransformer } from \"./transformers/highlight-lines\";\r\nimport { createDiffTransformer } from \"./transformers/diff\";\r\nimport { createFocusTransformer } from \"./transformers/focus\";\r\n\r\n// Global highlighter promise (per Shiki Next.js docs pattern)\r\n// Define without await as a global variable to reference from components\r\n// https://shiki.style/packages/next\r\nconst highlighter = createHighlighterCore({\r\n  themes: [\r\n    import(\"shiki/themes/github-light.mjs\"),\r\n    import(\"shiki/themes/github-dark.mjs\"),\r\n  ],\r\n  langs: [], // Load languages on-demand for optimal performance\r\n  engine: createJavaScriptRegexEngine(), // Smaller bundle, faster startup than WASM\r\n});\r\n\r\n// Track loaded languages to avoid redundant imports\r\nconst loadedLanguages = new Set<string>();\r\n\r\nconst BASE_TRANSFORMERS: ShikiTransformer[] = [\r\n  {\r\n    name: \"remove-background\",\r\n    pre(node: any) {\r\n      delete node.properties.style;\r\n    },\r\n    code(node: any) {\r\n      delete node.properties.style;\r\n    },\r\n  },\r\n  {\r\n    name: \"fix-empty-lines\",\r\n    line(node: any) {\r\n      // Ensure empty lines have a space to maintain height\r\n      // Shiki creates empty .line spans for blank lines which collapse\r\n      if (!node.children || node.children.length === 0) {\r\n        node.children = [{ type: \"text\", value: \" \" }];\r\n      }\r\n    },\r\n  },\r\n];\r\n\r\nexport interface HighlightOptions {\r\n  highlightLines?: number[] | string;\r\n  showDiff?: boolean;\r\n  focusLines?: number[] | string;\r\n}\r\n\r\nasync function highlightWithLang(\r\n  code: string,\r\n  lang: BundledLanguage,\r\n  options?: HighlightOptions,\r\n) {\r\n  // Await the global highlighter promise (per Shiki Next.js docs)\r\n  const instance = await highlighter;\r\n\r\n  // Load language dynamically if not already loaded (cached Set for performance)\r\n  if (!loadedLanguages.has(lang)) {\r\n    // Dynamically import only the specific language module needed\r\n    const langModule = await import(`shiki/langs/${lang}.mjs`);\r\n    await instance.loadLanguage(langModule.default);\r\n    loadedLanguages.add(lang);\r\n  }\r\n\r\n  // Build transformers array based on options\r\n  const transformers: ShikiTransformer[] = [...BASE_TRANSFORMERS];\r\n\r\n  if (options?.highlightLines) {\r\n    transformers.push(createHighlightLinesTransformer(options.highlightLines));\r\n  }\r\n\r\n  if (options?.showDiff) {\r\n    transformers.push(createDiffTransformer());\r\n  }\r\n\r\n  if (options?.focusLines) {\r\n    transformers.push(createFocusTransformer(options.focusLines));\r\n  }\r\n\r\n  const out = instance.codeToHast(code, {\r\n    lang,\r\n    themes: {\r\n      light: \"github-light\",\r\n      dark: \"github-dark\",\r\n    },\r\n    defaultColor: \"light-dark()\",\r\n    transformers,\r\n  });\r\n\r\n  return toJsxRuntime(out, { Fragment, jsx, jsxs }) as JSX.Element;\r\n}\r\n\r\nexport async function highlight(\r\n  code: string,\r\n  lang: BundledLanguage,\r\n  options?: HighlightOptions,\r\n) {\r\n  try {\r\n    return await highlightWithLang(code, lang, options);\r\n  } catch {\r\n    // If language isn't supported, try with javascript as fallback\r\n    try {\r\n      return await highlightWithLang(code, \"javascript\", options);\r\n    } catch {\r\n      // Final fallback to plain text\r\n      return jsx(\"pre\", { children: code }) as JSX.Element;\r\n    }\r\n  }\r\n}\r\n",
      "type": "registry:lib",
      "target": "components/ui/cubby-ui/code-block/lib/shiki-shared.ts"
    },
    {
      "path": "registry/default/code-block/lib/transformers/diff.ts",
      "content": "import type { ShikiTransformer } from \"shiki\";\nimport { detectDiffMarker, stripDiffMarker } from \"./utils\";\n\n/**\n * Shiki transformer that detects diff markers and adds data-diff attributes\n * Supports:\n * - \"+\" prefix for added lines\n * - \"-\" prefix for removed lines\n * - \"!\" prefix for modified lines\n * - Comment variants: \"// +\", \"// -\", \"// !\"\n *\n * The markers are stripped from the displayed code for clean output\n *\n * @returns Shiki transformer\n */\nexport function createDiffTransformer(): ShikiTransformer {\n  // Store original code lines for diff detection\n  let codeLines: string[] = [];\n\n  return {\n    name: \"diff\",\n    preprocess(code) {\n      // Store original lines before Shiki processes them\n      codeLines = code.split(\"\\n\");\n      // Strip diff markers from the code that will be highlighted\n      return code\n        .split(\"\\n\")\n        .map((line) => stripDiffMarker(line))\n        .join(\"\\n\");\n    },\n    line(node, lineNumber) {\n      // lineNumber is 1-indexed by Shiki, convert to 0-indexed for array access\n      const originalLine = codeLines[lineNumber - 1];\n      if (!originalLine) return;\n\n      const diffType = detectDiffMarker(originalLine);\n      if (diffType) {\n        node.properties[\"data-diff\"] = diffType;\n      }\n    },\n  };\n}\n",
      "type": "registry:lib",
      "target": "components/ui/cubby-ui/code-block/lib/transformers/diff.ts"
    },
    {
      "path": "registry/default/code-block/lib/transformers/focus.ts",
      "content": "import type { ShikiTransformer } from \"shiki\";\nimport { parseLineRange } from \"./utils\";\n\n/**\n * Shiki transformer that adds focus attributes to lines\n * - Adds data-line-number to all lines for targeting\n * - Adds data-focused to specified lines\n *\n * @param lines - Line numbers to focus (1-indexed) or range string like \"1-3,5\"\n * @returns Shiki transformer\n */\nexport function createFocusTransformer(\n  lines: number[] | string | undefined,\n): ShikiTransformer {\n  const focusedLines = parseLineRange(lines);\n  const focusSet = new Set(focusedLines);\n\n  return {\n    name: \"focus\",\n    line(node, lineNumber) {\n      // lineNumber is already 1-indexed by Shiki\n      // Add line number to all lines for CSS targeting\n      node.properties[\"data-line-number\"] = String(lineNumber);\n\n      // Mark focused lines\n      if (focusSet.has(lineNumber)) {\n        node.properties[\"data-focused\"] = \"true\";\n      }\n    },\n  };\n}\n",
      "type": "registry:lib",
      "target": "components/ui/cubby-ui/code-block/lib/transformers/focus.ts"
    },
    {
      "path": "registry/default/code-block/lib/transformers/highlight-lines.ts",
      "content": "import type { ShikiTransformer } from \"shiki\";\nimport { parseLineRange } from \"./utils\";\n\n/**\n * Shiki transformer that adds data-highlighted attribute to specified lines\n *\n * @param lines - Line numbers to highlight (1-indexed) or range string like \"1-3,5,7-9\"\n * @returns Shiki transformer\n */\nexport function createHighlightLinesTransformer(\n  lines: number[] | string | undefined,\n): ShikiTransformer {\n  const highlightedLines = parseLineRange(lines);\n  const highlightSet = new Set(highlightedLines);\n\n  return {\n    name: \"highlight-lines\",\n    line(node, lineNumber) {\n      // lineNumber is already 1-indexed by Shiki\n      if (highlightSet.has(lineNumber)) {\n        node.properties[\"data-highlighted\"] = \"true\";\n      }\n    },\n  };\n}\n",
      "type": "registry:lib",
      "target": "components/ui/cubby-ui/code-block/lib/transformers/highlight-lines.ts"
    },
    {
      "path": "registry/default/code-block/lib/transformers/utils.ts",
      "content": "/**\n * Parse line range syntax into an array of line numbers\n * Supports formats:\n * - Array: [1, 2, 3]\n * - String: \"1,3,5\" or \"1-3,5,7-9\"\n * - Mixed: \"1-3,5\" becomes [1, 2, 3, 5]\n *\n * @param input - Line numbers as array or range string\n * @returns Array of line numbers (1-indexed)\n */\nexport function parseLineRange(\n  input: number[] | string | undefined,\n): number[] {\n  if (!input) return [];\n  if (Array.isArray(input)) return input;\n\n  const lines = new Set<number>();\n  const parts = input.split(\",\").map((s) => s.trim());\n\n  for (const part of parts) {\n    // Range format: \"1-3\"\n    if (part.includes(\"-\")) {\n      const [start, end] = part.split(\"-\").map((s) => Number.parseInt(s, 10));\n      if (!Number.isNaN(start) && !Number.isNaN(end)) {\n        for (let i = start; i <= end; i++) {\n          lines.add(i);\n        }\n      }\n    } else {\n      // Single number\n      const num = Number.parseInt(part, 10);\n      if (!Number.isNaN(num)) {\n        lines.add(num);\n      }\n    }\n  }\n\n  return Array.from(lines).sort((a, b) => a - b);\n}\n\n/**\n * Detect diff markers in code lines\n * Supports:\n * - Prefix markers: \"+\", \"-\", \"!\"\n * - Comment markers: \"// +\", \"// -\", \"// !\"\n *\n * @param line - Code line to check\n * @returns Diff type or null\n */\nexport function detectDiffMarker(\n  line: string,\n): \"added\" | \"removed\" | \"modified\" | null {\n  const trimmed = line.trim();\n\n  // Direct prefix markers\n  if (trimmed.startsWith(\"+\")) return \"added\";\n  if (trimmed.startsWith(\"-\")) return \"removed\";\n  if (trimmed.startsWith(\"!\")) return \"modified\";\n\n  // Comment markers (for languages that don't support bare +/-)\n  if (trimmed.startsWith(\"// +\")) return \"added\";\n  if (trimmed.startsWith(\"// -\")) return \"removed\";\n  if (trimmed.startsWith(\"// !\")) return \"modified\";\n\n  return null;\n}\n\n/**\n * Strip diff markers from a code line\n *\n * @param line - Code line with potential diff marker\n * @returns Line with marker removed\n */\nexport function stripDiffMarker(line: string): string {\n  const trimmed = line.trim();\n\n  // Direct prefix markers\n  if (trimmed.startsWith(\"+\") || trimmed.startsWith(\"-\") || trimmed.startsWith(\"!\")) {\n    return line.replace(/^(\\s*)[-+!](\\s?)/, \"$1\");\n  }\n\n  // Comment markers\n  if (trimmed.startsWith(\"// +\") || trimmed.startsWith(\"// -\") || trimmed.startsWith(\"// !\")) {\n    return line.replace(/^(\\s*)\\/\\/\\s*[-+!](\\s?)/, \"$1\");\n  }\n\n  return line;\n}\n",
      "type": "registry:lib",
      "target": "components/ui/cubby-ui/code-block/lib/transformers/utils.ts"
    }
  ]
}