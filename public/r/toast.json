{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "toast",
  "type": "registry:ui",
  "title": "Toast",
  "description": "A toast component.",
  "dependencies": [
    "class-variance-authority",
    "motion",
    "@hugeicons/react",
    "@hugeicons/core-free-icons"
  ],
  "registryDependencies": [
    "@cubby-ui/button"
  ],
  "files": [
    {
      "path": "registry/default/toast/toast.tsx",
      "content": "\"use client\";\r\n\r\nimport * as React from \"react\";\r\nimport { cva } from \"class-variance-authority\";\r\nimport { Popover } from \"@base-ui/react/popover\";\r\nimport { Toast } from \"@base-ui/react/toast\";\r\nimport { AnimatePresence } from \"motion/react\";\r\nimport { motion } from \"motion/react\";\r\nimport { HugeiconsIcon } from \"@hugeicons/react\";\r\nimport {\r\n  AlertCircleIcon,\r\n  Alert02Icon,\r\n  CheckmarkCircle02Icon,\r\n  InformationCircleIcon,\r\n  Loading03Icon,\r\n  Cancel01Icon,\r\n} from \"@hugeicons/core-free-icons\";\r\nimport { cn } from \"@/lib/utils\";\r\nimport { buttonVariants } from \"@/registry/default/button/button\";\r\nimport \"./toast.css\";\r\n\r\n// Module-level managers\r\nconst toastManager = Toast.createToastManager();\r\nconst anchoredToastManager = Toast.createToastManager();\r\n\r\n// Grouped Toast Mappings\r\n// Map groupId -> Base UI toastId\r\nconst groupToToastMap = new Map<string, string>();\r\n// Map itemId -> groupId for lookups\r\nconst groupItemToGroupMap = new Map<string, string>();\r\n// Map groupId -> GroupedToastData (we track our own data since toastManager doesn't expose getSnapshot)\r\nconst groupDataMap = new Map<string, GroupedToastData>();\r\n\r\n// Types\r\nconst TOAST_ICONS = {\r\n  success: CheckmarkCircle02Icon,\r\n  error: AlertCircleIcon,\r\n  warning: Alert02Icon,\r\n  info: InformationCircleIcon,\r\n  loading: Loading03Icon,\r\n} as const;\r\n\r\nconst toastIconVariants = cva(\"\", {\r\n  variants: {\r\n    type: {\r\n      default: \"\",\r\n      success: \"text-success-foreground\",\r\n      error: \"text-danger-foreground\",\r\n      warning: \"text-warning-foreground\",\r\n      info: \"text-info-foreground\",\r\n      loading: \"text-muted-foreground animate-spin\",\r\n    },\r\n  },\r\n});\r\n\r\n// Icon colors in StackedToastItem use in-data-[type=*] selectors,\r\n// which automatically style based on the data-type attribute set by Base UI on Toast.Root\r\n\r\n// Shared Toast CSS Classes (used by StackedToastItem and GroupedToastRoot)\r\nconst TOAST_CSS_VARIABLES = [\r\n  \"[--toast-gap:0.75rem] [--toast-peek:0.75rem]\",\r\n  \"[--toast-scale:calc(max(0,1-(var(--toast-index)*0.1)))]\",\r\n  \"[--toast-shrink:calc(1-var(--toast-scale))]\",\r\n  \"[--toast-calc-height:var(--toast-frontmost-height,var(--toast-height))]\",\r\n  \"data-[position*=top]:[--toast-calc-offset-y:calc(var(--toast-offset-y)+(var(--toast-index)*var(--toast-gap))+var(--toast-swipe-movement-y))]\",\r\n  \"data-[position*=bottom]:[--toast-calc-offset-y:calc(var(--toast-offset-y)*-1+(var(--toast-index)*var(--toast-gap)*-1)+var(--toast-swipe-movement-y))]\",\r\n];\r\n\r\nconst TOAST_POSITION_CLASSES = [\r\n  \"absolute z-[calc(1000-var(--toast-index))] w-full\",\r\n  \"data-[position*=top]:top-0 data-[position*=top]:right-0 data-[position*=top]:left-0 data-[position*=top]:origin-top\",\r\n  \"data-[position*=bottom]:right-0 data-[position*=bottom]:bottom-0 data-[position*=bottom]:left-0 data-[position*=bottom]:origin-bottom\",\r\n];\r\n\r\nconst TOAST_TRANSFORM_CLASSES = [\r\n  \"data-[position*=top]:transform-[translateX(var(--toast-swipe-movement-x))_translateY(calc(var(--toast-swipe-movement-y)+(var(--toast-index)*var(--toast-peek))+(var(--toast-shrink)*var(--toast-calc-height))))_scale(var(--toast-scale))]\",\r\n  \"data-[position*=bottom]:transform-[translateX(var(--toast-swipe-movement-x))_translateY(calc(var(--toast-swipe-movement-y)-(var(--toast-index)*var(--toast-peek))-(var(--toast-shrink)*var(--toast-calc-height))))_scale(var(--toast-scale))]\",\r\n  \"data-expanded:h-(--toast-height)\",\r\n  \"data-position:data-expanded:transform-[translateX(var(--toast-swipe-movement-x))_translateY(var(--toast-calc-offset-y))]\",\r\n];\r\n\r\nconst TOAST_ANIMATION_CLASSES = [\r\n  \"data-[position*=top]:data-starting-style:transform-[translateY(calc(-100%-var(--toast-inset)))]\",\r\n  \"data-[position*=bottom]:data-starting-style:transform-[translateY(calc(100%+var(--toast-inset)))]\",\r\n  \"data-ending-style:opacity-0\",\r\n  \"data-[position*=top]:data-ending-style:not-data-limited:not-data-swipe-direction:transform-[translateY(calc(-100%-var(--toast-inset)))]\",\r\n  \"data-[position*=bottom]:data-ending-style:not-data-limited:not-data-swipe-direction:transform-[translateY(calc(100%+var(--toast-inset)))]\",\r\n  \"data-ending-style:data-[swipe-direction=down]:transform-[translateX(var(--toast-swipe-movement-x))_translateY(calc(var(--toast-swipe-movement-y)+100%+var(--toast-inset)))]\",\r\n  \"data-expanded:data-ending-style:data-[swipe-direction=down]:transform-[translateX(var(--toast-swipe-movement-x))_translateY(calc(var(--toast-swipe-movement-y)+100%+var(--toast-inset)))]\",\r\n  \"data-ending-style:data-[swipe-direction=left]:transform-[translateX(calc(var(--toast-swipe-movement-x)-100%-var(--toast-inset)))_translateY(var(--toast-calc-offset-y))]\",\r\n  \"data-expanded:data-ending-style:data-[swipe-direction=left]:transform-[translateX(calc(var(--toast-swipe-movement-x)-100%-var(--toast-inset)))_translateY(var(--toast-calc-offset-y))]\",\r\n  \"data-ending-style:data-[swipe-direction=right]:transform-[translateX(calc(var(--toast-swipe-movement-x)+100%+var(--toast-inset)))_translateY(var(--toast-calc-offset-y))]\",\r\n  \"data-expanded:data-ending-style:data-[swipe-direction=right]:transform-[translateX(calc(var(--toast-swipe-movement-x)+100%+var(--toast-inset)))_translateY(var(--toast-calc-offset-y))]\",\r\n  \"data-ending-style:data-[swipe-direction=up]:transform-[translateX(var(--toast-swipe-movement-x))_translateY(calc(var(--toast-swipe-movement-y)-100%-var(--toast-inset)))]\",\r\n  \"data-expanded:data-ending-style:data-[swipe-direction=up]:transform-[translateX(var(--toast-swipe-movement-x))_translateY(calc(var(--toast-swipe-movement-y)-100%-var(--toast-inset)))]\",\r\n];\r\n\r\nconst TOAST_VISUAL_CLASSES = [\r\n  \"rounded-lg ring-1 ring-border bg-card text-card-foreground\",\r\n  \"bg-clip-padding shadow-lg/4 select-none\",\r\n  'after:absolute after:left-0 after:h-[calc(var(--toast-gap)+1px)] after:w-full after:content-[\"\"]',\r\n  \"data-[position*=top]:after:bottom-full\",\r\n  \"data-[position*=bottom]:after:top-full\",\r\n  \"data-limited:opacity-0\",\r\n  \"h-(--toast-calc-height)\",\r\n  \"[transition:transform_.5s_cubic-bezier(.22,1,.36,1),opacity_.5s,height_.20s]\",\r\n];\r\n\r\nexport interface ToastOptions<TData extends object = object> {\r\n  title?: string;\r\n  description?: string;\r\n  type?: \"default\" | \"success\" | \"error\" | \"warning\" | \"info\";\r\n  duration?: number;\r\n  priority?: \"low\" | \"high\";\r\n  action?: {\r\n    label: string;\r\n    onClick: () => void;\r\n  };\r\n  data?: TData;\r\n  onClose?: () => void;\r\n  onRemove?: () => void;\r\n  /** Whether to show the close button. Defaults to true. */\r\n  showCloseButton?: boolean;\r\n}\r\n\r\nexport interface AnchoredToastOptions<\r\n  TData extends object = object,\r\n> extends Omit<ToastOptions<TData>, \"type\"> {\r\n  anchor: Element | React.RefObject<Element | null>;\r\n  side?: \"top\" | \"bottom\" | \"left\" | \"right\";\r\n  sideOffset?: number;\r\n  align?: \"start\" | \"center\" | \"end\";\r\n  alignOffset?: number;\r\n  arrow?: boolean;\r\n}\r\n\r\ninterface ToastData {\r\n  id: string;\r\n  title?: string;\r\n  description?: string;\r\n  type?: \"default\" | \"success\" | \"error\" | \"warning\" | \"info\" | \"loading\";\r\n  action?: {\r\n    label: string;\r\n    onClick: () => void;\r\n  };\r\n  showCloseButton?: boolean;\r\n  data?: unknown;\r\n  positionerProps?: {\r\n    anchor?: Element | null;\r\n    side?: \"top\" | \"bottom\" | \"left\" | \"right\";\r\n    sideOffset?: number;\r\n    align?: \"start\" | \"center\" | \"end\";\r\n    alignOffset?: number;\r\n  };\r\n}\r\n\r\n// Grouped Toast Types\r\ntype ToastType =\r\n  | \"default\"\r\n  | \"loading\"\r\n  | \"success\"\r\n  | \"error\"\r\n  | \"warning\"\r\n  | \"info\";\r\n\r\n/** Duration in ms before a completed group item auto-dismisses */\r\nconst GROUP_ITEM_DISMISS_DURATION = 5000;\r\n\r\n/** Individual item within a grouped toast */\r\nexport interface GroupedToastItem {\r\n  id: string;\r\n  title?: string;\r\n  description?: string;\r\n  type?: ToastType;\r\n  action?: {\r\n    label: string;\r\n    onClick: () => void;\r\n  };\r\n  data?: object;\r\n  createdAt: number;\r\n  showCloseButton?: boolean;\r\n  /** Timestamp when this item transitioned to a completed state */\r\n  completedAt?: number;\r\n  /** Duration for progress bar after completing (loading items only). Defaults to GROUP_ITEM_DISMISS_DURATION. */\r\n  duration?: number;\r\n}\r\n\r\n/**\r\n * Counts passed to groupSummary function.\r\n *\r\n * Note: `completedCount`, `successCount`, `errorCount`, `warningCount`, and `infoCount`\r\n * are **historical** - they persist even after completed items are auto-dismissed.\r\n * This ensures accurate summaries like \"3 of 5 succeeded\" remain correct after items fade out.\r\n * Only `loadingCount` reflects currently visible loading items.\r\n */\r\nexport interface GroupSummaryCounts {\r\n  /** Number of items currently in loading state (reflects visible items) */\r\n  loadingCount: number;\r\n  /** Total items that have completed historically (persists after dismiss) */\r\n  completedCount: number;\r\n  /** Total items: loadingCount + completedCount */\r\n  totalCount: number;\r\n  /** Items that completed with type 'success' (historical, persists after dismiss) */\r\n  successCount: number;\r\n  /** Items that completed with type 'error' (historical, persists after dismiss) */\r\n  errorCount: number;\r\n  /** Items that completed with type 'warning' (historical, persists after dismiss) */\r\n  warningCount: number;\r\n  /** Items that completed with type 'info' (historical, persists after dismiss) */\r\n  infoCount: number;\r\n}\r\n\r\n/** Options for creating a grouped toast item */\r\nexport interface GroupedToastOptions<TData extends object = object> {\r\n  groupId: string;\r\n  title?: string;\r\n  description?: string;\r\n  type?: ToastType;\r\n  action?: {\r\n    label: string;\r\n    onClick: () => void;\r\n  };\r\n  data?: TData;\r\n  onClose?: () => void;\r\n  onRemove?: () => void;\r\n  /** Whether to show the close button. Defaults to true. */\r\n  showCloseButton?: boolean;\r\n  /** Summary text or function. Function receives counts: loadingCount (in-progress items) and totalCount (all items including completed). */\r\n  groupSummary: string | ((counts: GroupSummaryCounts) => string);\r\n  groupAction?: {\r\n    label: string;\r\n    expandedLabel?: string;\r\n  };\r\n  /** Duration in ms before the group auto-dismisses. Resets on each new item added. */\r\n  duration?: number;\r\n}\r\n\r\n/** Message configuration for grouped promise toasts */\r\ninterface GroupedPromiseMessage {\r\n  title?: string;\r\n  description?: string;\r\n  type?: ToastType;\r\n}\r\n\r\n/** Messages for each state of a grouped promise toast */\r\nexport interface GroupedPromiseMessages<T> {\r\n  loading: GroupedPromiseMessage & {\r\n    action?: { label: string; onClick: () => void };\r\n  };\r\n  success: PromiseMessage | ((data: T) => GroupedPromiseMessage);\r\n  error: PromiseMessage | ((error: Error) => GroupedPromiseMessage);\r\n  /** Message to show when aborted via AbortController. Defaults to error message. */\r\n  aborted?: PromiseMessage | (() => GroupedPromiseMessage);\r\n}\r\n\r\n/** Options for grouped promise toasts */\r\nexport interface GroupedPromiseOptions extends Omit<\r\n  GroupedToastOptions,\r\n  \"type\" | \"title\" | \"description\" | \"action\"\r\n> {\r\n  /** AbortSignal for cancellation support */\r\n  signal?: AbortSignal;\r\n}\r\n\r\n/** Historical counts that only increment (never decrement on item dismiss) */\r\ninterface HistoricalCounts {\r\n  success: number;\r\n  error: number;\r\n  warning: number;\r\n  info: number;\r\n}\r\n\r\n/** Data structure stored in Base UI toast for grouped toasts */\r\ninterface GroupedToastData {\r\n  isGrouped: true;\r\n  groupId: string;\r\n  /** Pending items (loading state) */\r\n  items: GroupedToastItem[];\r\n  /** Completed items that are transitioning out with progress bar */\r\n  completedItems: GroupedToastItem[];\r\n  isExpanded: boolean;\r\n  summary: string | ((counts: GroupSummaryCounts) => string);\r\n  action: {\r\n    label: string;\r\n    expandedLabel: string;\r\n  };\r\n  /** True once we've shown \"All complete\" (2+ items completed simultaneously) - stays in summary mode */\r\n  hasShownAllComplete: boolean;\r\n  /** Duration in ms, stored so we can pass it on update to reset timer */\r\n  duration?: number;\r\n  /** Historical counts that persist even after items are dismissed */\r\n  historicalCounts: HistoricalCounts;\r\n}\r\n\r\n// Toast Helper Functions\r\n// Overloaded function signatures for JSX support\r\nfunction baseToast(jsx: React.ReactElement): string | undefined;\r\nfunction baseToast<TData extends object = object>(\r\n  jsx: React.ReactElement,\r\n  options: Omit<ToastOptions<TData>, \"title\" | \"description\">,\r\n): string | undefined;\r\nfunction baseToast<TData extends object = object>(\r\n  options: ToastOptions<TData>,\r\n): string | undefined;\r\n\r\nfunction baseToast<TData extends object = object>(\r\n  optionsOrJSX: ToastOptions<TData> | React.ReactElement,\r\n  jsxOptions?: Omit<ToastOptions<TData>, \"title\" | \"description\">,\r\n): string | undefined {\r\n  // Handle JSX element passed directly (with optional options)\r\n  if (React.isValidElement(optionsOrJSX)) {\r\n    return toastManager.add({\r\n      title: \"\",\r\n      description: \"\",\r\n      type: jsxOptions?.type || \"default\",\r\n      timeout: jsxOptions?.duration || undefined,\r\n      priority: jsxOptions?.priority || \"low\",\r\n      ...(jsxOptions?.action && {\r\n        actionProps: {\r\n          children: jsxOptions.action.label,\r\n          onClick: jsxOptions.action.onClick,\r\n        },\r\n      }),\r\n      data: {\r\n        customJSX: optionsOrJSX,\r\n        ...(jsxOptions?.data && jsxOptions.data),\r\n        showCloseButton: jsxOptions?.showCloseButton ?? true,\r\n      },\r\n      ...(jsxOptions?.onClose && { onClose: jsxOptions.onClose }),\r\n      ...(jsxOptions?.onRemove && { onRemove: jsxOptions.onRemove }),\r\n    });\r\n  }\r\n\r\n  // Handle options object\r\n  const options = optionsOrJSX as ToastOptions<TData>;\r\n  return toastManager.add({\r\n    title: options.title,\r\n    description: options.description || \"\",\r\n    type: options.type || \"default\",\r\n    timeout: options.duration || undefined,\r\n    priority: options.priority || \"low\",\r\n    ...(options.action && {\r\n      actionProps: {\r\n        children: options.action.label,\r\n        onClick: options.action.onClick,\r\n      },\r\n    }),\r\n    data: {\r\n      ...(options.data || {}),\r\n      showCloseButton: options.showCloseButton ?? true,\r\n    },\r\n    ...(options.onClose && { onClose: options.onClose }),\r\n    ...(options.onRemove && { onRemove: options.onRemove }),\r\n  });\r\n}\r\n\r\n/** Message format for promise toasts - can be a string or an object with title/description */\r\ntype PromiseMessage = string | { title?: string; description?: string };\r\n\r\n/** Promise message that can also be a function returning the message */\r\ntype PromiseMessageOrFn<T> = PromiseMessage | ((data: T) => PromiseMessage);\r\n\r\nconst promise = async <T,>(\r\n  promiseToResolve: Promise<T>,\r\n  messages: {\r\n    loading: PromiseMessage;\r\n    success: PromiseMessageOrFn<T>;\r\n    error: PromiseMessageOrFn<Error>;\r\n  },\r\n) => {\r\n  const resolveMessage = <U,>(msg: PromiseMessageOrFn<U>, data: U) =>\r\n    typeof msg === \"function\" ? msg(data) : msg;\r\n\r\n  return toastManager.promise(promiseToResolve, {\r\n    loading: messages.loading,\r\n    success: (data: T) => resolveMessage(messages.success, data),\r\n    error: (err: Error) => resolveMessage(messages.error, err),\r\n  });\r\n};\r\n\r\n// Factory function to create typed toast methods (DRY)\r\nfunction createTypedToast(type: NonNullable<ToastOptions[\"type\"]>) {\r\n  return <TData extends object = object>(\r\n    optionsOrJSX: Omit<ToastOptions<TData>, \"type\"> | React.ReactElement,\r\n    jsxOptions?: Omit<ToastOptions<TData>, \"title\" | \"description\" | \"type\">,\r\n  ) => {\r\n    if (React.isValidElement(optionsOrJSX)) {\r\n      return baseToast(optionsOrJSX, { ...jsxOptions, type });\r\n    }\r\n    return baseToast({ ...optionsOrJSX, type });\r\n  };\r\n}\r\n\r\n// Create the toast object with methods like Sonner\r\nexport const toast = Object.assign(baseToast, {\r\n  success: createTypedToast(\"success\"),\r\n  error: createTypedToast(\"error\"),\r\n  warning: createTypedToast(\"warning\"),\r\n  info: createTypedToast(\"info\"),\r\n  promise,\r\n  dismiss: (toastId: string) => {\r\n    return toastManager.close(toastId);\r\n  },\r\n  update: (toastId: string, options: Partial<ToastOptions>) => {\r\n    const updateOptions: Record<string, unknown> = {};\r\n    if (options.title !== undefined) updateOptions.title = options.title;\r\n    if (options.description !== undefined)\r\n      updateOptions.description = options.description;\r\n    if (options.type !== undefined) updateOptions.type = options.type;\r\n    if (options.data !== undefined) updateOptions.data = options.data;\r\n\r\n    return toastManager.update(toastId, updateOptions);\r\n  },\r\n  custom: <TData extends object = object>(options: ToastOptions<TData>) =>\r\n    baseToast(options),\r\n  /** Show an anchored toast near an element */\r\n  anchored: <TData extends object = object>(\r\n    options: AnchoredToastOptions<TData>,\r\n  ) => {\r\n    const anchor =\r\n      options.anchor instanceof Element\r\n        ? options.anchor\r\n        : options.anchor?.current;\r\n\r\n    if (!anchor) {\r\n      console.warn(\"Toast anchor element not found\");\r\n      return;\r\n    }\r\n\r\n    return anchoredToastManager.add({\r\n      title: options.title,\r\n      description: options.description || \"\",\r\n      timeout: options.duration || undefined,\r\n      priority: options.priority || \"low\",\r\n      ...(options.action && {\r\n        actionProps: {\r\n          children: options.action.label,\r\n          onClick: options.action.onClick,\r\n        },\r\n      }),\r\n      data: {\r\n        ...(options.data || {}),\r\n        arrow: options.arrow ?? false,\r\n      },\r\n      positionerProps: {\r\n        anchor,\r\n        side: options.side ?? \"top\",\r\n        sideOffset: options.sideOffset ?? 8,\r\n        align: options.align,\r\n        alignOffset: options.alignOffset,\r\n      },\r\n      ...(options.onClose && { onClose: options.onClose }),\r\n      ...(options.onRemove && { onRemove: options.onRemove }),\r\n    });\r\n  },\r\n  /** Dismiss an anchored toast */\r\n  dismissAnchored: (toastId: string) => {\r\n    return anchoredToastManager.close(toastId);\r\n  },\r\n  /** Show a grouped toast that collapses multiple items into a summary */\r\n  grouped: <TData extends object = object>(\r\n    options: GroupedToastOptions<TData>,\r\n  ) => {\r\n    const existingToastId = groupToToastMap.get(options.groupId);\r\n    const itemId = `grouped-${options.groupId}-${Date.now()}-${Math.random().toString(36).slice(2, 9)}`;\r\n\r\n    const isLoading = options.type === \"loading\";\r\n\r\n    const newItem: GroupedToastItem = {\r\n      id: itemId,\r\n      title: options.title,\r\n      description: options.description,\r\n      type: options.type,\r\n      action: options.action,\r\n      data: options.data,\r\n      createdAt: Date.now(),\r\n      showCloseButton: options.showCloseButton ?? true,\r\n      // For loading items, duration controls progress bar time after success\r\n      duration: isLoading ? options.duration : undefined,\r\n    };\r\n\r\n    if (existingToastId) {\r\n      // Add to existing group - all new items go to `items` array\r\n      const existingData = groupDataMap.get(options.groupId);\r\n      if (existingData) {\r\n        // Increment historical counts for non-loading items immediately\r\n        const updatedHistoricalCounts = { ...existingData.historicalCounts };\r\n        if (\r\n          newItem.type === \"success\" ||\r\n          newItem.type === \"error\" ||\r\n          newItem.type === \"warning\" ||\r\n          newItem.type === \"info\"\r\n        ) {\r\n          updatedHistoricalCounts[newItem.type]++;\r\n        }\r\n        const updatedData: GroupedToastData = {\r\n          ...existingData,\r\n          items: [...existingData.items, newItem],\r\n          historicalCounts: updatedHistoricalCounts,\r\n        };\r\n        groupDataMap.set(options.groupId, updatedData);\r\n        // Pass timeout to reset Base UI's built-in timer (pauses on hover/drag)\r\n        toastManager.update(existingToastId, {\r\n          data: updatedData,\r\n          timeout: existingData.duration ?? 0,\r\n        });\r\n      }\r\n    } else {\r\n      // Create new group\r\n      const groupId = options.groupId;\r\n      const groupData: GroupedToastData = {\r\n        isGrouped: true,\r\n        groupId,\r\n        items: [newItem],\r\n        completedItems: [],\r\n        isExpanded: false,\r\n        summary: options.groupSummary,\r\n        action: {\r\n          label: options.groupAction?.label ?? \"Show\",\r\n          expandedLabel: options.groupAction?.expandedLabel ?? \"Hide\",\r\n        },\r\n        hasShownAllComplete: false,\r\n        // For non-loading items, duration controls group auto-dismiss\r\n        // For loading items, duration is stored on the item for progress bar\r\n        duration: isLoading ? undefined : options.duration,\r\n        historicalCounts: {\r\n          success: newItem.type === \"success\" ? 1 : 0,\r\n          error: newItem.type === \"error\" ? 1 : 0,\r\n          warning: newItem.type === \"warning\" ? 1 : 0,\r\n          info: newItem.type === \"info\" ? 1 : 0,\r\n        },\r\n      };\r\n      const toastId = toastManager.add({\r\n        title: \"\",\r\n        description: \"\",\r\n        data: groupData,\r\n        // Use Base UI's built-in timeout for auto-dismiss (only for non-loading items)\r\n        // Loading items don't auto-dismiss the group - they wait for updateGroupItem()\r\n        timeout: isLoading ? 0 : (options.duration ?? 0),\r\n        // Clean up our maps when the toast is closed (via close button or swipe)\r\n        onClose: () => {\r\n          const data = groupDataMap.get(groupId);\r\n          if (data) {\r\n            data.items.forEach((item) => groupItemToGroupMap.delete(item.id));\r\n            (data.completedItems ?? []).forEach((item) =>\r\n              groupItemToGroupMap.delete(item.id),\r\n            );\r\n          }\r\n          groupToToastMap.delete(groupId);\r\n          groupDataMap.delete(groupId);\r\n        },\r\n      });\r\n      if (toastId) {\r\n        groupToToastMap.set(groupId, toastId);\r\n        groupDataMap.set(groupId, groupData);\r\n      }\r\n    }\r\n\r\n    groupItemToGroupMap.set(itemId, options.groupId);\r\n\r\n    return itemId;\r\n  },\r\n  /** Dismiss a single item from a grouped toast (checks both pending and completed arrays) */\r\n  dismissGroupItem: (itemId: string) => {\r\n    const groupId = groupItemToGroupMap.get(itemId);\r\n    if (!groupId) return;\r\n\r\n    const toastId = groupToToastMap.get(groupId);\r\n    if (!toastId) return;\r\n\r\n    const data = groupDataMap.get(groupId);\r\n    if (!data) return;\r\n\r\n    // Check both arrays\r\n    const inPending = data.items.some((item) => item.id === itemId);\r\n    const inCompleted = (data.completedItems ?? []).some(\r\n      (item) => item.id === itemId,\r\n    );\r\n\r\n    let newItems = data.items;\r\n    let newCompletedItems = data.completedItems ?? [];\r\n\r\n    if (inPending) {\r\n      newItems = data.items.filter((item) => item.id !== itemId);\r\n    }\r\n    if (inCompleted) {\r\n      newCompletedItems = newCompletedItems.filter(\r\n        (item) => item.id !== itemId,\r\n      );\r\n    }\r\n\r\n    groupItemToGroupMap.delete(itemId);\r\n\r\n    if (newItems.length === 0 && newCompletedItems.length === 0) {\r\n      // Last item - close the toast entirely\r\n      toastManager.close(toastId);\r\n      groupToToastMap.delete(groupId);\r\n      groupDataMap.delete(groupId);\r\n    } else {\r\n      // Update toast with remaining items\r\n      const updatedData: GroupedToastData = {\r\n        ...data,\r\n        items: newItems,\r\n        completedItems: newCompletedItems,\r\n        // Collapse if only 1 pending item remains and no completed\r\n        isExpanded:\r\n          newItems.length <= 1 && newCompletedItems.length === 0\r\n            ? false\r\n            : data.isExpanded,\r\n      };\r\n      groupDataMap.set(groupId, updatedData);\r\n      toastManager.update(toastId, { data: updatedData });\r\n    }\r\n  },\r\n  /** Dismiss an entire group of toasts */\r\n  dismissGroup: (groupId: string) => {\r\n    const toastId = groupToToastMap.get(groupId);\r\n    if (!toastId) return;\r\n\r\n    // Clean up item mappings for both arrays\r\n    const data = groupDataMap.get(groupId);\r\n    if (data) {\r\n      data.items.forEach((item) => groupItemToGroupMap.delete(item.id));\r\n      (data.completedItems ?? []).forEach((item) =>\r\n        groupItemToGroupMap.delete(item.id),\r\n      );\r\n    }\r\n\r\n    toastManager.close(toastId);\r\n    groupToToastMap.delete(groupId);\r\n    groupDataMap.delete(groupId);\r\n  },\r\n  /** Update a single item in a grouped toast */\r\n  updateGroupItem: (\r\n    itemId: string,\r\n    options: Partial<Omit<GroupedToastItem, \"id\" | \"createdAt\">>,\r\n  ) => {\r\n    const groupId = groupItemToGroupMap.get(itemId);\r\n    if (!groupId) return;\r\n\r\n    const toastId = groupToToastMap.get(groupId);\r\n    if (!toastId) return;\r\n\r\n    const data = groupDataMap.get(groupId);\r\n    if (!data) return;\r\n\r\n    // Find the current item to check if type is changing from loading\r\n    const currentItem = data.items.find((item) => item.id === itemId);\r\n    const wasLoading = currentItem?.type === \"loading\";\r\n    const isNowComplete =\r\n      options.type !== undefined && options.type !== \"loading\";\r\n\r\n    if (wasLoading && isNowComplete && currentItem) {\r\n      // Move item from pending to completed\r\n      const newItems = data.items.filter((item) => item.id !== itemId);\r\n      const completedItem: GroupedToastItem = {\r\n        ...currentItem,\r\n        ...options,\r\n        completedAt: Date.now(),\r\n      };\r\n\r\n      // Insert at beginning (newest on top)\r\n      const newCompletedItems = [completedItem, ...(data.completedItems ?? [])];\r\n\r\n      // Check if we have 2+ complete items (triggers \"All complete\" summary)\r\n      const completeCount = newCompletedItems.length;\r\n      const shouldShowAllComplete = completeCount >= 2;\r\n\r\n      // Increment historical counts (these persist even after items are dismissed)\r\n      const completedType = completedItem.type as ToastType;\r\n      const newHistoricalCounts = { ...data.historicalCounts };\r\n      if (completedType === \"success\") newHistoricalCounts.success++;\r\n      else if (completedType === \"error\") newHistoricalCounts.error++;\r\n      else if (completedType === \"warning\") newHistoricalCounts.warning++;\r\n      else if (completedType === \"info\") newHistoricalCounts.info++;\r\n      // \"default\" is the unstyled/neutral variant - count as success\r\n      else if (completedType === \"default\") newHistoricalCounts.success++;\r\n\r\n      const updatedData: GroupedToastData = {\r\n        ...data,\r\n        items: newItems,\r\n        completedItems: newCompletedItems,\r\n        hasShownAllComplete: data.hasShownAllComplete || shouldShowAllComplete,\r\n        historicalCounts: newHistoricalCounts,\r\n      };\r\n      groupDataMap.set(groupId, updatedData);\r\n      toastManager.update(toastId, { data: updatedData });\r\n\r\n      // Start dismiss timer for the completed item (use item's duration or default)\r\n      const dismissDuration =\r\n        currentItem.duration ?? GROUP_ITEM_DISMISS_DURATION;\r\n      setTimeout(() => {\r\n        toast.dismissCompletedItem(itemId);\r\n      }, dismissDuration);\r\n    } else {\r\n      // Just update in place (not a loading->complete transition)\r\n      const newItems = data.items.map((item) =>\r\n        item.id === itemId ? { ...item, ...options } : item,\r\n      );\r\n\r\n      const updatedData: GroupedToastData = {\r\n        ...data,\r\n        items: newItems,\r\n      };\r\n      groupDataMap.set(groupId, updatedData);\r\n      toastManager.update(toastId, { data: updatedData });\r\n    }\r\n  },\r\n  /** Dismiss a completed item (removes from completedItems array) */\r\n  dismissCompletedItem: (itemId: string) => {\r\n    const groupId = groupItemToGroupMap.get(itemId);\r\n    if (!groupId) return;\r\n\r\n    const toastId = groupToToastMap.get(groupId);\r\n    if (!toastId) return;\r\n\r\n    const data = groupDataMap.get(groupId);\r\n    if (!data) return;\r\n\r\n    const newCompletedItems = (data.completedItems ?? []).filter(\r\n      (item) => item.id !== itemId,\r\n    );\r\n    groupItemToGroupMap.delete(itemId);\r\n\r\n    // Check if entire group should close\r\n    if (data.items.length === 0 && newCompletedItems.length === 0) {\r\n      toastManager.close(toastId);\r\n      groupToToastMap.delete(groupId);\r\n      groupDataMap.delete(groupId);\r\n      return;\r\n    }\r\n\r\n    const updatedData: GroupedToastData = {\r\n      ...data,\r\n      completedItems: newCompletedItems,\r\n      // Collapse if only 1 pending item remains and no completed (unless in group mode)\r\n      isExpanded:\r\n        data.items.length <= 1 &&\r\n        newCompletedItems.length === 0 &&\r\n        !data.hasShownAllComplete\r\n          ? false\r\n          : data.isExpanded,\r\n    };\r\n    groupDataMap.set(groupId, updatedData);\r\n    toastManager.update(toastId, { data: updatedData });\r\n  },\r\n  /** Show a grouped toast that resolves with a promise, handling loading/success/error states */\r\n  groupedPromise: async <T,>(\r\n    promiseToResolve: Promise<T>,\r\n    messages: GroupedPromiseMessages<T>,\r\n    options: GroupedPromiseOptions,\r\n  ): Promise<T> => {\r\n    // Helper to resolve message to GroupedPromiseMessage format\r\n    const resolveMessage = <U,>(\r\n      msg: PromiseMessage | ((data: U) => GroupedPromiseMessage),\r\n      data: U,\r\n    ): GroupedPromiseMessage => {\r\n      if (typeof msg === \"function\") {\r\n        return msg(data);\r\n      }\r\n      if (typeof msg === \"string\") {\r\n        return { title: msg };\r\n      }\r\n      return msg;\r\n    };\r\n\r\n    // Create loading item\r\n    const itemId = toast.grouped({\r\n      ...options,\r\n      title: messages.loading.title,\r\n      description: messages.loading.description,\r\n      type: \"loading\",\r\n      action: messages.loading.action,\r\n    });\r\n\r\n    if (!itemId) {\r\n      return promiseToResolve;\r\n    }\r\n\r\n    // Track if already handled and whether it was an abort\r\n    let handled = false;\r\n    let wasAborted = false;\r\n\r\n    // Set up abort listener if signal provided\r\n    if (options.signal) {\r\n      const handleAbort = () => {\r\n        if (handled) return;\r\n        handled = true;\r\n        wasAborted = true;\r\n\r\n        const abortedMsg: GroupedPromiseMessage = messages.aborted\r\n          ? typeof messages.aborted === \"function\"\r\n            ? messages.aborted()\r\n            : typeof messages.aborted === \"string\"\r\n              ? { title: messages.aborted }\r\n              : messages.aborted\r\n          : { title: \"Cancelled\" };\r\n\r\n        toast.updateGroupItem(itemId, {\r\n          title: abortedMsg.title,\r\n          description: abortedMsg.description,\r\n          type: abortedMsg.type ?? \"error\",\r\n          action: undefined,\r\n        });\r\n      };\r\n\r\n      if (options.signal.aborted) {\r\n        handleAbort();\r\n        throw new DOMException(\"Aborted\", \"AbortError\");\r\n      }\r\n\r\n      options.signal.addEventListener(\"abort\", handleAbort, { once: true });\r\n    }\r\n\r\n    try {\r\n      const result = await promiseToResolve;\r\n\r\n      if (!handled) {\r\n        handled = true;\r\n        const successMsg = resolveMessage(messages.success, result);\r\n        toast.updateGroupItem(itemId, {\r\n          title: successMsg.title,\r\n          description: successMsg.description,\r\n          type: successMsg.type ?? \"success\",\r\n          action: undefined,\r\n        });\r\n      }\r\n\r\n      return result;\r\n    } catch (error) {\r\n      if (!handled) {\r\n        handled = true;\r\n        const errorMsg = resolveMessage(\r\n          messages.error,\r\n          error instanceof Error ? error : new Error(String(error)),\r\n        );\r\n        toast.updateGroupItem(itemId, {\r\n          title: errorMsg.title,\r\n          description: errorMsg.description,\r\n          type: errorMsg.type ?? \"error\",\r\n          action: undefined,\r\n        });\r\n      }\r\n\r\n      // Throw AbortError for user-initiated abort (matches fetch() behavior)\r\n      // Callers can catch and check: error.name === 'AbortError'\r\n      if (wasAborted) {\r\n        throw new DOMException(\"Aborted\", \"AbortError\");\r\n      }\r\n\r\n      throw error;\r\n    }\r\n  },\r\n});\r\n\r\n// Toast Provider\r\nexport type ToastPosition =\r\n  | \"top-left\"\r\n  | \"top-center\"\r\n  | \"top-right\"\r\n  | \"bottom-left\"\r\n  | \"bottom-center\"\r\n  | \"bottom-right\";\r\n\r\ninterface ToastProviderProps {\r\n  children: React.ReactNode;\r\n  position?: ToastPosition;\r\n  limit?: number;\r\n  timeout?: number;\r\n  container?: HTMLElement | React.RefObject<HTMLElement | null> | null;\r\n}\r\n\r\nexport function ToastProvider({\r\n  children,\r\n  position = \"bottom-right\",\r\n  limit = 3,\r\n  timeout = 5000,\r\n  container,\r\n}: ToastProviderProps) {\r\n  return (\r\n    <Toast.Provider limit={limit} timeout={timeout} toastManager={toastManager}>\r\n      {children}\r\n      <Toast.Portal container={container}>\r\n        <Toast.Viewport\r\n          data-slot=\"toast-viewport\"\r\n          data-position={position}\r\n          className={cn(\r\n            \"fixed z-50 flex w-[calc(100%-var(--toast-inset)*2)] max-w-[360px]\",\r\n            \"[--toast-inset:1rem] sm:[--toast-inset:2rem]\",\r\n            // Vertical positioning\r\n            \"data-[position*=top]:top-(--toast-inset)\",\r\n            \"data-[position*=bottom]:bottom-(--toast-inset)\",\r\n            // Horizontal positioning\r\n            \"data-[position*=left]:left-(--toast-inset)\",\r\n            \"data-[position*=right]:right-(--toast-inset)\",\r\n            \"data-[position*=center]:left-1/2 data-[position*=center]:-translate-x-1/2\",\r\n          )}\r\n        >\r\n          <StackedToasts position={position} />\r\n        </Toast.Viewport>\r\n      </Toast.Portal>\r\n    </Toast.Provider>\r\n  );\r\n}\r\n\r\nfunction StackedToasts({ position }: { position: ToastPosition }) {\r\n  const { toasts } = Toast.useToastManager();\r\n  const isTop = position.startsWith(\"top\");\r\n\r\n  return (\r\n    <>\r\n      {toasts.map((toast) => (\r\n        <StackedToastItem\r\n          key={toast.id}\r\n          toast={toast as ToastData}\r\n          position={position}\r\n          swipeDirection={\r\n            position.includes(\"center\")\r\n              ? [isTop ? \"up\" : \"down\"]\r\n              : position.includes(\"left\")\r\n                ? [\"left\", isTop ? \"up\" : \"down\"]\r\n                : [\"right\", isTop ? \"up\" : \"down\"]\r\n          }\r\n        />\r\n      ))}\r\n    </>\r\n  );\r\n}\r\n\r\ninterface StackedToastItemProps {\r\n  toast: ToastData;\r\n  position: ToastPosition;\r\n  swipeDirection:\r\n    | (\"up\" | \"down\" | \"left\" | \"right\")\r\n    | (\"up\" | \"down\" | \"left\" | \"right\")[];\r\n}\r\n\r\nfunction StackedToastItem({\r\n  toast,\r\n  position,\r\n  swipeDirection,\r\n}: StackedToastItemProps) {\r\n  // Check if this is a grouped toast\r\n  const isGrouped =\r\n    toast.data &&\r\n    typeof toast.data === \"object\" &&\r\n    \"isGrouped\" in toast.data &&\r\n    (toast.data as GroupedToastData).isGrouped === true;\r\n\r\n  // For grouped toasts, render with GroupedToastContent\r\n  if (isGrouped) {\r\n    return (\r\n      <GroupedToastRoot\r\n        toast={toast}\r\n        position={position}\r\n        swipeDirection={swipeDirection}\r\n        data={toast.data as GroupedToastData}\r\n      />\r\n    );\r\n  }\r\n\r\n  const type = toast.type || \"default\";\r\n\r\n  // Check if this is a custom JSX toast\r\n  const hasCustomJSX =\r\n    toast.data && typeof toast.data === \"object\" && \"customJSX\" in toast.data;\r\n\r\n  // Check if close button should be shown (defaults to true)\r\n  const showCloseButton =\r\n    toast.data &&\r\n    typeof toast.data === \"object\" &&\r\n    \"showCloseButton\" in toast.data &&\r\n    (toast.data as Record<string, unknown>).showCloseButton === false\r\n      ? false\r\n      : true;\r\n\r\n  const Icon =\r\n    type !== \"default\" ? TOAST_ICONS[type as keyof typeof TOAST_ICONS] : null;\r\n\r\n  return (\r\n    <Toast.Root\r\n      toast={toast}\r\n      swipeDirection={swipeDirection}\r\n      data-slot=\"toast\"\r\n      data-position={position}\r\n      className={cn(\r\n        TOAST_CSS_VARIABLES,\r\n        TOAST_POSITION_CLASSES,\r\n        TOAST_TRANSFORM_CLASSES,\r\n        TOAST_ANIMATION_CLASSES,\r\n        TOAST_VISUAL_CLASSES,\r\n      )}\r\n    >\r\n      <Toast.Content\r\n        data-slot=\"toast-content\"\r\n        className={cn(\r\n          \"flex gap-3 overflow-hidden px-3.5 py-3 text-sm\",\r\n          showCloseButton ? \"items-start\" : \"items-center\",\r\n          \"transition-opacity duration-250\",\r\n          \"data-behind:pointer-events-none data-behind:opacity-0\",\r\n          \"data-expanded:pointer-events-auto data-expanded:opacity-100\",\r\n        )}\r\n      >\r\n        {hasCustomJSX ? (\r\n          <div className=\"w-full\">\r\n            {(toast.data as Record<string, React.ReactNode>).customJSX}\r\n          </div>\r\n        ) : (\r\n          <>\r\n            {Icon && (\r\n              <div\r\n                data-slot=\"toast-icon\"\r\n                className={cn(\r\n                  \"[&>svg]:size-4 [&>svg]:shrink-0\",\r\n                  showCloseButton && \"mt-0.5\",\r\n                )}\r\n              >\r\n                <HugeiconsIcon\r\n                  icon={Icon}\r\n                  strokeWidth={2}\r\n                  className={cn(\r\n                    \"in-data-[type=success]:text-success-foreground\",\r\n                    \"in-data-[type=error]:text-danger-foreground\",\r\n                    \"in-data-[type=warning]:text-warning-foreground\",\r\n                    \"in-data-[type=info]:text-info-foreground\",\r\n                    \"in-data-[type=loading]:text-muted-foreground in-data-[type=loading]:animate-spin\",\r\n                  )}\r\n                />\r\n              </div>\r\n            )}\r\n            <div className=\"flex min-w-0 flex-1 flex-col gap-0.5\">\r\n              <Toast.Title\r\n                data-slot=\"toast-title\"\r\n                className=\"text-sm leading-5 font-medium\"\r\n              />\r\n              <Toast.Description\r\n                data-slot=\"toast-description\"\r\n                className=\"text-muted-foreground text-sm leading-5\"\r\n              />\r\n              {showCloseButton && (\r\n                <Toast.Action\r\n                  data-slot=\"toast-action\"\r\n                  className={cn(\r\n                    buttonVariants({ variant: \"outline\", size: \"xs\" }),\r\n                    \"mt-1.5 w-fit\",\r\n                  )}\r\n                />\r\n              )}\r\n            </div>\r\n            {!showCloseButton && (\r\n              <Toast.Action\r\n                data-slot=\"toast-action\"\r\n                className={buttonVariants({ variant: \"outline\", size: \"xs\" })}\r\n              />\r\n            )}\r\n            {showCloseButton && (\r\n              <Toast.Close\r\n                data-slot=\"toast-close\"\r\n                className=\"text-muted-foreground hover:bg-accent/50 hover:text-foreground -mt-1 -mr-1 flex size-6 shrink-0 items-center justify-center rounded-md border-none bg-transparent transition-colors duration-200\"\r\n                aria-label=\"Close\"\r\n              >\r\n                <HugeiconsIcon\r\n                  icon={Cancel01Icon}\r\n                  strokeWidth={2}\r\n                  className=\"size-4\"\r\n                />\r\n              </Toast.Close>\r\n            )}\r\n          </>\r\n        )}\r\n      </Toast.Content>\r\n    </Toast.Root>\r\n  );\r\n}\r\n\r\n// Anchored Toast Provider\r\ninterface AnchoredToastProviderProps {\r\n  children: React.ReactNode;\r\n  limit?: number;\r\n  timeout?: number;\r\n  container?: HTMLElement | React.RefObject<HTMLElement | null> | null;\r\n}\r\n\r\nexport function AnchoredToastProvider({\r\n  children,\r\n  limit = 5,\r\n  timeout = 2000,\r\n  container,\r\n}: AnchoredToastProviderProps) {\r\n  return (\r\n    <Toast.Provider\r\n      limit={limit}\r\n      timeout={timeout}\r\n      toastManager={anchoredToastManager}\r\n    >\r\n      {children}\r\n      <Toast.Portal container={container}>\r\n        <Toast.Viewport data-slot=\"toast-viewport\" className=\"outline-none\">\r\n          <AnchoredToasts />\r\n        </Toast.Viewport>\r\n      </Toast.Portal>\r\n    </Toast.Provider>\r\n  );\r\n}\r\n\r\nfunction AnchoredToasts() {\r\n  const { toasts } = Toast.useToastManager();\r\n\r\n  return (\r\n    <>\r\n      {toasts.map((toast) => {\r\n        const toastData = toast as ToastData;\r\n        if (!toastData.positionerProps?.anchor) {\r\n          return null;\r\n        }\r\n        return <AnchoredToastItem key={toast.id} toast={toastData} />;\r\n      })}\r\n    </>\r\n  );\r\n}\r\n\r\nfunction AnchoredToastItem({ toast }: { toast: ToastData }) {\r\n  const showArrow = Boolean(\r\n    toast.data &&\r\n    typeof toast.data === \"object\" &&\r\n    \"arrow\" in toast.data &&\r\n    (toast.data as Record<string, unknown>).arrow === true,\r\n  );\r\n\r\n  return (\r\n    <Toast.Positioner\r\n      toast={toast}\r\n      data-slot=\"toast-positioner\"\r\n      className=\"z-[calc(1000-var(--toast-index))]\"\r\n    >\r\n      <Toast.Root\r\n        toast={toast}\r\n        data-slot=\"toast\"\r\n        className={cn(\r\n          \"flex w-max origin-(--transform-origin) flex-col rounded-md\",\r\n          \"ring-border bg-card text-card-foreground ring-1\",\r\n          \"px-3 py-2 text-sm shadow-lg/4\",\r\n          \"transition-all duration-200\",\r\n          \"data-starting-style:scale-95 data-starting-style:opacity-0\",\r\n          \"data-ending-style:scale-95 data-ending-style:opacity-0\",\r\n        )}\r\n      >\r\n        {showArrow && (\r\n          <Toast.Arrow\r\n            data-slot=\"toast-arrow\"\r\n            className=\"fill-card [&>path:first-child]:fill-card [&>path:not(:first-child)]:stroke-border\"\r\n          />\r\n        )}\r\n        <Toast.Content data-slot=\"toast-content\">\r\n          <Toast.Title\r\n            data-slot=\"toast-title\"\r\n            className=\"text-sm font-medium\"\r\n          />\r\n          <Toast.Description\r\n            data-slot=\"toast-description\"\r\n            className=\"text-muted-foreground text-sm\"\r\n          />\r\n        </Toast.Content>\r\n      </Toast.Root>\r\n    </Toast.Positioner>\r\n  );\r\n}\r\n\r\n// Grouped Toast Components\r\n\r\n// Feature detection for calc-size() support (Chrome 129+, Edge 129+)\r\n// Used to conditionally render different DOM structures for height animation\r\nconst supportsCalcSize =\r\n  typeof CSS !== \"undefined\" && CSS.supports(\"height\", \"calc-size(auto, size)\");\r\n\r\ninterface GroupedToastRootProps {\r\n  toast: ToastData;\r\n  position: ToastPosition;\r\n  swipeDirection:\r\n    | (\"up\" | \"down\" | \"left\" | \"right\")\r\n    | (\"up\" | \"down\" | \"left\" | \"right\")[];\r\n  data: GroupedToastData;\r\n}\r\n\r\n/** Helper to toggle expand/collapse for a grouped toast */\r\nfunction toggleGroupExpanded(toastId: string) {\r\n  // Find the groupId from toastId\r\n  let groupId: string | undefined;\r\n  for (const [gId, tId] of groupToToastMap.entries()) {\r\n    if (tId === toastId) {\r\n      groupId = gId;\r\n      break;\r\n    }\r\n  }\r\n  if (!groupId) return;\r\n\r\n  const data = groupDataMap.get(groupId);\r\n  if (!data) return;\r\n\r\n  const updatedData: GroupedToastData = {\r\n    ...data,\r\n    isExpanded: !data.isExpanded,\r\n  };\r\n  groupDataMap.set(groupId, updatedData);\r\n  toastManager.update(toastId, { data: updatedData });\r\n}\r\n\r\nfunction GroupedToastRoot({\r\n  toast,\r\n  position,\r\n  swipeDirection,\r\n  data,\r\n}: GroupedToastRootProps) {\r\n  const toastRootRef = React.useRef<HTMLDivElement>(null);\r\n  const isTop = position.startsWith(\"top\");\r\n\r\n  // Sync popover open state with toast data\r\n  const handlePopoverOpenChange = React.useCallback(\r\n    (open: boolean, eventDetails: Popover.Root.ChangeEventDetails) => {\r\n      // Block all close reasons except escape key (accessibility pattern)\r\n      // State is managed via explicit Show/Hide button toggle\r\n      if (!open && eventDetails.reason !== \"escape-key\") {\r\n        eventDetails.cancel();\r\n        return;\r\n      }\r\n      if (open !== data.isExpanded) {\r\n        toggleGroupExpanded(toast.id);\r\n      }\r\n    },\r\n    [toast.id, data.isExpanded],\r\n  );\r\n\r\n  return (\r\n    <Toast.Root\r\n      ref={toastRootRef}\r\n      toast={toast}\r\n      swipeDirection={swipeDirection}\r\n      data-slot=\"toast\"\r\n      data-position={position}\r\n      className={cn(\r\n        TOAST_CSS_VARIABLES,\r\n        TOAST_POSITION_CLASSES,\r\n        TOAST_TRANSFORM_CLASSES,\r\n        TOAST_ANIMATION_CLASSES,\r\n        TOAST_VISUAL_CLASSES,\r\n        \"overflow-visible\", // Additional class for grouped toasts (popover needs to overflow)\r\n      )}\r\n    >\r\n      <Toast.Content\r\n        data-slot=\"toast-content\"\r\n        className={cn(\r\n          \"text-sm\",\r\n          \"transition-[opacity,height] duration-300\",\r\n          \"data-behind:pointer-events-none data-behind:opacity-0\",\r\n          \"data-expanded:pointer-events-auto data-expanded:opacity-100\",\r\n        )}\r\n      >\r\n        <GroupedToastSummaryOrSingle data={data} toastId={toast.id} />\r\n      </Toast.Content>\r\n      {/* Expanded cards popover - uses CSS positioning to maintain stable layout */}\r\n      <Popover.Root\r\n        open={data.isExpanded}\r\n        onOpenChange={handlePopoverOpenChange}\r\n      >\r\n        <Popover.Portal container={toastRootRef}>\r\n          <Popover.Positioner\r\n            anchor={toastRootRef}\r\n            side={isTop ? \"bottom\" : \"top\"}\r\n            align=\"start\"\r\n            sideOffset={8}\r\n          >\r\n            <Popover.Popup\r\n              data-slot=\"expanded-cards-popup\"\r\n              className={cn(\r\n                \"absolute w-(--anchor-width)\",\r\n                // Override transform origin (align=\"start\" sets it to left edge)\r\n                isTop\r\n                  ? \"top-full mt-2 origin-top\"\r\n                  : \"bottom-full mb-2 origin-bottom\",\r\n                // Only transition opacity and scale for enter/exit\r\n                \"ease-out-cubic transition-[opacity,scale] duration-200\",\r\n                \"data-starting-style:scale-95 data-starting-style:opacity-0\",\r\n                \"data-ending-style:scale-95 data-ending-style:opacity-0\",\r\n              )}\r\n            >\r\n              <ExpandedCardsContainer data={data} isTop={isTop} />\r\n            </Popover.Popup>\r\n          </Popover.Positioner>\r\n        </Popover.Portal>\r\n      </Popover.Root>\r\n    </Toast.Root>\r\n  );\r\n}\r\n\r\ninterface GroupedToastSummaryOrSingleProps {\r\n  data: GroupedToastData;\r\n  toastId: string;\r\n}\r\n\r\nfunction GroupedToastSummaryOrSingle({\r\n  data,\r\n  toastId,\r\n}: GroupedToastSummaryOrSingleProps) {\r\n  // Total items across both arrays\r\n  const totalPending = data.items.length;\r\n  const totalCompleted = (data.completedItems ?? []).length;\r\n  const totalItems = totalPending + totalCompleted;\r\n\r\n  // Show single-item view when there's exactly 1 total item (pending OR completed)\r\n  // and we haven't shown \"All complete\" mode yet\r\n  const isSingle = totalItems === 1 && !data.hasShownAllComplete;\r\n\r\n  // Get the single item to display (prefer pending, fallback to completed)\r\n  const singleItem = data.items[0] ?? data.completedItems?.[0];\r\n\r\n  // Modern browsers (Chrome 129+): single element with key switching\r\n  // Height animates from CSS var to calc-size(auto, size)\r\n  if (supportsCalcSize) {\r\n    return (\r\n      <div\r\n        key={isSingle ? \"single\" : \"summary\"}\r\n        className={cn(\r\n          \"ease-out-cubic duration-200\",\r\n          \"transition-[height,opacity,filter,scale]\",\r\n          \"overflow-clip\",\r\n          // Height: start from CSS var, animate to intrinsic size\r\n          \"h-[calc-size(auto,size)]\",\r\n          \"starting:h-(--toast-calc-height)\",\r\n          // Opacity/blur/scale entry animation\r\n\r\n          \"starting:scale-95 starting:opacity-0 starting:blur-[2px]\",\r\n          \"blur-0 scale-100 opacity-100\",\r\n        )}\r\n      >\r\n        {isSingle && singleItem ? (\r\n          <GroupedSingleItemContent\r\n            item={singleItem}\r\n            showCloseButton={singleItem.showCloseButton}\r\n          />\r\n        ) : (\r\n          <GroupedToastSummaryContent\r\n            data={data}\r\n            onToggle={() => toggleGroupExpanded(toastId)}\r\n          />\r\n        )}\r\n      </div>\r\n    );\r\n  }\r\n\r\n  // Fallback (Firefox/Safari): two elements with grid-based height animation\r\n  return (\r\n    <>\r\n      {/* Single item view */}\r\n      <div\r\n        className={cn(\r\n          \"ease-out-cubic grid duration-200\",\r\n          \"transition-[grid-template-rows,opacity,filter,scale]\",\r\n          isSingle\r\n            ? \"blur-0 scale-100 grid-rows-[1fr] opacity-100\"\r\n            : \"pointer-events-none scale-95 grid-rows-[0fr] opacity-0 blur-[2px]\",\r\n        )}\r\n      >\r\n        <div className=\"overflow-hidden\">\r\n          {singleItem && (\r\n            <GroupedSingleItemContent\r\n              item={singleItem}\r\n              showCloseButton={singleItem.showCloseButton}\r\n            />\r\n          )}\r\n        </div>\r\n      </div>\r\n\r\n      {/* Summary view */}\r\n      <div\r\n        className={cn(\r\n          \"ease-out-cubic grid duration-200\",\r\n          \"transition-[grid-template-rows,opacity,filter,scale]\",\r\n          !isSingle\r\n            ? \"blur-0 scale-100 grid-rows-[1fr] opacity-100\"\r\n            : \"pointer-events-none scale-95 grid-rows-[0fr] opacity-0 blur-[2px]\",\r\n        )}\r\n      >\r\n        <div className=\"overflow-hidden\">\r\n          <GroupedToastSummaryContent\r\n            data={data}\r\n            onToggle={() => toggleGroupExpanded(toastId)}\r\n          />\r\n        </div>\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n\r\ninterface GroupedSingleItemContentProps {\r\n  item: GroupedToastItem;\r\n  showCloseButton?: boolean;\r\n}\r\n\r\nfunction GroupedSingleItemContent({\r\n  item,\r\n  showCloseButton = true,\r\n}: GroupedSingleItemContentProps) {\r\n  const type = item.type || \"default\";\r\n  const Icon =\r\n    type !== \"default\" ? TOAST_ICONS[type as keyof typeof TOAST_ICONS] : null;\r\n\r\n  // When close button exists: action underneath text, items-start\r\n  // When no close button: action on right side, items-center\r\n  return (\r\n    <div\r\n      className={cn(\r\n        \"flex gap-3 px-3.5 py-3\",\r\n        showCloseButton ? \"items-start\" : \"items-center\",\r\n      )}\r\n    >\r\n      {Icon && (\r\n        <div\r\n          data-slot=\"toast-icon\"\r\n          className={cn(\r\n            \"[&>svg]:size-4 [&>svg]:shrink-0\",\r\n            showCloseButton && \"mt-0.5\",\r\n          )}\r\n        >\r\n          <HugeiconsIcon\r\n            icon={Icon}\r\n            strokeWidth={2}\r\n            className={toastIconVariants({ type })}\r\n          />\r\n        </div>\r\n      )}\r\n      <div className=\"flex min-w-0 flex-1 flex-col gap-0.5\">\r\n        {item.title && (\r\n          <span className=\"text-sm leading-5 font-medium\">{item.title}</span>\r\n        )}\r\n        {item.description && (\r\n          <span className=\"text-muted-foreground text-sm leading-5\">\r\n            {item.description}\r\n          </span>\r\n        )}\r\n        {showCloseButton && item.action && (\r\n          <div className=\"mt-1.5\">\r\n            <button\r\n              onClick={item.action.onClick}\r\n              className={buttonVariants({ variant: \"outline\", size: \"xs\" })}\r\n            >\r\n              {item.action.label}\r\n            </button>\r\n          </div>\r\n        )}\r\n      </div>\r\n      {!showCloseButton && item.action && (\r\n        <button\r\n          onClick={item.action.onClick}\r\n          className={buttonVariants({ variant: \"outline\", size: \"xs\" })}\r\n        >\r\n          {item.action.label}\r\n        </button>\r\n      )}\r\n      {showCloseButton && (\r\n        <Toast.Close\r\n          data-slot=\"toast-close\"\r\n          className=\"text-muted-foreground hover:bg-accent/50 hover:text-foreground -mt-1 -mr-1 flex size-6 shrink-0 items-center justify-center rounded-md border-none bg-transparent transition-colors duration-200\"\r\n          aria-label=\"Close\"\r\n        >\r\n          <HugeiconsIcon\r\n            icon={Cancel01Icon}\r\n            strokeWidth={2}\r\n            className=\"size-4\"\r\n          />\r\n        </Toast.Close>\r\n      )}\r\n    </div>\r\n  );\r\n}\r\n\r\ninterface GroupedToastSummaryContentProps {\r\n  data: GroupedToastData;\r\n  onToggle: () => void;\r\n}\r\n\r\nfunction GroupedToastSummaryContent({\r\n  data,\r\n  onToggle,\r\n}: GroupedToastSummaryContentProps) {\r\n  // Compute counts - use historical counts for accuracy (don't decrement on dismiss)\r\n  const loadingCount = data.items.filter(\r\n    (item) => item.type === \"loading\",\r\n  ).length;\r\n\r\n  // Use historical counts for type breakdown (persist after items dismiss)\r\n  const {\r\n    success: successCount,\r\n    error: errorCount,\r\n    warning: warningCount,\r\n    info: infoCount,\r\n  } = data.historicalCounts;\r\n  const completedCount = successCount + errorCount + warningCount + infoCount;\r\n  const totalCount = loadingCount + completedCount;\r\n\r\n  // Determine icon type based on state\r\n  let iconType: \"loading\" | \"success\" | \"error\" | \"warning\";\r\n  if (loadingCount > 0) {\r\n    iconType = \"loading\";\r\n  } else if (errorCount === 0) {\r\n    iconType = \"success\"; // All succeeded\r\n  } else if (successCount === 0 && warningCount === 0 && infoCount === 0) {\r\n    iconType = \"error\"; // All failed\r\n  } else {\r\n    iconType = \"warning\"; // Mixed results\r\n  }\r\n  const Icon = TOAST_ICONS[iconType];\r\n\r\n  const summaryText =\r\n    typeof data.summary === \"function\"\r\n      ? data.summary({\r\n          loadingCount,\r\n          completedCount,\r\n          totalCount,\r\n          successCount,\r\n          errorCount,\r\n          warningCount,\r\n          infoCount,\r\n        })\r\n      : data.summary;\r\n\r\n  const buttonLabel = data.isExpanded\r\n    ? data.action.expandedLabel\r\n    : data.action.label;\r\n\r\n  return (\r\n    <div className=\"flex items-center gap-3 px-3.5 py-3\">\r\n      <div data-slot=\"toast-icon\" className=\"[&>svg]:size-4 [&>svg]:shrink-0\">\r\n        <HugeiconsIcon\r\n          icon={Icon}\r\n          strokeWidth={2}\r\n          className={toastIconVariants({ type: iconType })}\r\n        />\r\n      </div>\r\n      <span className=\"flex-1 font-medium\">{summaryText}</span>\r\n      {/* Show button when in group mode (historical or current expandable items) */}\r\n      {(data.hasShownAllComplete ||\r\n        data.items.length > 1 ||\r\n        (data.completedItems ?? []).length > 0) && (\r\n        <button\r\n          onClick={onToggle}\r\n          aria-expanded={data.isExpanded}\r\n          className={buttonVariants({ variant: \"outline\", size: \"xs\" })}\r\n        >\r\n          {buttonLabel}\r\n        </button>\r\n      )}\r\n    </div>\r\n  );\r\n}\r\n\r\ninterface ExpandedCardsContainerProps {\r\n  data: GroupedToastData;\r\n  isTop: boolean;\r\n}\r\n\r\n/** Container for expanded pending/completed item cards with enter/exit animations */\r\nfunction ExpandedCardsContainer({ data, isTop }: ExpandedCardsContainerProps) {\r\n  const completedCount = (data.completedItems ?? []).length;\r\n  const pendingCount = data.items.length;\r\n  const hasCompletedItems = completedCount > 0;\r\n\r\n  // Show pending card when:\r\n  // - There are 2+ pending items (original behavior), OR\r\n  // - There's at least 1 pending item AND completed items exist, OR\r\n  // - There's at least 1 pending item AND we've been in group mode (historical context)\r\n  const hasPendingItems =\r\n    pendingCount > 1 ||\r\n    (pendingCount >= 1 && hasCompletedItems) ||\r\n    (pendingCount >= 1 && data.hasShownAllComplete);\r\n\r\n  if (!hasCompletedItems && !hasPendingItems) {\r\n    return null;\r\n  }\r\n\r\n  return (\r\n    <div\r\n      data-slot=\"expanded-cards-container\"\r\n      // Use flex-col with conditional DOM order instead of flex-col-reverse for Safari animation compatibility\r\n      className=\"flex flex-col gap-2\"\r\n    >\r\n      <AnimatePresence initial={false} mode=\"popLayout\">\r\n        {/* Flat conditional rendering for Safari AnimatePresence compatibility.\r\n            Order: completed first for bottom position, pending, completed last for top position */}\r\n\r\n        {/* Completed card first (for bottom position only) */}\r\n        {!isTop && hasCompletedItems && (\r\n          <motion.div\r\n            key=\"completed-card\"\r\n            layout\r\n            initial={{ opacity: 0, scale: 0.95 }}\r\n            animate={{ opacity: 1, scale: 1 }}\r\n            exit={{ opacity: 0, scale: 0.95 }}\r\n            transition={{ duration: 0.2, ease: [0.25, 0.1, 0.25, 1] }}\r\n          >\r\n            <CompletedItemsCard items={data.completedItems} isTop={isTop} />\r\n          </motion.div>\r\n        )}\r\n\r\n        {/* Pending card (always in middle position) */}\r\n        {hasPendingItems && (\r\n          <motion.div\r\n            key=\"pending-card\"\r\n            layout\r\n            initial={{ opacity: 0, scale: 0.95 }}\r\n            animate={{ opacity: 1, scale: 1 }}\r\n            exit={{ opacity: 0, scale: 0.95, y: -20 }}\r\n            transition={{ duration: 0.2, ease: [0.25, 0.1, 0.25, 1] }}\r\n          >\r\n            <GroupedToastCard data={data} isTop={isTop} />\r\n          </motion.div>\r\n        )}\r\n\r\n        {/* Completed card last (for top position only) */}\r\n        {isTop && hasCompletedItems && (\r\n          <motion.div\r\n            key=\"completed-card\"\r\n            layout\r\n            initial={{ opacity: 0, scale: 0.95 }}\r\n            animate={{ opacity: 1, scale: 1 }}\r\n            exit={{ opacity: 0, scale: 0.95 }}\r\n            transition={{ duration: 0.2, ease: [0.25, 0.1, 0.25, 1] }}\r\n          >\r\n            <CompletedItemsCard items={data.completedItems} isTop={isTop} />\r\n          </motion.div>\r\n        )}\r\n      </AnimatePresence>\r\n    </div>\r\n  );\r\n}\r\n\r\ninterface GroupedToastCardProps {\r\n  data: GroupedToastData;\r\n  isTop: boolean;\r\n}\r\n\r\nfunction GroupedToastCard({ data, isTop }: GroupedToastCardProps) {\r\n  const cardRef = React.useRef<HTMLDivElement>(null);\r\n\r\n  // Use native event listeners to stop propagation at the capture phase\r\n  React.useEffect(() => {\r\n    const card = cardRef.current;\r\n    if (!card) return;\r\n\r\n    const stopPropagation = (e: TouchEvent) => {\r\n      e.stopPropagation();\r\n    };\r\n\r\n    // Stop all touch events from reaching the toast's swipe handler\r\n    card.addEventListener(\"touchstart\", stopPropagation, { passive: true });\r\n    card.addEventListener(\"touchmove\", stopPropagation, { passive: true });\r\n    card.addEventListener(\"touchend\", stopPropagation, { passive: true });\r\n\r\n    return () => {\r\n      card.removeEventListener(\"touchstart\", stopPropagation);\r\n      card.removeEventListener(\"touchmove\", stopPropagation);\r\n      card.removeEventListener(\"touchend\", stopPropagation);\r\n    };\r\n  }, []);\r\n\r\n  return (\r\n    <div\r\n      ref={cardRef}\r\n      data-slot=\"grouped-toast-card\"\r\n      data-swipe-ignore\r\n      className={cn(\r\n        \"max-h-64 w-full overflow-y-auto overscroll-contain\",\r\n        \"ring-border bg-card text-card-foreground rounded-lg ring-1\",\r\n        \"shadow-lg/4\",\r\n        \"animate-in fade-in-0 zoom-in-95\",\r\n        isTop ? \"slide-in-from-top-2\" : \"slide-in-from-bottom-2\",\r\n      )}\r\n    >\r\n      <AnimatePresence initial={false}>\r\n        {data.items.map((item, index) => (\r\n          <motion.div\r\n            key={item.id}\r\n            initial={{ height: 0, opacity: 0 }}\r\n            animate={{ height: \"auto\", opacity: 1 }}\r\n            exit={{ height: 0, opacity: 0 }}\r\n            transition={{ duration: 0.2, ease: [0.25, 0.1, 0.25, 1] }}\r\n            className=\"overflow-hidden\"\r\n          >\r\n            <GroupedToastCardItem item={item} showSeparator={index > 0} />\r\n          </motion.div>\r\n        ))}\r\n      </AnimatePresence>\r\n    </div>\r\n  );\r\n}\r\n\r\ninterface GroupedToastCardItemProps {\r\n  item: GroupedToastItem;\r\n  showSeparator: boolean;\r\n}\r\n\r\nfunction GroupedToastCardItem({\r\n  item,\r\n  showSeparator,\r\n}: GroupedToastCardItemProps) {\r\n  const type = item.type || \"default\";\r\n  const Icon =\r\n    type !== \"default\" ? TOAST_ICONS[type as keyof typeof TOAST_ICONS] : null;\r\n\r\n  return (\r\n    <>\r\n      {showSeparator && (\r\n        <div\r\n          className=\"bg-border mx-2 h-px\"\r\n          data-slot=\"grouped-toast-separator\"\r\n        />\r\n      )}\r\n      <div\r\n        data-slot=\"grouped-toast-card-item\"\r\n        className=\"flex items-center gap-3 px-3.5 py-3 text-sm\"\r\n      >\r\n        {Icon && (\r\n          <div\r\n            data-slot=\"toast-icon\"\r\n            className=\"[&>svg]:size-4 [&>svg]:shrink-0\"\r\n          >\r\n            <HugeiconsIcon\r\n              icon={Icon}\r\n              strokeWidth={2}\r\n              className={toastIconVariants({ type })}\r\n            />\r\n          </div>\r\n        )}\r\n        <div className=\"flex min-w-0 flex-1 flex-col gap-0.5\">\r\n          {item.title && (\r\n            <span className=\"leading-5 font-medium\">{item.title}</span>\r\n          )}\r\n          {item.description && (\r\n            <span className=\"text-muted-foreground leading-5\">\r\n              {item.description}\r\n            </span>\r\n          )}\r\n        </div>\r\n        {item.action && (\r\n          <button\r\n            onClick={item.action.onClick}\r\n            className={buttonVariants({ variant: \"outline\", size: \"xs\" })}\r\n          >\r\n            {item.action.label}\r\n          </button>\r\n        )}\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n\r\n// Completed Items Components\r\ninterface CompletedItemRowProps {\r\n  item: GroupedToastItem;\r\n  showSeparator: boolean;\r\n}\r\n\r\nfunction CompletedItemRow({ item, showSeparator }: CompletedItemRowProps) {\r\n  const type = item.type || \"success\";\r\n  const Icon =\r\n    type !== \"default\" ? TOAST_ICONS[type as keyof typeof TOAST_ICONS] : null;\r\n\r\n  // Use item's duration or default for progress bar animation\r\n  const dismissDuration = item.duration ?? GROUP_ITEM_DISMISS_DURATION;\r\n  // Calculate elapsed time on mount to sync animation with actual timer\r\n  const [elapsed] = React.useState(() =>\r\n    item.completedAt ? Date.now() - item.completedAt : 0,\r\n  );\r\n  const animationStyle = {\r\n    \"--dismiss-duration\": `${dismissDuration}ms`,\r\n    \"--animation-delay\": `-${Math.min(elapsed, dismissDuration)}ms`,\r\n  } as React.CSSProperties;\r\n\r\n  return (\r\n    <>\r\n      {showSeparator && (\r\n        <div\r\n          className=\"bg-border h-px w-full\"\r\n          data-slot=\"completed-item-separator\"\r\n        />\r\n      )}\r\n      <div\r\n        data-slot=\"completed-item-row\"\r\n        className=\"relative flex items-center gap-3 overflow-hidden px-3.5 py-3 text-sm\"\r\n        style={animationStyle}\r\n      >\r\n        {/* Progress bar background (fills left-to-right) */}\r\n        <div\r\n          data-slot=\"completed-item-progress\"\r\n          className={cn(\r\n            \"bg-card absolute inset-0 origin-left\",\r\n            \"animate-[progress-fill_var(--dismiss-duration)_linear_forwards]\",\r\n            \"[animation-delay:var(--animation-delay)]\",\r\n          )}\r\n        />\r\n\r\n        {/* Content layer (above progress bar) */}\r\n        <div className=\"relative z-10 flex w-full items-center gap-3\">\r\n          {Icon && (\r\n            <div\r\n              data-slot=\"toast-icon\"\r\n              className=\"[&>svg]:size-4 [&>svg]:shrink-0\"\r\n            >\r\n              <HugeiconsIcon\r\n                icon={Icon}\r\n                strokeWidth={2}\r\n                className={toastIconVariants({ type })}\r\n              />\r\n            </div>\r\n          )}\r\n\r\n          <div className=\"flex min-w-0 flex-1 flex-col gap-0.5\">\r\n            {item.title && (\r\n              <span className=\"leading-5 font-medium\">{item.title}</span>\r\n            )}\r\n            {item.description && (\r\n              <span className=\"text-muted-foreground leading-5\">\r\n                {item.description}\r\n              </span>\r\n            )}\r\n          </div>\r\n\r\n          {/* Action button on right */}\r\n          {item.action && (\r\n            <button\r\n              onClick={item.action.onClick}\r\n              className={buttonVariants({ variant: \"outline\", size: \"xs\" })}\r\n            >\r\n              {item.action.label}\r\n            </button>\r\n          )}\r\n        </div>\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n\r\ninterface CompletedItemsCardProps {\r\n  items: GroupedToastItem[];\r\n  isTop: boolean;\r\n}\r\n\r\nfunction CompletedItemsCard({ items, isTop }: CompletedItemsCardProps) {\r\n  const cardRef = React.useRef<HTMLDivElement>(null);\r\n\r\n  // Touch event isolation (same pattern as GroupedToastCard)\r\n  React.useEffect(() => {\r\n    const card = cardRef.current;\r\n    if (!card) return;\r\n\r\n    const stopPropagation = (e: TouchEvent) => {\r\n      e.stopPropagation();\r\n    };\r\n\r\n    card.addEventListener(\"touchstart\", stopPropagation, { passive: true });\r\n    card.addEventListener(\"touchmove\", stopPropagation, { passive: true });\r\n    card.addEventListener(\"touchend\", stopPropagation, { passive: true });\r\n\r\n    return () => {\r\n      card.removeEventListener(\"touchstart\", stopPropagation);\r\n      card.removeEventListener(\"touchmove\", stopPropagation);\r\n      card.removeEventListener(\"touchend\", stopPropagation);\r\n    };\r\n  }, []);\r\n\r\n  return (\r\n    <div\r\n      ref={cardRef}\r\n      data-slot=\"completed-items-card\"\r\n      data-swipe-ignore\r\n      className={cn(\r\n        \"max-h-48 w-full overflow-y-auto overscroll-contain\",\r\n        \"ring-border bg-muted text-card-foreground rounded-lg ring-1\",\r\n        \"shadow-lg/4\",\r\n        \"animate-in fade-in-0 zoom-in-95\",\r\n        isTop ? \"slide-in-from-top-2\" : \"slide-in-from-bottom-2\",\r\n      )}\r\n    >\r\n      <AnimatePresence initial={false}>\r\n        {items.map((item, index) => (\r\n          <motion.div\r\n            key={item.id}\r\n            initial={{ height: 0, opacity: 0 }}\r\n            animate={{ height: \"auto\", opacity: 1 }}\r\n            exit={{ height: 0, opacity: 0 }}\r\n            transition={{ duration: 0.2, ease: [0.25, 0.1, 0.25, 1] }}\r\n            className=\"overflow-hidden\"\r\n          >\r\n            <CompletedItemRow item={item} showSeparator={index > 0} />\r\n          </motion.div>\r\n        ))}\r\n      </AnimatePresence>\r\n    </div>\r\n  );\r\n}\r\n\r\n// Exports\r\nexport { Toast, toastManager, anchoredToastManager };\r\n",
      "type": "registry:ui",
      "target": "components/ui/cubby-ui/toast/toast.tsx"
    },
    {
      "path": "registry/default/toast/toast.css",
      "content": "@keyframes progress-fill {\r\n  from {\r\n    transform: scaleX(0);\r\n  }\r\n  to {\r\n    transform: scaleX(1);\r\n  }\r\n}\r\n",
      "type": "registry:file",
      "target": "components/ui/cubby-ui/toast/toast.css"
    }
  ]
}