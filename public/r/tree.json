{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "tree",
  "type": "registry:ui",
  "title": "Tree",
  "description": "A tree component.",
  "dependencies": [
    "lucide-react"
  ],
  "registryDependencies": [
    "@cubby-ui/checkbox"
  ],
  "files": [
    {
      "path": "registry/default/tree/tree.tsx",
      "content": "\"use client\";\r\n\r\nimport * as React from \"react\";\r\nimport { Collapsible as BaseCollapsible } from \"@base-ui/react/collapsible\";\r\nimport { CheckboxGroup } from \"@base-ui/react/checkbox-group\";\r\nimport { Checkbox } from \"@/registry/default/checkbox/checkbox\";\r\nimport { ChevronRightIcon, Loader2Icon } from \"lucide-react\";\r\nimport { mergeProps } from \"@base-ui/react/merge-props\";\r\nimport { useRender } from \"@base-ui/react/use-render\";\r\nimport { cn } from \"@/lib/utils\";\r\nimport {\r\n  getAllDescendantIds,\r\n  getLeafNodeIds,\r\n  buildParentMap,\r\n  collectVisibleIds,\r\n  handleTreeKeyboardNavigation,\r\n} from \"./lib/tree-utils\";\r\n\r\n// ============================================================================\r\n// Types\r\n// ============================================================================\r\n\r\nexport interface TreeNodeBase<\r\n  TData extends Record<string, unknown> = Record<string, unknown>,\r\n> {\r\n  id: string;\r\n  name: string;\r\n  data?: TData;\r\n  disabled?: boolean;\r\n  loading?: boolean;\r\n  icon?: React.ReactNode;\r\n  badge?: React.ReactNode;\r\n}\r\n\r\nexport interface TreeLeafNode<\r\n  TData extends Record<string, unknown> = Record<string, unknown>,\r\n> extends TreeNodeBase<TData> {\r\n  children?: never;\r\n}\r\n\r\nexport interface TreeParentNode<\r\n  TData extends Record<string, unknown> = Record<string, unknown>,\r\n> extends TreeNodeBase<TData> {\r\n  children: TreeNode<TData>[];\r\n  iconOpen?: React.ReactNode;\r\n  onLoadChildren?: () => Promise<TreeNode<TData>[]>;\r\n}\r\n\r\nexport type TreeNode<\r\n  TData extends Record<string, unknown> = Record<string, unknown>,\r\n> = TreeLeafNode<TData> | TreeParentNode<TData>;\r\n\r\nexport interface TreeSelectEvent<\r\n  TData extends Record<string, unknown> = Record<string, unknown>,\r\n> {\r\n  nodeId: string;\r\n  node: TreeNode<TData>;\r\n  event: React.MouseEvent | React.KeyboardEvent;\r\n}\r\n\r\nexport interface TreeExpandEvent {\r\n  nodeId: string;\r\n  expanded: boolean;\r\n}\r\n\r\ntype TreeVariant = \"default\" | \"filled\" | \"outline\";\r\ntype TreeMode = \"single\" | \"multiple\" | \"none\";\r\n\r\n// ============================================================================\r\n// Context\r\n// ============================================================================\r\n\r\ninterface TreeContextValue<\r\n  TData extends Record<string, unknown> = Record<string, unknown>,\r\n> {\r\n  // Tree-level state\r\n  selectedNode?: string | null;\r\n  onNodeSelect?: (nodeId: string) => void;\r\n  expandedNodes: Set<string>;\r\n  onToggleNode: (nodeId: string) => void | Promise<void>;\r\n  checkedNodes?: Set<string>;\r\n  onCheckedNodesChange?: (checked: string[]) => void;\r\n  renderItem: (item: TreeNode<TData>) => React.ReactElement;\r\n  variant: TreeVariant;\r\n  showLines: boolean;\r\n  enableBulkActions: boolean;\r\n  disableSelection: boolean;\r\n  focusableNodes: React.MutableRefObject<Map<string, HTMLElement>>;\r\n  visibleNodeIds: string[];\r\n  disabledNodesMap: Map<string, boolean>;\r\n  loadingNodesMap: Map<string, boolean>;\r\n  parentNodeMap: Map<string, string>;\r\n  lastFocusedNodeId: string | null;\r\n  setLastFocusedNodeId: (nodeId: string | null) => void;\r\n  data: TreeNode<TData>[];\r\n  // Item-level state\r\n  item?: TreeNode<TData>;\r\n  depth?: number;\r\n  isExpanded?: boolean;\r\n  isSelected?: boolean;\r\n  hasChildren?: boolean;\r\n  isLoading?: boolean;\r\n}\r\n\r\nconst TreeContext = React.createContext<TreeContextValue | null>(null);\r\n\r\nfunction useTreeContext<\r\n  TData extends Record<string, unknown> = Record<string, unknown>,\r\n>(): TreeContextValue<TData> {\r\n  const context = React.useContext(\r\n    TreeContext,\r\n  ) as TreeContextValue<TData> | null;\r\n  if (!context) {\r\n    throw new Error(\"Tree components must be used within a Tree\");\r\n  }\r\n  return context;\r\n}\r\n\r\n// Extracts item-level state from context for TreeItem subcomponents\r\nfunction useTreeItemContext<\r\n  TData extends Record<string, unknown> = Record<string, unknown>,\r\n>(): Required<\r\n  Pick<\r\n    TreeContextValue<TData>,\r\n    \"item\" | \"depth\" | \"isExpanded\" | \"isSelected\" | \"hasChildren\" | \"isLoading\"\r\n  >\r\n> {\r\n  const context = useTreeContext<TData>();\r\n  if (!context.item) {\r\n    throw new Error(\"TreeItem subcomponents must be used within TreeItem\");\r\n  }\r\n  return {\r\n    item: context.item,\r\n    depth: context.depth!,\r\n    isExpanded: context.isExpanded!,\r\n    isSelected: context.isSelected!,\r\n    hasChildren: context.hasChildren!,\r\n    isLoading: context.isLoading!,\r\n  };\r\n}\r\n\r\n// ============================================================================\r\n// Tree Root\r\n// ============================================================================\r\n\r\nexport interface TreeProps<\r\n  TData extends Record<string, unknown> = Record<string, unknown>,\r\n> extends Omit<useRender.ComponentProps<\"div\">, \"children\"> {\r\n  data: TreeNode<TData>[];\r\n  children: (item: TreeNode<TData>) => React.ReactElement;\r\n  selectedNode?: string | null;\r\n  onNodeSelect?: (nodeId: string) => void;\r\n  defaultExpanded?: string[];\r\n  expanded?: string[];\r\n  onExpandedChange?: (expanded: string[]) => void;\r\n  checkedNodes?: string[];\r\n  onCheckedNodesChange?: (checked: string[]) => void;\r\n  variant?: TreeVariant;\r\n  showLines?: boolean;\r\n  mode?: TreeMode;\r\n}\r\n\r\nfunction Tree<TData extends Record<string, unknown> = Record<string, unknown>>({\r\n  data,\r\n  children: renderItem,\r\n  selectedNode,\r\n  onNodeSelect,\r\n  defaultExpanded = [],\r\n  expanded,\r\n  onExpandedChange,\r\n  checkedNodes,\r\n  onCheckedNodesChange,\r\n  variant = \"default\",\r\n  showLines = false,\r\n  mode = \"single\",\r\n  className,\r\n  render,\r\n  ...props\r\n}: TreeProps<TData>): React.ReactElement {\r\n  // Derive internal flags from mode\r\n  const enableBulkActions = mode === \"multiple\";\r\n  const disableSelection = mode === \"none\";\r\n  // Validate tree structure in development\r\n  React.useEffect(() => {\r\n    if (process.env.NODE_ENV !== \"development\") return;\r\n    import(\"./lib/tree-utils\")\r\n      .then(({ validateTreeStructure }) => {\r\n        validateTreeStructure(data);\r\n      })\r\n      .catch((error) => {\r\n        console.error(\"Tree validation error:\", error);\r\n      });\r\n  }, [data]);\r\n\r\n  // Store renderItem in ref for stable context reference\r\n  const renderItemRef = React.useRef(renderItem);\r\n  renderItemRef.current = renderItem;\r\n\r\n  const [internalExpanded, setInternalExpanded] = React.useState<Set<string>>(\r\n    () => new Set(defaultExpanded),\r\n  );\r\n\r\n  const focusableNodes = React.useRef<Map<string, HTMLElement>>(new Map());\r\n  const [lastFocusedNodeId, setLastFocusedNodeId] = React.useState<\r\n    string | null\r\n  >(null);\r\n\r\n  // Track nodes that are currently loading children\r\n  const [loadingNodes, setLoadingNodes] = React.useState<Set<string>>(\r\n    () => new Set(),\r\n  );\r\n\r\n  // Track nodes that have already loaded their children\r\n  const loadedNodesRef = React.useRef<Set<string>>(new Set());\r\n\r\n  // Store dynamically loaded children\r\n  const [loadedChildren, setLoadedChildren] = React.useState<\r\n    Map<string, TreeNode<TData>[]>\r\n  >(() => new Map());\r\n\r\n  const expandedNodes = React.useMemo(() => {\r\n    return expanded ? new Set(expanded) : internalExpanded;\r\n  }, [expanded, internalExpanded]);\r\n\r\n  // Merge loaded children into the tree data\r\n  const mergedData = React.useMemo(() => {\r\n    if (loadedChildren.size === 0) return data;\r\n\r\n    const mergeChildren = (nodes: TreeNode<TData>[]): TreeNode<TData>[] => {\r\n      return nodes.map((node) => {\r\n        const loaded = loadedChildren.get(node.id);\r\n        if (loaded) {\r\n          return { ...node, children: loaded };\r\n        }\r\n        if (node.children) {\r\n          return { ...node, children: mergeChildren(node.children) };\r\n        }\r\n        return node;\r\n      });\r\n    };\r\n\r\n    return mergeChildren(data);\r\n  }, [data, loadedChildren]);\r\n\r\n  const handleToggleNode = React.useCallback(\r\n    async (nodeId: string) => {\r\n      const isCurrentlyExpanded = expandedNodes.has(nodeId);\r\n      const isExpanding = !isCurrentlyExpanded;\r\n\r\n      // Find the node to check if it needs to load children\r\n      const findNode = (\r\n        nodes: TreeNode<TData>[],\r\n      ): TreeNode<TData> | undefined => {\r\n        for (const node of nodes) {\r\n          if (node.id === nodeId) return node;\r\n          if (node.children) {\r\n            const found = findNode(node.children);\r\n            if (found) return found;\r\n          }\r\n        }\r\n        return undefined;\r\n      };\r\n\r\n      const node = findNode(mergedData);\r\n      const needsToLoad =\r\n        isExpanding &&\r\n        node &&\r\n        \"onLoadChildren\" in node &&\r\n        node.onLoadChildren &&\r\n        !loadedNodesRef.current.has(nodeId);\r\n\r\n      // If we need to load children, delay expansion until loaded\r\n      if (needsToLoad) {\r\n        setLoadingNodes((prev) => new Set(prev).add(nodeId));\r\n        loadedNodesRef.current.add(nodeId);\r\n\r\n        try {\r\n          const children = await node.onLoadChildren!();\r\n          setLoadedChildren((prev) => {\r\n            const next = new Map(prev);\r\n            next.set(nodeId, children);\r\n            return next;\r\n          });\r\n\r\n          // NOW expand the node after children are loaded\r\n          const newExpanded = new Set(expandedNodes);\r\n          newExpanded.add(nodeId);\r\n          if (expanded && onExpandedChange) {\r\n            onExpandedChange(Array.from(newExpanded));\r\n          } else {\r\n            setInternalExpanded(newExpanded);\r\n          }\r\n        } catch (error) {\r\n          console.error(`Failed to load children for node ${nodeId}:`, error);\r\n          loadedNodesRef.current.delete(nodeId);\r\n        } finally {\r\n          setLoadingNodes((prev) => {\r\n            const next = new Set(prev);\r\n            next.delete(nodeId);\r\n            return next;\r\n          });\r\n        }\r\n        return;\r\n      }\r\n\r\n      // Standard toggle for collapsing or nodes that don't need to load\r\n      const newExpanded = new Set(expandedNodes);\r\n      if (isCurrentlyExpanded) {\r\n        newExpanded.delete(nodeId);\r\n      } else {\r\n        newExpanded.add(nodeId);\r\n      }\r\n\r\n      if (expanded && onExpandedChange) {\r\n        onExpandedChange(Array.from(newExpanded));\r\n      } else {\r\n        setInternalExpanded(newExpanded);\r\n      }\r\n    },\r\n    [expandedNodes, expanded, onExpandedChange, mergedData],\r\n  );\r\n\r\n  const checkedNodesSet = React.useMemo(() => {\r\n    return checkedNodes ? new Set(checkedNodes) : undefined;\r\n  }, [checkedNodes]);\r\n\r\n  // Compute parent node map for ALL nodes (not just visible ones)\r\n  const parentNodeMap = React.useMemo(\r\n    () => buildParentMap(mergedData),\r\n    [mergedData],\r\n  );\r\n\r\n  const { visibleNodeIds, disabledNodesMap } = React.useMemo(\r\n    () => collectVisibleIds(mergedData, expandedNodes),\r\n    [mergedData, expandedNodes],\r\n  );\r\n\r\n  // Create loading nodes map\r\n  const loadingNodesMap = React.useMemo(() => {\r\n    const map = new Map<string, boolean>();\r\n    loadingNodes.forEach((id) => map.set(id, true));\r\n    return map;\r\n  }, [loadingNodes]);\r\n\r\n  // Focus restoration: when data changes and focused node is removed, focus first node\r\n  React.useEffect(() => {\r\n    if (!lastFocusedNodeId || visibleNodeIds.includes(lastFocusedNodeId))\r\n      return;\r\n\r\n    const firstId = visibleNodeIds[0];\r\n    if (firstId) {\r\n      setLastFocusedNodeId(firstId);\r\n      setTimeout(() => focusableNodes.current.get(firstId)?.focus(), 0);\r\n    } else {\r\n      setLastFocusedNodeId(null);\r\n    }\r\n  }, [visibleNodeIds, lastFocusedNodeId]);\r\n\r\n  const contextValue = React.useMemo(\r\n    () => ({\r\n      selectedNode,\r\n      onNodeSelect,\r\n      expandedNodes,\r\n      onToggleNode: handleToggleNode,\r\n      checkedNodes: checkedNodesSet,\r\n      onCheckedNodesChange,\r\n      renderItem: ((item: TreeNode<Record<string, unknown>>) =>\r\n        renderItemRef.current(item as TreeNode<TData>)) as (\r\n        item: TreeNode<Record<string, unknown>>,\r\n      ) => React.ReactElement,\r\n      variant,\r\n      showLines,\r\n      enableBulkActions,\r\n      disableSelection,\r\n      focusableNodes,\r\n      visibleNodeIds,\r\n      disabledNodesMap,\r\n      loadingNodesMap,\r\n      parentNodeMap,\r\n      lastFocusedNodeId,\r\n      setLastFocusedNodeId,\r\n      data: mergedData,\r\n    }),\r\n    [\r\n      selectedNode,\r\n      onNodeSelect,\r\n      expandedNodes,\r\n      handleToggleNode,\r\n      checkedNodesSet,\r\n      onCheckedNodesChange,\r\n      variant,\r\n      showLines,\r\n      enableBulkActions,\r\n      disableSelection,\r\n      visibleNodeIds,\r\n      disabledNodesMap,\r\n      loadingNodesMap,\r\n      parentNodeMap,\r\n      lastFocusedNodeId,\r\n      setLastFocusedNodeId,\r\n      mergedData,\r\n    ],\r\n  );\r\n\r\n  const defaultProps = {\r\n    \"data-slot\": \"tree\",\r\n    className: cn(\r\n      \"w-full min-w-0 text-sm\",\r\n      variant === \"filled\" &&\r\n        \"ring ring-border/60 ring-1 bg-muted rounded-2xl p-2 shadow-sm\",\r\n      variant === \"outline\" &&\r\n        \"overflow-hidden rounded-2xl ring ring-border/60 bg-card p-2 shadow-sm\",\r\n      className,\r\n    ),\r\n    role: \"tree\",\r\n    \"aria-multiselectable\": enableBulkActions,\r\n    children: (\r\n      <TreeContext.Provider value={contextValue}>\r\n        {mergedData.map((node, index) => (\r\n          <TreeItemInternal\r\n            key={node.id}\r\n            node={node}\r\n            depth={0}\r\n            positionInSet={index + 1}\r\n            setSize={mergedData.length}\r\n          />\r\n        ))}\r\n      </TreeContext.Provider>\r\n    ),\r\n  };\r\n\r\n  const element = useRender({\r\n    defaultTagName: \"div\",\r\n    render,\r\n    props: mergeProps<\"div\">(defaultProps, props),\r\n  });\r\n\r\n  return element;\r\n}\r\n\r\n// ============================================================================\r\n// Constants\r\n// ============================================================================\r\n\r\nconst INDENT_SIZE = 20;\r\nconst INDENT_SIZE_WITH_CHECKBOX = 12;\r\nconst VERTICAL_LINE_OFFSET = 4.5;\r\nconst CHILD_VERTICAL_LINE_OFFSET = 15.5;\r\nconst BADGE_TEXT_SIZE = \"text-[10px]\";\r\n\r\n// ============================================================================\r\n// Helper Functions - Defined outside component for stable references\r\n// ============================================================================\r\n\r\n/**\r\n * Updates parent nodes based on their children's checked state.\r\n * A parent is checked if all its leaf descendants are checked.\r\n */\r\nfunction updateParentCheckStates<\r\n  TData extends Record<string, unknown> = Record<string, unknown>,\r\n>(nodes: TreeNode<TData>[], checkedSet: Set<string>): void {\r\n  for (const node of nodes) {\r\n    if (node.children && node.children.length > 0) {\r\n      // Recursively update children first (bottom-up)\r\n      updateParentCheckStates(node.children, checkedSet);\r\n\r\n      // Get all leaf descendants of this parent\r\n      const leafIds = getLeafNodeIds(node.children);\r\n\r\n      // Parent should be checked if all leaf descendants are checked\r\n      const allLeavesChecked = leafIds.every((id) => checkedSet.has(id));\r\n\r\n      if (allLeavesChecked) {\r\n        checkedSet.add(node.id);\r\n      } else {\r\n        checkedSet.delete(node.id);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// Custom Hooks\r\n// ============================================================================\r\n\r\ninterface UseTreeCheckboxStateParams<\r\n  TData extends Record<string, unknown> = Record<string, unknown>,\r\n> {\r\n  node: TreeNode<TData>;\r\n  hasChildren: boolean;\r\n  context: TreeContextValue<TData>;\r\n}\r\n\r\ninterface UseTreeCheckboxStateReturn {\r\n  allDescendantIds: string[];\r\n  localChildValues: string[];\r\n  handleLocalCheckboxChange: (newValues: string[]) => void;\r\n}\r\n\r\nfunction useTreeCheckboxState<\r\n  TData extends Record<string, unknown> = Record<string, unknown>,\r\n>({\r\n  node,\r\n  hasChildren,\r\n  context,\r\n}: UseTreeCheckboxStateParams<TData>): UseTreeCheckboxStateReturn {\r\n  const allDescendantIds = React.useMemo(\r\n    () => (hasChildren ? getAllDescendantIds(node) : []),\r\n    [hasChildren, node],\r\n  );\r\n\r\n  const allLeafIds = React.useMemo(\r\n    () => (hasChildren ? getLeafNodeIds(node.children || []) : []),\r\n    [hasChildren, node.children],\r\n  );\r\n\r\n  const localChildValues = React.useMemo(() => {\r\n    if (!hasChildren || !context.checkedNodes || !context.enableBulkActions)\r\n      return [];\r\n    return allDescendantIds.filter((id) => context.checkedNodes!.has(id));\r\n  }, [\r\n    hasChildren,\r\n    context.checkedNodes,\r\n    allDescendantIds,\r\n    context.enableBulkActions,\r\n  ]);\r\n\r\n  const handleLocalCheckboxChange = React.useCallback(\r\n    (newValues: string[]) => {\r\n      if (!context.onCheckedNodesChange || !context.checkedNodes) return;\r\n\r\n      const currentSet = new Set(context.checkedNodes);\r\n\r\n      // Remove all descendants\r\n      for (const id of allDescendantIds) {\r\n        currentSet.delete(id);\r\n      }\r\n\r\n      // Add back the selected values (these are all descendants now)\r\n      for (const id of newValues) {\r\n        currentSet.add(id);\r\n      }\r\n\r\n      // Update all parent nodes based on their children's checked state\r\n      // This will correctly set all ancestors (parent, grandparent, etc.)\r\n      updateParentCheckStates(context.data, currentSet);\r\n\r\n      context.onCheckedNodesChange(Array.from(currentSet));\r\n    },\r\n    [context, allDescendantIds],\r\n  );\r\n\r\n  return {\r\n    allDescendantIds,\r\n    localChildValues,\r\n    handleLocalCheckboxChange,\r\n  };\r\n}\r\n\r\n// ============================================================================\r\n// TreeItemInternal - Handles recursion internally\r\n// ============================================================================\r\n\r\ninterface TreeItemInternalProps<\r\n  TData extends Record<string, unknown> = Record<string, unknown>,\r\n> {\r\n  node: TreeNode<TData>;\r\n  depth: number;\r\n  positionInSet?: number;\r\n  setSize?: number;\r\n}\r\n\r\nfunction TreeItemInternal<\r\n  TData extends Record<string, unknown> = Record<string, unknown>,\r\n>({\r\n  node,\r\n  depth,\r\n  positionInSet,\r\n  setSize,\r\n}: TreeItemInternalProps<TData>): React.ReactElement {\r\n  const context = useTreeContext<TData>();\r\n\r\n  const hasChildren = Boolean(\r\n    (node.children && node.children.length > 0) ||\r\n    (\"onLoadChildren\" in node && node.onLoadChildren),\r\n  );\r\n  const isExpanded = context.expandedNodes.has(node.id);\r\n  const isSelected = context.selectedNode === node.id;\r\n  const isDisabled = node.disabled || false;\r\n  const isLoading =\r\n    context.loadingNodesMap.has(node.id) || node.loading || false;\r\n  const isChecked =\r\n    context.enableBulkActions && context.checkedNodes\r\n      ? context.checkedNodes.has(node.id)\r\n      : false;\r\n\r\n  // Roving tabindex: only the last focused node should be tabbable\r\n  // If no node has been focused yet, the first node is tabbable\r\n  const isFirstNode = context.visibleNodeIds[0] === node.id;\r\n  const isLastFocused = context.lastFocusedNodeId === node.id;\r\n  const isTabbable =\r\n    isLastFocused || (!context.lastFocusedNodeId && isFirstNode);\r\n\r\n  // Create merged context value with item-level state\r\n  const mergedContextValue = React.useMemo(\r\n    () => ({\r\n      ...context,\r\n      item: node,\r\n      depth,\r\n      isExpanded,\r\n      isSelected,\r\n      hasChildren,\r\n      isLoading,\r\n    }),\r\n    [context, node, depth, isExpanded, isSelected, hasChildren, isLoading],\r\n  );\r\n\r\n  const handleToggleChecked = React.useCallback(() => {\r\n    if (!context.onCheckedNodesChange || !context.checkedNodes) return;\r\n\r\n    const currentSet = new Set(context.checkedNodes);\r\n    const allDescendantIds = hasChildren ? getAllDescendantIds(node) : [];\r\n\r\n    if (isChecked) {\r\n      // Uncheck this node and all descendants\r\n      currentSet.delete(node.id);\r\n      for (const id of allDescendantIds) {\r\n        currentSet.delete(id);\r\n      }\r\n    } else {\r\n      // Check this node and all descendants\r\n      currentSet.add(node.id);\r\n      for (const id of allDescendantIds) {\r\n        currentSet.add(id);\r\n      }\r\n    }\r\n\r\n    // Update all parent nodes based on their children's checked state\r\n    updateParentCheckStates(context.data, currentSet);\r\n\r\n    context.onCheckedNodesChange(Array.from(currentSet));\r\n  }, [context, isChecked, node, hasChildren]);\r\n\r\n  const handleClick = React.useCallback(\r\n    (e: React.MouseEvent) => {\r\n      if (isDisabled) return;\r\n      e.stopPropagation();\r\n\r\n      if (context.enableBulkActions) {\r\n        handleToggleChecked();\r\n      } else if (!context.disableSelection) {\r\n        context.onNodeSelect?.(node.id);\r\n      }\r\n    },\r\n    [context, node.id, isDisabled, handleToggleChecked],\r\n  );\r\n\r\n  const handleKeyDown = React.useCallback(\r\n    (e: React.KeyboardEvent) => {\r\n      handleTreeKeyboardNavigation(e, {\r\n        nodeId: node.id,\r\n        hasChildren,\r\n        isExpanded,\r\n        isDisabled,\r\n        node,\r\n        visibleNodeIds: context.visibleNodeIds,\r\n        disabledNodesMap: context.disabledNodesMap,\r\n        parentNodeMap: context.parentNodeMap,\r\n        focusableNodes: context.focusableNodes.current,\r\n        enableBulkActions: context.enableBulkActions,\r\n        disableSelection: context.disableSelection,\r\n        onToggleNode: context.onToggleNode,\r\n        onNodeSelect: context.onNodeSelect,\r\n        setLastFocusedNodeId: context.setLastFocusedNodeId,\r\n        handleToggleChecked,\r\n      });\r\n    },\r\n    [\r\n      node,\r\n      hasChildren,\r\n      isExpanded,\r\n      isDisabled,\r\n      context.visibleNodeIds,\r\n      context.disabledNodesMap,\r\n      context.parentNodeMap,\r\n      context.focusableNodes,\r\n      context.enableBulkActions,\r\n      context.disableSelection,\r\n      context.onToggleNode,\r\n      context.onNodeSelect,\r\n      context.setLastFocusedNodeId,\r\n      handleToggleChecked,\r\n    ],\r\n  );\r\n\r\n  const paddingLeft =\r\n    depth *\r\n    (context.enableBulkActions ? INDENT_SIZE_WITH_CHECKBOX : INDENT_SIZE);\r\n\r\n  // Checkbox state management\r\n  const { allDescendantIds, localChildValues, handleLocalCheckboxChange } =\r\n    useTreeCheckboxState({\r\n      node,\r\n      hasChildren,\r\n      context,\r\n    });\r\n\r\n  // Render leaf node (no children)\r\n  if (!hasChildren) {\r\n    return (\r\n      <TreeContext.Provider value={mergedContextValue as TreeContextValue}>\r\n        <div className={cn(\"mt-0.5 first:mt-0\")}>\r\n          <div\r\n            className=\"group relative flex select-none\"\r\n            style={{ paddingLeft }}\r\n          >\r\n            {context.showLines && depth > 0 && (\r\n              <div\r\n                className=\"absolute top-0 bottom-0 left-0\"\r\n                style={{ left: paddingLeft - VERTICAL_LINE_OFFSET }}\r\n              >\r\n                <div className=\"bg-border h-full w-px\" />\r\n              </div>\r\n            )}\r\n            <div\r\n              className={cn(\r\n                \"flex flex-1 items-center gap-2 rounded-md px-2 py-1.5 text-sm transition-colors\",\r\n                \"hover:bg-accent\",\r\n                isSelected &&\r\n                  !context.disableSelection &&\r\n                  \"bg-accent text-accent-foreground\",\r\n                isDisabled && \"cursor-not-allowed opacity-50\",\r\n              )}\r\n            >\r\n              <div\r\n                ref={(el) => {\r\n                  if (el) {\r\n                    context.focusableNodes.current.set(node.id, el);\r\n                  } else {\r\n                    context.focusableNodes.current.delete(node.id);\r\n                  }\r\n                }}\r\n                className={cn(\r\n                  \"-my-1.5 flex flex-1 items-center gap-2 rounded-md px-2 py-1.5 transition-colors outline-none select-none\",\r\n                  \"-mx-2\",\r\n                  \"focus-visible:bg-accent focus-visible:ring-ring/50 focus-visible:ring-2\",\r\n                  !isDisabled && \"cursor-pointer\",\r\n                )}\r\n                onClick={handleClick}\r\n                onKeyDown={(e) => {\r\n                  if (e.key === \" \" || e.key === \"Enter\") {\r\n                    e.stopPropagation();\r\n                  }\r\n                  handleKeyDown(e);\r\n                }}\r\n                onFocus={() => {\r\n                  context.setLastFocusedNodeId(node.id);\r\n                }}\r\n                role=\"treeitem\"\r\n                aria-level={depth + 1}\r\n                aria-setsize={setSize}\r\n                aria-posinset={positionInSet}\r\n                aria-selected={\r\n                  context.enableBulkActions ? undefined : isSelected\r\n                }\r\n                aria-checked={context.enableBulkActions ? isChecked : undefined}\r\n                aria-disabled={isDisabled}\r\n                tabIndex={isDisabled ? -1 : isTabbable ? 0 : -1}\r\n              >\r\n                {context.enableBulkActions && (\r\n                  <Checkbox\r\n                    value={node.id}\r\n                    checked={isChecked}\r\n                    disabled={isDisabled}\r\n                    tabIndex={-1}\r\n                    className=\"pointer-events-none\"\r\n                  />\r\n                )}\r\n                {context.renderItem(node)}\r\n              </div>\r\n            </div>\r\n          </div>\r\n        </div>\r\n      </TreeContext.Provider>\r\n    );\r\n  }\r\n\r\n  // Render parent node (has children)\r\n\r\n  const parentContent = (\r\n    <TreeContext.Provider value={mergedContextValue as TreeContextValue}>\r\n      <div\r\n        role=\"treeitem\"\r\n        aria-expanded={isExpanded}\r\n        aria-level={depth + 1}\r\n        aria-setsize={setSize}\r\n        aria-posinset={positionInSet}\r\n        aria-selected={context.enableBulkActions ? undefined : isSelected}\r\n        aria-checked={context.enableBulkActions ? isChecked : undefined}\r\n        aria-disabled={isDisabled}\r\n        className={cn(\"mt-0.5 first:mt-0\")}\r\n      >\r\n        <BaseCollapsible.Root\r\n          open={isExpanded}\r\n          onOpenChange={() => !isDisabled && context.onToggleNode(node.id)}\r\n        >\r\n          <div\r\n            className=\"group relative flex select-none\"\r\n            style={{ paddingLeft }}\r\n          >\r\n            {context.showLines && depth > 0 && (\r\n              <div\r\n                className=\"absolute top-0 bottom-0 left-0\"\r\n                style={{ left: paddingLeft - VERTICAL_LINE_OFFSET }}\r\n              >\r\n                <div className=\"bg-border h-full w-px\" />\r\n              </div>\r\n            )}\r\n            <div\r\n              className={cn(\r\n                \"flex flex-1 items-center gap-2 rounded-md px-2 py-1.5 text-sm transition-colors\",\r\n                \"hover:bg-accent\",\r\n                isSelected &&\r\n                  !context.disableSelection &&\r\n                  \"bg-accent text-accent-foreground\",\r\n                isDisabled && \"cursor-not-allowed opacity-50\",\r\n              )}\r\n            >\r\n              {context.enableBulkActions ? (\r\n                // In bulk actions mode, use plain div to avoid Collapsible.Trigger keyboard handling\r\n                <div\r\n                  ref={(el) => {\r\n                    if (el) {\r\n                      context.focusableNodes.current.set(node.id, el);\r\n                    } else {\r\n                      context.focusableNodes.current.delete(node.id);\r\n                    }\r\n                  }}\r\n                  className={cn(\r\n                    \"group/trigger -mx-2 -my-1.5 flex flex-1 items-center gap-2 rounded-md border-0 bg-transparent px-2 py-1.5 text-left transition-colors outline-none select-none\",\r\n                    \"focus-visible:bg-accent focus-visible:ring-ring/50 focus-visible:ring-2\",\r\n                    !isDisabled && \"cursor-pointer\",\r\n                  )}\r\n                  onClick={() => {\r\n                    // Clicking node text/content expands/collapses\r\n                    if (!isDisabled) {\r\n                      context.onToggleNode(node.id);\r\n                    }\r\n                  }}\r\n                  onKeyDown={handleKeyDown}\r\n                  onFocus={() => {\r\n                    context.setLastFocusedNodeId(node.id);\r\n                  }}\r\n                  tabIndex={isDisabled ? -1 : isTabbable ? 0 : -1}\r\n                >\r\n                  <span\r\n                    onClick={(e: React.MouseEvent) => {\r\n                      // Clicking checkbox toggles checked state\r\n                      e.stopPropagation();\r\n                      handleToggleChecked();\r\n                    }}\r\n                  >\r\n                    <Checkbox\r\n                      parent\r\n                      disabled={isDisabled}\r\n                      tabIndex={-1}\r\n                      className=\"pointer-events-auto cursor-pointer\"\r\n                    />\r\n                  </span>\r\n                  <ChevronRightIcon\r\n                    aria-hidden=\"true\"\r\n                    className={cn(\r\n                      \"text-muted-foreground ease-out-cubic size-4 shrink-0 transition-transform duration-[325ms]\",\r\n                      isExpanded && \"rotate-90\",\r\n                      isDisabled && \"opacity-50\",\r\n                    )}\r\n                  />\r\n                  {context.renderItem(node)}\r\n                </div>\r\n              ) : (\r\n                // In navigation/selection mode, use Collapsible.Trigger for built-in behavior\r\n                <BaseCollapsible.Trigger\r\n                  ref={(el) => {\r\n                    if (el) {\r\n                      context.focusableNodes.current.set(node.id, el);\r\n                    } else {\r\n                      context.focusableNodes.current.delete(node.id);\r\n                    }\r\n                  }}\r\n                  className={cn(\r\n                    \"group/trigger -mx-2 -my-1.5 flex flex-1 items-center gap-2 rounded-md border-0 bg-transparent px-2 py-1.5 text-left transition-colors outline-none select-none\",\r\n                    \"focus-visible:bg-accent focus-visible:ring-ring/50 focus-visible:ring-2\",\r\n                    !isDisabled && \"cursor-pointer\",\r\n                  )}\r\n                  onClick={(e) => {\r\n                    if (!isDisabled && !context.disableSelection) {\r\n                      handleClick(e);\r\n                    }\r\n                  }}\r\n                  onKeyDown={handleKeyDown}\r\n                  onFocus={() => {\r\n                    context.setLastFocusedNodeId(node.id);\r\n                  }}\r\n                  disabled={isDisabled}\r\n                  tabIndex={isDisabled ? -1 : isTabbable ? 0 : -1}\r\n                >\r\n                  <ChevronRightIcon\r\n                    aria-hidden=\"true\"\r\n                    className={cn(\r\n                      \"text-muted-foreground ease-out-cubic size-4 shrink-0 transition-transform duration-[325ms]\",\r\n                      isExpanded && \"rotate-90\",\r\n                      isDisabled && \"opacity-50\",\r\n                    )}\r\n                  />\r\n                  {context.renderItem(node)}\r\n                </BaseCollapsible.Trigger>\r\n              )}\r\n            </div>\r\n          </div>\r\n\r\n          <BaseCollapsible.Panel\r\n            className={cn(\r\n              \"ease-out-cubic h-[var(--collapsible-panel-height)] overflow-y-clip transition-all duration-[325ms]\",\r\n              \"data-[ending-style]:h-0 data-[ending-style]:opacity-0\",\r\n              \"data-[starting-style]:h-0 data-[starting-style]:opacity-0\",\r\n            )}\r\n          >\r\n            {node.children && node.children.length > 0 && (\r\n              <div\r\n                className={cn(\r\n                  context.showLines && \"relative\",\r\n                  \"pt-0.5 pb-0.5 pl-0\",\r\n                )}\r\n              >\r\n                {context.showLines && (\r\n                  <div\r\n                    className=\"bg-border absolute top-0 bottom-0 w-px\"\r\n                    style={{ left: paddingLeft + CHILD_VERTICAL_LINE_OFFSET }}\r\n                  />\r\n                )}\r\n                {node.children.map((child, index) => (\r\n                  <TreeItemInternal\r\n                    key={child.id}\r\n                    node={child}\r\n                    depth={depth + 1}\r\n                    positionInSet={index + 1}\r\n                    setSize={node.children?.length}\r\n                  />\r\n                ))}\r\n              </div>\r\n            )}\r\n          </BaseCollapsible.Panel>\r\n        </BaseCollapsible.Root>\r\n      </div>\r\n    </TreeContext.Provider>\r\n  );\r\n\r\n  if (context.enableBulkActions) {\r\n    return (\r\n      <CheckboxGroup\r\n        value={localChildValues}\r\n        onValueChange={handleLocalCheckboxChange}\r\n        allValues={allDescendantIds}\r\n      >\r\n        {parentContent}\r\n      </CheckboxGroup>\r\n    );\r\n  }\r\n\r\n  return parentContent;\r\n}\r\n\r\n// ============================================================================\r\n// TreeItem Component (Public API)\r\n// ============================================================================\r\n\r\nexport interface TreeItemProps extends useRender.ComponentProps<\"div\"> {\r\n  children: React.ReactNode;\r\n}\r\n\r\nfunction TreeItem({ className, children, render, ...props }: TreeItemProps) {\r\n  const defaultProps = {\r\n    \"data-slot\": \"tree-item\",\r\n    className: cn(\"flex flex-1 items-center gap-2\", className),\r\n    children,\r\n  };\r\n\r\n  const element = useRender({\r\n    defaultTagName: \"div\",\r\n    render,\r\n    props: mergeProps<\"div\">(defaultProps, props),\r\n  });\r\n\r\n  return element;\r\n}\r\n\r\n// ============================================================================\r\n// TreeItemIcon Component\r\n// ============================================================================\r\n\r\nexport interface TreeItemIconProps extends useRender.ComponentProps<\"span\"> {\r\n  children?: React.ReactNode;\r\n}\r\n\r\nfunction TreeItemIcon({\r\n  children,\r\n  className,\r\n  render,\r\n  ...props\r\n}: TreeItemIconProps) {\r\n  const { item, isExpanded, isLoading } = useTreeItemContext();\r\n\r\n  // Show loading spinner if node is loading\r\n  let displayIcon: React.ReactNode;\r\n  if (isLoading) {\r\n    displayIcon = <Loader2Icon className=\"animate-spin\" />;\r\n  } else {\r\n    displayIcon =\r\n      isExpanded && \"iconOpen\" in item && item.iconOpen\r\n        ? item.iconOpen\r\n        : children;\r\n  }\r\n\r\n  const defaultProps = {\r\n    \"data-slot\": \"tree-item-icon\",\r\n    className: cn(\"text-muted-foreground shrink-0 [&>svg]:size-4\", className),\r\n    children: displayIcon,\r\n  };\r\n\r\n  const element = useRender({\r\n    defaultTagName: \"span\",\r\n    render,\r\n    props: mergeProps<\"span\">(defaultProps, props),\r\n  });\r\n\r\n  if (!displayIcon) return null;\r\n\r\n  return element;\r\n}\r\n\r\n// ============================================================================\r\n// TreeItemLabel Component\r\n// ============================================================================\r\n\r\nexport interface TreeItemLabelProps extends useRender.ComponentProps<\"span\"> {\r\n  children: React.ReactNode;\r\n}\r\n\r\nfunction TreeItemLabel({\r\n  children,\r\n  className,\r\n  render,\r\n  ...props\r\n}: TreeItemLabelProps) {\r\n  const defaultProps = {\r\n    \"data-slot\": \"tree-item-label\",\r\n    className: cn(\"truncate\", className),\r\n    children,\r\n  };\r\n\r\n  const element = useRender({\r\n    defaultTagName: \"span\",\r\n    render,\r\n    props: mergeProps<\"span\">(defaultProps, props),\r\n  });\r\n\r\n  if (!children) return null;\r\n\r\n  return element;\r\n}\r\n\r\n// ============================================================================\r\n// TreeItemBadge Component\r\n// ============================================================================\r\n\r\nexport interface TreeItemBadgeProps extends useRender.ComponentProps<\"span\"> {\r\n  children?: React.ReactNode;\r\n}\r\n\r\nfunction TreeItemBadge({\r\n  children,\r\n  className,\r\n  render,\r\n  ...props\r\n}: TreeItemBadgeProps) {\r\n  const defaultProps = {\r\n    \"data-slot\": \"tree-item-badge\",\r\n    className: cn(\r\n      \"ml-auto flex shrink-0 items-center\",\r\n      // Scale down badges to match tree text size and prevent height increase\r\n      `[&_[data-slot=badge]]:py-0.5 [&_[data-slot=badge]]:${BADGE_TEXT_SIZE} [&_[data-slot=badge]]:leading-tight`,\r\n      className,\r\n    ),\r\n    children,\r\n  };\r\n\r\n  const element = useRender({\r\n    defaultTagName: \"span\",\r\n    render,\r\n    props: mergeProps<\"span\">(defaultProps, props),\r\n  });\r\n\r\n  if (!children) return null;\r\n\r\n  return element;\r\n}\r\n\r\n// ============================================================================\r\n// Exports\r\n// ============================================================================\r\n\r\nexport {\r\n  Tree,\r\n  TreeItem,\r\n  TreeItemIcon,\r\n  TreeItemLabel,\r\n  TreeItemBadge,\r\n  type TreeVariant,\r\n  type TreeMode,\r\n};\r\n\r\n// Re-export tree utilities for consumers\r\nimport * as TreeUtils from \"./lib/tree-utils\";\r\nexport { TreeUtils };\r\n",
      "type": "registry:ui",
      "target": "components/ui/cubby-ui/tree/tree.tsx"
    },
    {
      "path": "registry/default/tree/lib/tree-utils.ts",
      "content": "import type { TreeNode } from \"../tree\";\n\n/**\n * Validate tree structure for circular references and duplicate IDs\n * @param nodes - The tree data array\n * @param seen - Set of IDs already seen (for internal use)\n * @throws Error if circular reference or duplicate ID is detected\n */\nexport function validateTreeStructure<\n  TData extends Record<string, unknown> = Record<string, unknown>,\n>(nodes: TreeNode<TData>[], seen = new Set<string>()): void {\n  const idsInLevel = new Set<string>();\n\n  for (const node of nodes) {\n    // Check for duplicate IDs\n    if (idsInLevel.has(node.id)) {\n      throw new Error(`Tree validation error: Duplicate node ID \"${node.id}\"`);\n    }\n    idsInLevel.add(node.id);\n\n    // Check for circular references\n    if (seen.has(node.id)) {\n      throw new Error(\n        `Tree validation error: Circular reference detected for node ID \"${node.id}\"`,\n      );\n    }\n\n    const newSeen = new Set(seen);\n    newSeen.add(node.id);\n\n    if (node.children && node.children.length > 0) {\n      validateTreeStructure(node.children, newSeen);\n    }\n  }\n}\n\n/**\n * Get all descendant IDs of a node (recursive)\n * @param node - The parent node\n * @returns Array of all descendant node IDs\n */\nexport function getAllDescendantIds<\n  TData extends Record<string, unknown> = Record<string, unknown>,\n>(node: TreeNode<TData>): string[] {\n  const ids: string[] = [];\n  if (node.children) {\n    for (const child of node.children) {\n      ids.push(child.id);\n      if (child.children && child.children.length > 0) {\n        ids.push(...getAllDescendantIds(child));\n      }\n    }\n  }\n  return ids;\n}\n\n/**\n * Get IDs of all leaf nodes (nodes without children)\n * @param nodes - Array of tree nodes\n * @returns Array of leaf node IDs\n */\nexport function getLeafNodeIds<\n  TData extends Record<string, unknown> = Record<string, unknown>,\n>(nodes: TreeNode<TData>[]): string[] {\n  const leafIds: string[] = [];\n  for (const node of nodes) {\n    if (!node.children || node.children.length === 0) {\n      leafIds.push(node.id);\n    } else {\n      leafIds.push(...getLeafNodeIds(node.children));\n    }\n  }\n  return leafIds;\n}\n\n/**\n * Build a map of child node IDs to their parent node IDs\n * @param nodes - The tree data array\n * @param parentMap - Map to populate (for internal use)\n * @param parentId - Current parent ID (for internal use)\n * @returns Map of child ID to parent ID\n */\nexport function buildParentMap<\n  TData extends Record<string, unknown> = Record<string, unknown>,\n>(\n  nodes: TreeNode<TData>[],\n  parentMap = new Map<string, string>(),\n  parentId?: string,\n): Map<string, string> {\n  for (const node of nodes) {\n    if (parentId) {\n      parentMap.set(node.id, parentId);\n    }\n    if (node.children) {\n      buildParentMap(node.children, parentMap, node.id);\n    }\n  }\n  return parentMap;\n}\n\n/**\n * Collect IDs of all visible nodes (including children of expanded nodes)\n * @param nodes - The tree data array\n * @param expandedNodes - Set of expanded node IDs\n * @param ids - Array to populate (for internal use)\n * @param disabledMap - Map to track disabled nodes (for internal use)\n * @returns Object with visible node IDs and disabled nodes map\n */\nexport function collectVisibleIds<\n  TData extends Record<string, unknown> = Record<string, unknown>,\n>(\n  nodes: TreeNode<TData>[],\n  expandedNodes: Set<string>,\n  ids: string[] = [],\n  disabledMap = new Map<string, boolean>(),\n): { visibleNodeIds: string[]; disabledNodesMap: Map<string, boolean> } {\n  for (const node of nodes) {\n    ids.push(node.id);\n    if (node.disabled) {\n      disabledMap.set(node.id, true);\n    }\n    if (node.children && expandedNodes.has(node.id)) {\n      collectVisibleIds(node.children, expandedNodes, ids, disabledMap);\n    }\n  }\n  return { visibleNodeIds: ids, disabledNodesMap: disabledMap };\n}\n\n/**\n * Handle keyboard navigation for tree nodes\n * @param e - Keyboard event\n * @param params - Navigation parameters\n */\nexport function handleTreeKeyboardNavigation<\n  TData extends Record<string, unknown> = Record<string, unknown>,\n>(\n  e: React.KeyboardEvent,\n  params: {\n    nodeId: string;\n    hasChildren: boolean;\n    isExpanded: boolean;\n    isDisabled: boolean;\n    node: TreeNode<TData>;\n    visibleNodeIds: string[];\n    disabledNodesMap: Map<string, boolean>;\n    parentNodeMap: Map<string, string>;\n    focusableNodes: Map<string, HTMLElement>;\n    enableBulkActions: boolean;\n    disableSelection: boolean;\n    onToggleNode: (nodeId: string) => void;\n    onNodeSelect?: (nodeId: string) => void;\n    setLastFocusedNodeId: (nodeId: string | null) => void;\n    handleToggleChecked: () => void;\n  },\n): void {\n  const {\n    nodeId,\n    hasChildren,\n    isExpanded,\n    isDisabled,\n    node,\n    visibleNodeIds,\n    disabledNodesMap,\n    parentNodeMap,\n    focusableNodes,\n    enableBulkActions,\n    disableSelection,\n    onToggleNode,\n    onNodeSelect,\n    setLastFocusedNodeId,\n    handleToggleChecked,\n  } = params;\n\n  if (isDisabled) return;\n\n  const currentIndex = visibleNodeIds.indexOf(nodeId);\n\n  switch (e.key) {\n    case \" \":\n      e.preventDefault();\n      e.stopPropagation();\n      if (enableBulkActions) {\n        handleToggleChecked();\n      } else {\n        if (hasChildren) {\n          onToggleNode(nodeId);\n        }\n        if (!disableSelection) {\n          onNodeSelect?.(nodeId);\n        }\n      }\n      break;\n\n    case \"Enter\":\n      e.preventDefault();\n      e.stopPropagation();\n      if (enableBulkActions) {\n        if (hasChildren) {\n          onToggleNode(nodeId);\n        } else {\n          handleToggleChecked();\n        }\n      } else {\n        if (hasChildren) {\n          onToggleNode(nodeId);\n        }\n        if (!disableSelection) {\n          onNodeSelect?.(nodeId);\n        }\n      }\n      break;\n\n    case \"ArrowRight\":\n      e.preventDefault();\n      if (hasChildren) {\n        if (!isExpanded) {\n          onToggleNode(nodeId);\n        } else {\n          const firstChildId = node.children?.[0]?.id;\n          if (firstChildId && !disabledNodesMap.has(firstChildId)) {\n            const firstChildElement = focusableNodes.get(firstChildId);\n            if (firstChildElement) {\n              firstChildElement.focus();\n              setLastFocusedNodeId(firstChildId);\n            }\n          }\n        }\n      }\n      break;\n\n    case \"ArrowLeft\":\n      e.preventDefault();\n      if (hasChildren && isExpanded) {\n        onToggleNode(nodeId);\n      } else {\n        const parentId = parentNodeMap.get(nodeId);\n        if (parentId) {\n          const parentElement = focusableNodes.get(parentId);\n          if (parentElement) {\n            parentElement.focus();\n            setLastFocusedNodeId(parentId);\n          }\n        }\n      }\n      break;\n\n    case \"ArrowDown\": {\n      e.preventDefault();\n      let nextIndex = currentIndex + 1;\n      while (nextIndex < visibleNodeIds.length) {\n        const nextId = visibleNodeIds[nextIndex];\n        if (disabledNodesMap.has(nextId)) {\n          nextIndex++;\n          continue;\n        }\n        const nextElement = focusableNodes.get(nextId);\n        if (nextElement) {\n          nextElement.focus();\n          setLastFocusedNodeId(nextId);\n          break;\n        }\n        nextIndex++;\n      }\n      break;\n    }\n\n    case \"ArrowUp\": {\n      e.preventDefault();\n      let prevIndex = currentIndex - 1;\n      while (prevIndex >= 0) {\n        const prevId = visibleNodeIds[prevIndex];\n        if (disabledNodesMap.has(prevId)) {\n          prevIndex--;\n          continue;\n        }\n        const prevElement = focusableNodes.get(prevId);\n        if (prevElement) {\n          prevElement.focus();\n          setLastFocusedNodeId(prevId);\n          break;\n        }\n        prevIndex--;\n      }\n      break;\n    }\n\n    case \"Home\": {\n      e.preventDefault();\n      for (let i = 0; i < visibleNodeIds.length; i++) {\n        const firstId = visibleNodeIds[i];\n        if (disabledNodesMap.has(firstId)) continue;\n        const firstElement = focusableNodes.get(firstId);\n        if (firstElement) {\n          firstElement.focus();\n          setLastFocusedNodeId(firstId);\n          break;\n        }\n      }\n      break;\n    }\n\n    case \"End\": {\n      e.preventDefault();\n      for (let i = visibleNodeIds.length - 1; i >= 0; i--) {\n        const lastId = visibleNodeIds[i];\n        if (disabledNodesMap.has(lastId)) continue;\n        const lastElement = focusableNodes.get(lastId);\n        if (lastElement) {\n          lastElement.focus();\n          setLastFocusedNodeId(lastId);\n          break;\n        }\n      }\n      break;\n    }\n  }\n}\n",
      "type": "registry:lib",
      "target": "components/ui/cubby-ui/tree/lib/tree-utils.ts"
    }
  ]
}