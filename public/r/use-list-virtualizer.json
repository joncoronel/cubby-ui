{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "use-list-virtualizer",
  "type": "registry:hook",
  "title": "useListVirtualizer",
  "description": "A custom React hook for list virtualizer.",
  "dependencies": [
    "@tanstack/react-virtual"
  ],
  "files": [
    {
      "path": "registry/default/hooks/use-list-virtualizer.ts",
      "content": "import * as React from \"react\";\r\nimport { useVirtualizer, type VirtualItem } from \"@tanstack/react-virtual\";\r\n\r\nexport interface UseListVirtualizerOptions<T> {\r\n  /**\r\n   * Whether virtualization is enabled.\r\n   * Typically tied to whether the list container is open/visible.\r\n   * @default true\r\n   */\r\n  enabled?: boolean;\r\n\r\n  /**\r\n   * All items in the list (unfiltered).\r\n   * Used by Base UI Autocomplete for proper aria-setsize.\r\n   */\r\n  items: T[];\r\n\r\n  /**\r\n   * The filtered items to display.\r\n   * Can be the same as `items` if no filtering is applied (e.g., server-side filtering).\r\n   */\r\n  filteredItems: T[];\r\n\r\n  /**\r\n   * Estimated height of each item in pixels, or a function that returns\r\n   * the estimate for each item. Used for initial layout before measurement.\r\n   * @default 40\r\n   */\r\n  estimateSize?: number | ((index: number, item: T) => number);\r\n\r\n  /**\r\n   * Number of items to render outside the visible area.\r\n   * Higher values = smoother scrolling, more memory.\r\n   * @default 20\r\n   */\r\n  overscan?: number;\r\n\r\n  /**\r\n   * Padding at the start of the list in pixels.\r\n   * Should match the list container's padding.\r\n   * @default 8\r\n   */\r\n  paddingStart?: number;\r\n\r\n  /**\r\n   * Padding at the end of the list in pixels.\r\n   * @default 8\r\n   */\r\n  paddingEnd?: number;\r\n}\r\n\r\nexport interface UseListVirtualizerReturn<T> {\r\n  /**\r\n   * Props to spread on the root component (Autocomplete.Root).\r\n   * Includes: virtualized, items, filteredItems, onItemHighlighted\r\n   */\r\n  rootProps: {\r\n    virtualized: true;\r\n    items: T[];\r\n    filteredItems: T[];\r\n    onItemHighlighted: (\r\n      item: T | null | undefined,\r\n      details: { reason: \"none\" | \"keyboard\" | \"pointer\"; index: number }\r\n    ) => void;\r\n  };\r\n\r\n  /**\r\n   * Ref callback for the scroll container element.\r\n   * Attach to a div wrapping the virtual items.\r\n   */\r\n  scrollRef: (element: HTMLDivElement | null) => void;\r\n\r\n  /**\r\n   * Ref callback for measuring individual items.\r\n   * Attach to each list item for dynamic height support.\r\n   */\r\n  measureRef: (element: HTMLDivElement | null) => void;\r\n\r\n  /**\r\n   * Total height of all virtual items in pixels.\r\n   * Use for the height of the placeholder container.\r\n   */\r\n  totalSize: number;\r\n\r\n  /**\r\n   * Array of virtual items to render.\r\n   * Each contains: key, index, start, size\r\n   */\r\n  virtualItems: VirtualItem[];\r\n\r\n  /**\r\n   * Get the item at a virtual index.\r\n   * Convenience method: filteredItems[virtualItem.index]\r\n   */\r\n  getItem: (virtualItem: { index: number }) => T | undefined;\r\n\r\n  /**\r\n   * Get inline styles for a virtual item.\r\n   * Returns: { position, top, left, right, transform }\r\n   */\r\n  getItemStyle: (virtualItem: { start: number }) => React.CSSProperties;\r\n\r\n  /**\r\n   * Get aria attributes and props for a virtual item.\r\n   * Returns: { 'aria-setsize', 'aria-posinset', 'data-index', index }\r\n   */\r\n  getItemProps: (virtualItem: { index: number }) => {\r\n    \"aria-setsize\": number;\r\n    \"aria-posinset\": number;\r\n    \"data-index\": number;\r\n    index: number;\r\n  };\r\n}\r\n\r\nexport function useListVirtualizer<T>(\r\n  options: UseListVirtualizerOptions<T>\r\n): UseListVirtualizerReturn<T> {\r\n  const {\r\n    enabled: _enabled = true,\r\n    items,\r\n    filteredItems,\r\n    estimateSize = 40,\r\n    overscan = 20,\r\n    paddingStart = 8,\r\n    paddingEnd = 8,\r\n  } = options;\r\n\r\n  const scrollElementRef = React.useRef<HTMLDivElement | null>(null);\r\n\r\n  const virtualizer = useVirtualizer({\r\n    // Don't pass `enabled` to virtualizer - let it always calculate sizes\r\n    // to prevent height jumping during close animation\r\n    count: filteredItems.length,\r\n    getScrollElement: () => scrollElementRef.current,\r\n    estimateSize:\r\n      typeof estimateSize === \"function\"\r\n        ? (index) => estimateSize(index, filteredItems[index])\r\n        : () => estimateSize,\r\n    overscan,\r\n    paddingStart,\r\n    paddingEnd,\r\n    scrollPaddingStart: paddingStart,\r\n    scrollPaddingEnd: paddingEnd,\r\n  });\r\n\r\n  // Ref callback that stores the element and triggers measurement\r\n  const scrollRef = React.useCallback(\r\n    (element: HTMLDivElement | null) => {\r\n      scrollElementRef.current = element;\r\n      if (element) {\r\n        virtualizer.measure();\r\n      }\r\n    },\r\n    [virtualizer]\r\n  );\r\n\r\n  // Handler for keyboard/pointer navigation scroll-to-index\r\n  const onItemHighlighted = React.useCallback(\r\n    (\r\n      item: T | null | undefined,\r\n      {\r\n        reason,\r\n        index,\r\n      }: { reason: \"none\" | \"keyboard\" | \"pointer\"; index: number }\r\n    ) => {\r\n      if (item == null) return;\r\n\r\n      const isStart = index === 0;\r\n      const isEnd = index === filteredItems.length - 1;\r\n\r\n      // Scroll on initial highlight or keyboard navigation at edges\r\n      const shouldScroll =\r\n        reason === \"none\" || (reason === \"keyboard\" && (isStart || isEnd));\r\n\r\n      if (shouldScroll) {\r\n        queueMicrotask(() => {\r\n          virtualizer.scrollToIndex(index, {\r\n            align: isEnd ? \"start\" : \"end\",\r\n          });\r\n        });\r\n      }\r\n    },\r\n    [filteredItems.length, virtualizer]\r\n  );\r\n\r\n  const getItem = React.useCallback(\r\n    (virtualItem: { index: number }) => filteredItems[virtualItem.index],\r\n    [filteredItems]\r\n  );\r\n\r\n  const getItemStyle = React.useCallback(\r\n    (virtualItem: { start: number }): React.CSSProperties => ({\r\n      position: \"absolute\",\r\n      top: 0,\r\n      left: 0,\r\n      right: 0, // Use right: 0 instead of width: 100% so margins work correctly\r\n      // No explicit height - let content determine size for dynamic measurement\r\n      transform: `translateY(${virtualItem.start}px)`,\r\n    }),\r\n    []\r\n  );\r\n\r\n  const getItemProps = React.useCallback(\r\n    (virtualItem: { index: number }) => ({\r\n      \"aria-setsize\": filteredItems.length,\r\n      \"aria-posinset\": virtualItem.index + 1,\r\n      \"data-index\": virtualItem.index,\r\n      index: virtualItem.index,\r\n    }),\r\n    [filteredItems.length]\r\n  );\r\n\r\n  return {\r\n    rootProps: {\r\n      virtualized: true,\r\n      items,\r\n      filteredItems,\r\n      onItemHighlighted,\r\n    },\r\n    scrollRef,\r\n    measureRef: virtualizer.measureElement as (\r\n      element: HTMLDivElement | null\r\n    ) => void,\r\n    totalSize: filteredItems.length > 0 ? virtualizer.getTotalSize() : 0,\r\n    virtualItems: virtualizer.getVirtualItems(),\r\n    getItem,\r\n    getItemStyle,\r\n    getItemProps,\r\n  };\r\n}\r\n",
      "type": "registry:hook",
      "target": "hooks/cubby-ui/use-list-virtualizer.ts"
    }
  ]
}