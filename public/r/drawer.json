{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "drawer",
  "type": "registry:ui",
  "title": "Drawer",
  "description": "A drawer component.",
  "dependencies": [
    "class-variance-authority"
  ],
  "registryDependencies": [
    "@cubby-ui/scroll-area"
  ],
  "files": [
    {
      "path": "registry/default/drawer/drawer.tsx",
      "content": "\"use client\";\r\n\r\nimport * as React from \"react\";\r\nimport { Dialog as BaseDialog } from \"@base-ui/react/dialog\";\r\nimport { mergeProps } from \"@base-ui/react/merge-props\";\r\nimport { useRender } from \"@base-ui/react/use-render\";\r\nimport { cva } from \"class-variance-authority\";\r\n\r\nimport { cn } from \"@/lib/utils\";\r\nimport {\r\n  ScrollArea,\r\n  type ScrollAreaProps,\r\n} from \"@/registry/default/scroll-area/scroll-area\";\r\n\r\n// Drawer-specific CSS animations (scroll-driven animations for progressive enhancement)\r\nimport \"./drawer.css\";\r\n\r\nimport type { SnapPoint, DrawerDirection } from \"./lib/drawer-utils\";\r\nimport {\r\n  DIRECTION_CONFIG,\r\n  parsePixelValue,\r\n  findSnapPointIndex,\r\n  getSnapPointValue,\r\n  snapPointToRatio,\r\n  supportsScrollTimeline,\r\n  supportsScrollState,\r\n} from \"./lib/drawer-utils\";\r\nimport { useScrollSnap } from \"./hooks/use-scroll-snap\";\r\nimport { useVirtualKeyboard } from \"./hooks/use-virtual-keyboard\";\r\nimport { useVisualViewportHeight } from \"./hooks/use-visual-viewport-height\";\r\n\r\nexport type { SnapPoint, DrawerDirection };\r\n\r\nconst createDrawerHandle = BaseDialog.createHandle;\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * CVA Variants\r\n * -------------------------------------------------------------------------------------------------*/\r\n\r\nconst drawerContentVariants = cva(\r\n  [\r\n    \"bg-popover text-popover-foreground flex flex-col\",\r\n    \"relative \",\r\n    \"ease-[cubic-bezier(0, 0, 0.58, 1)] transition-transform duration-300 will-change-transform\",\r\n    \"motion-reduce:transition-none\",\r\n  ],\r\n  {\r\n    variants: {\r\n      variant: {\r\n        default: \"\",\r\n        floating: [\r\n          \"m-4 rounded-2xl\",\r\n          \"ring-border ring-1\",\r\n          \"shadow-[0_16px_32px_0_oklch(0.18_0_0/0.16)]\",\r\n        ],\r\n      },\r\n      direction: {\r\n        bottom: \"\",\r\n        top: \"\",\r\n        right: \"\",\r\n        left: \"\",\r\n      },\r\n    },\r\n    compoundVariants: [\r\n      // Default variant - direction-specific sizing and rounding\r\n      {\r\n        variant: \"default\",\r\n        direction: \"bottom\",\r\n        class:\r\n          \"mx-auto max-h-[95dvh] w-full max-w-full rounded-t-xl [&[data-starting-style]]:translate-y-[var(--drawer-offset)] [&[data-ending-style]]:translate-y-[var(--drawer-offset)]\",\r\n      },\r\n      {\r\n        variant: \"default\",\r\n        direction: \"top\",\r\n        class:\r\n          \"mx-auto max-h-[95dvh] w-full max-w-full rounded-b-xl [&[data-starting-style]]:-translate-y-[var(--drawer-offset)] [&[data-ending-style]]:-translate-y-[var(--drawer-offset)]\",\r\n      },\r\n      {\r\n        variant: \"default\",\r\n        direction: \"right\",\r\n        class:\r\n          \"max-w-screen w-screen rounded-l-xl sm:max-w-sm [&[data-starting-style]]:translate-x-[var(--drawer-offset)] [&[data-ending-style]]:translate-x-[var(--drawer-offset)]\",\r\n      },\r\n      {\r\n        variant: \"default\",\r\n        direction: \"left\",\r\n        class:\r\n          \"max-w-screen w-screen  rounded-r-xl sm:max-w-sm [&[data-starting-style]]:-translate-x-[var(--drawer-offset)] [&[data-ending-style]]:-translate-x-[var(--drawer-offset)]\",\r\n      },\r\n      // Floating variant - direction-specific sizing and transforms\r\n      {\r\n        variant: \"floating\",\r\n        direction: \"bottom\",\r\n        class:\r\n          \"mx-auto max-h-[calc(100dvh-2rem)] w-[calc(100%-2rem)] max-w-[calc(100%-2rem)] [&[data-starting-style]]:translate-y-[var(--drawer-offset)] [&[data-ending-style]]:translate-y-[var(--drawer-offset)]\",\r\n      },\r\n      {\r\n        variant: \"floating\",\r\n        direction: \"top\",\r\n        class:\r\n          \"mx-auto max-h-[calc(100dvh-2rem)] w-[calc(100%-2rem)] max-w-[calc(100%-2rem)] [&[data-starting-style]]:-translate-y-[var(--drawer-offset)] [&[data-ending-style]]:-translate-y-[var(--drawer-offset)]\",\r\n      },\r\n      {\r\n        variant: \"floating\",\r\n        direction: \"right\",\r\n        class:\r\n          \"h-[calc(100dvh-2rem)] w-[calc(100vw-2rem)] max-w-[calc(100vw-2rem)] sm:max-w-sm [&[data-starting-style]]:translate-x-[var(--drawer-offset)] [&[data-ending-style]]:translate-x-[var(--drawer-offset)]\",\r\n      },\r\n      {\r\n        variant: \"floating\",\r\n        direction: \"left\",\r\n        class:\r\n          \"h-[calc(100dvh-2rem)] w-[calc(100vw-2rem)] max-w-[calc(100vw-2rem)] sm:max-w-sm [&[data-starting-style]]:-translate-x-[var(--drawer-offset)] [&[data-ending-style]]:-translate-x-[var(--drawer-offset)]\",\r\n      },\r\n    ],\r\n    defaultVariants: {\r\n      variant: \"default\",\r\n      direction: \"bottom\",\r\n    },\r\n  },\r\n);\r\n\r\nconst drawerTrackVariants = cva(\"pointer-events-none relative flex\", {\r\n  variants: {\r\n    direction: {\r\n      bottom: \"w-full flex-col justify-end\",\r\n      top: \"w-full flex-col justify-start\",\r\n      right: \"h-full flex-row justify-end\",\r\n      left: \"h-full flex-row justify-start\",\r\n    },\r\n  },\r\n  defaultVariants: {\r\n    direction: \"bottom\",\r\n  },\r\n});\r\n\r\n// iOS 26 Safari: Fixed elements for nav bar color detection (must be within 3px of edge, ≥80% wide, ≥3px tall)\r\nconst SafariNavColorDetectors = (\r\n  <>\r\n    <div\r\n      aria-hidden=\"true\"\r\n      className=\"bg-popover pointer-events-none fixed inset-x-0 bottom-0 hidden h-10 bg-clip-text [@supports(-webkit-touch-callout:none)]:block\"\r\n    />\r\n    <div\r\n      aria-hidden=\"true\"\r\n      className=\"bg-popover pointer-events-none fixed inset-x-0 top-0 hidden h-10 bg-clip-text [@supports(-webkit-touch-callout:none)]:block\"\r\n    />\r\n  </>\r\n);\r\n\r\n// Scroll-driven backdrop animation styles per direction\r\nconst backdropAnimationStyles: Record<DrawerDirection, string> = {\r\n  bottom:\r\n    \"fill-mode-[both] [animation-name:drawer-backdrop-fade] [animation-range:entry_0%_entry_100%] [animation-timeline:--drawer-panel] [animation-timing-function:linear]\",\r\n  right:\r\n    \"fill-mode-[both] [animation-name:drawer-backdrop-fade] [animation-range:entry_0%_entry_100%] [animation-timeline:--drawer-panel] [animation-timing-function:linear]\",\r\n  top: \"fill-mode-[both] direction-[reverse] [animation-name:drawer-backdrop-fade] [animation-range:exit_0%_exit_100%] [animation-timeline:--drawer-panel] [animation-timing-function:linear]\",\r\n  left: \"fill-mode-[both] direction-[reverse] [animation-name:drawer-backdrop-fade] [animation-range:exit_0%_exit_100%] [animation-timeline:--drawer-panel] [animation-timing-function:linear]\",\r\n};\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * Drawer Context\r\n * -------------------------------------------------------------------------------------------------*/\r\n\r\ntype DrawerVariant = \"default\" | \"floating\";\r\n\r\ninterface DrawerConfigContextValue {\r\n  direction: DrawerDirection;\r\n  variant: DrawerVariant;\r\n  snapPoints: SnapPoint[];\r\n  dismissible: boolean;\r\n  modal: boolean | \"trap-focus\";\r\n  isVertical: boolean;\r\n  sequentialSnap: boolean;\r\n  repositionInputs: boolean;\r\n}\r\n\r\ninterface DrawerAnimationContextValue {\r\n  isDragging: boolean;\r\n  setIsDragging: (dragging: boolean) => void;\r\n  dragProgress: number;\r\n  setDragProgress: (progress: number) => void;\r\n  snapProgress: number;\r\n  setSnapProgress: (progress: number) => void;\r\n  activeSnapPoint: SnapPoint;\r\n  setActiveSnapPoint: (snapPoint: SnapPoint) => void;\r\n  open: boolean;\r\n  onOpenChange: (open: boolean, eventDetails?: { reason?: string }) => void;\r\n  contentSize: number | null;\r\n  setContentSize: (size: number | null) => void;\r\n  isAnimating: boolean;\r\n  immediateClose: boolean;\r\n  setImmediateClose: (value: boolean) => void;\r\n}\r\n\r\nconst DrawerConfigContext =\r\n  React.createContext<DrawerConfigContextValue | null>(null);\r\nconst DrawerAnimationContext =\r\n  React.createContext<DrawerAnimationContextValue | null>(null);\r\n\r\nfunction useDrawerConfig() {\r\n  const context = React.useContext(DrawerConfigContext);\r\n  if (!context) {\r\n    throw new Error(\"Drawer components must be used within a <Drawer />\");\r\n  }\r\n  return context;\r\n}\r\n\r\nfunction useDrawerAnimation() {\r\n  const context = React.useContext(DrawerAnimationContext);\r\n  if (!context) {\r\n    throw new Error(\"Drawer components must be used within a <Drawer />\");\r\n  }\r\n  return context;\r\n}\r\n\r\nfunction useDrawer() {\r\n  return { ...useDrawerConfig(), ...useDrawerAnimation() };\r\n}\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * Drawer (Root)\r\n * -------------------------------------------------------------------------------------------------*/\r\n\r\ninterface DrawerRenderProps {\r\n  /** 0 = first snap, 1 = last snap */\r\n  snapProgress: number;\r\n  /** 0 = open, 1 = closed */\r\n  dragProgress: number;\r\n  isDragging: boolean;\r\n  activeSnapPoint: SnapPoint;\r\n}\r\n\r\ninterface DrawerProps extends Omit<\r\n  React.ComponentProps<typeof BaseDialog.Root>,\r\n  \"children\"\r\n> {\r\n  direction?: DrawerDirection;\r\n  variant?: DrawerVariant;\r\n  /** Percentages (0-1) or pixel strings (e.g., \"200px\") */\r\n  snapPoints?: SnapPoint[];\r\n  defaultSnapPoint?: SnapPoint;\r\n  activeSnapPoint?: SnapPoint | null;\r\n  onActiveSnapPointChange?: (snapPoint: SnapPoint) => void;\r\n  dismissible?: boolean;\r\n  /** `true` = modal, `\"trap-focus\"` = focus trapped but no scroll lock, `false` = non-modal */\r\n  modal?: boolean | \"trap-focus\";\r\n  /** Prevents skipping snap points during fast swipes */\r\n  sequentialSnap?: boolean;\r\n  /** Repositions drawer when virtual keyboard appears (bottom only) */\r\n  repositionInputs?: boolean;\r\n  children?: React.ReactNode | ((props: DrawerRenderProps) => React.ReactNode);\r\n}\r\n\r\nfunction Drawer({\r\n  direction = \"bottom\",\r\n  variant = \"default\",\r\n  snapPoints = [1],\r\n  defaultSnapPoint,\r\n  activeSnapPoint: controlledSnapPoint,\r\n  onActiveSnapPointChange,\r\n  dismissible = true,\r\n  modal = true,\r\n  sequentialSnap = false,\r\n  repositionInputs = false,\r\n  open: controlledOpen,\r\n  defaultOpen,\r\n  onOpenChange: controlledOnOpenChange,\r\n  children,\r\n  ...props\r\n}: DrawerProps) {\r\n  const [uncontrolledOpen, setUncontrolledOpen] = React.useState(\r\n    defaultOpen ?? false,\r\n  );\r\n  const isOpenControlled = controlledOpen !== undefined;\r\n  const open = isOpenControlled ? controlledOpen : uncontrolledOpen;\r\n\r\n  const defaultSnapPointIndex =\r\n    defaultSnapPoint !== undefined\r\n      ? findSnapPointIndex(snapPoints, defaultSnapPoint)\r\n      : 0;\r\n\r\n  const [internalSnapPointIndex, setInternalSnapPointIndex] = React.useState(\r\n    defaultSnapPointIndex,\r\n  );\r\n\r\n  const isSnapPointControlled = controlledSnapPoint !== undefined;\r\n  const activeSnapPointIndex = isSnapPointControlled\r\n    ? findSnapPointIndex(snapPoints, controlledSnapPoint)\r\n    : internalSnapPointIndex;\r\n\r\n  const activeSnapPointValue = getSnapPointValue(\r\n    snapPoints,\r\n    activeSnapPointIndex,\r\n  );\r\n\r\n  const [isDragging, setIsDragging] = React.useState(false);\r\n  const [dragProgress, setDragProgress] = React.useState(1);\r\n  const [snapProgress, setSnapProgress] = React.useState(0);\r\n  const [contentSize, setContentSize] = React.useState<number | null>(null);\r\n  const [isAnimating, setIsAnimating] = React.useState(false);\r\n  const [immediateClose, setImmediateClose] = React.useState(false);\r\n\r\n  const { isVertical } = DIRECTION_CONFIG[direction];\r\n\r\n  const handleOpenChangeComplete = React.useCallback(() => {\r\n    setIsAnimating(false);\r\n  }, []);\r\n\r\n  const handleOpenChange = React.useCallback(\r\n    (nextOpen: boolean, eventDetails?: { reason?: string }) => {\r\n      // Prevent closing while scrolling, but allow explicit swipe dismiss\r\n      if (!nextOpen && isDragging && eventDetails?.reason !== \"swipe-dismiss\") {\r\n        return;\r\n      }\r\n\r\n      setIsAnimating(true);\r\n\r\n      if (!isOpenControlled) {\r\n        setUncontrolledOpen(nextOpen);\r\n      }\r\n      controlledOnOpenChange?.(nextOpen, eventDetails as never);\r\n\r\n      if (nextOpen && !isSnapPointControlled) {\r\n        setInternalSnapPointIndex(defaultSnapPointIndex);\r\n        const defaultSnapValue = getSnapPointValue(\r\n          snapPoints,\r\n          defaultSnapPointIndex,\r\n        );\r\n        onActiveSnapPointChange?.(defaultSnapValue);\r\n      }\r\n\r\n      if (nextOpen) {\r\n        setDragProgress(1);\r\n        setIsDragging(false);\r\n        setImmediateClose(false);\r\n        if (!isSnapPointControlled) {\r\n          const progress =\r\n            snapPoints.length > 1\r\n              ? defaultSnapPointIndex / (snapPoints.length - 1)\r\n              : 0;\r\n          setSnapProgress(progress);\r\n        }\r\n      }\r\n    },\r\n    [\r\n      isDragging,\r\n      isOpenControlled,\r\n      controlledOnOpenChange,\r\n      snapPoints,\r\n      isSnapPointControlled,\r\n      onActiveSnapPointChange,\r\n      defaultSnapPointIndex,\r\n    ],\r\n  );\r\n\r\n  const setActiveSnapPoint = React.useCallback(\r\n    (value: SnapPoint) => {\r\n      const index = findSnapPointIndex(snapPoints, value);\r\n      if (!isSnapPointControlled) {\r\n        setInternalSnapPointIndex(index);\r\n      }\r\n      onActiveSnapPointChange?.(value);\r\n    },\r\n    [snapPoints, isSnapPointControlled, onActiveSnapPointChange],\r\n  );\r\n\r\n  const configValue = React.useMemo(\r\n    () => ({\r\n      direction,\r\n      variant,\r\n      snapPoints,\r\n      dismissible,\r\n      modal,\r\n      isVertical,\r\n      sequentialSnap,\r\n      repositionInputs,\r\n    }),\r\n    [\r\n      direction,\r\n      variant,\r\n      snapPoints,\r\n      dismissible,\r\n      modal,\r\n      isVertical,\r\n      sequentialSnap,\r\n      repositionInputs,\r\n    ],\r\n  );\r\n\r\n  const animationValue = React.useMemo(\r\n    () => ({\r\n      isDragging,\r\n      setIsDragging,\r\n      dragProgress,\r\n      setDragProgress,\r\n      snapProgress,\r\n      setSnapProgress,\r\n      activeSnapPoint: activeSnapPointValue,\r\n      setActiveSnapPoint,\r\n      open,\r\n      onOpenChange: handleOpenChange,\r\n      contentSize,\r\n      setContentSize,\r\n      isAnimating,\r\n      immediateClose,\r\n      setImmediateClose,\r\n    }),\r\n    [\r\n      isDragging,\r\n      dragProgress,\r\n      snapProgress,\r\n      activeSnapPointValue,\r\n      setActiveSnapPoint,\r\n      open,\r\n      handleOpenChange,\r\n      contentSize,\r\n      isAnimating,\r\n      immediateClose,\r\n    ],\r\n  );\r\n\r\n  const resolvedChildren =\r\n    typeof children === \"function\"\r\n      ? children({\r\n          snapProgress,\r\n          dragProgress,\r\n          isDragging,\r\n          activeSnapPoint: activeSnapPointValue,\r\n        })\r\n      : children;\r\n\r\n  return (\r\n    <DrawerConfigContext.Provider value={configValue}>\r\n      <DrawerAnimationContext.Provider value={animationValue}>\r\n        <BaseDialog.Root\r\n          data-slot=\"drawer\"\r\n          open={open}\r\n          onOpenChange={handleOpenChange}\r\n          onOpenChangeComplete={handleOpenChangeComplete}\r\n          modal={modal}\r\n          disablePointerDismissal={isAnimating || modal !== true}\r\n          {...props}\r\n        >\r\n          {resolvedChildren}\r\n        </BaseDialog.Root>\r\n      </DrawerAnimationContext.Provider>\r\n    </DrawerConfigContext.Provider>\r\n  );\r\n}\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * DrawerTrigger\r\n * -------------------------------------------------------------------------------------------------*/\r\n\r\nfunction DrawerTrigger({\r\n  ...props\r\n}: React.ComponentProps<typeof BaseDialog.Trigger>) {\r\n  return <BaseDialog.Trigger data-slot=\"drawer-trigger\" {...props} />;\r\n}\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * DrawerClose\r\n * -------------------------------------------------------------------------------------------------*/\r\n\r\ninterface DrawerCloseProps extends useRender.ComponentProps<\"button\"> {\r\n  onClick?: (event: React.MouseEvent) => void;\r\n}\r\n\r\nfunction DrawerClose({\r\n  onClick,\r\n  className,\r\n  render,\r\n  ...props\r\n}: DrawerCloseProps) {\r\n  const { onOpenChange, isAnimating } = useDrawerAnimation();\r\n\r\n  const handleClick = React.useCallback(\r\n    (event: React.MouseEvent) => {\r\n      onClick?.(event);\r\n      if (event.defaultPrevented) return;\r\n      if (isAnimating) return;\r\n      onOpenChange(false);\r\n    },\r\n    [onClick, onOpenChange, isAnimating],\r\n  );\r\n\r\n  const defaultProps = {\r\n    \"data-slot\": \"drawer-close\",\r\n    type: \"button\" as const,\r\n    className,\r\n    onClick: handleClick,\r\n  };\r\n\r\n  const element = useRender({\r\n    defaultTagName: \"button\",\r\n    render,\r\n    props: mergeProps<\"button\">(defaultProps, props),\r\n  });\r\n\r\n  return element;\r\n}\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * DrawerPortal\r\n * -------------------------------------------------------------------------------------------------*/\r\n\r\nfunction DrawerPortal({\r\n  ...props\r\n}: React.ComponentProps<typeof BaseDialog.Portal>) {\r\n  return <BaseDialog.Portal data-slot=\"drawer-portal\" {...props} />;\r\n}\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * DrawerContent\r\n * -------------------------------------------------------------------------------------------------*/\r\n\r\ninterface DrawerContentProps extends BaseDialog.Popup.Props {\r\n  footerVariant?: \"default\" | \"inset\";\r\n}\r\n\r\nfunction DrawerContent({\r\n  initialFocus,\r\n  finalFocus,\r\n  footerVariant = \"default\",\r\n  ...props\r\n}: DrawerContentProps) {\r\n  return (\r\n    <DrawerPortal>\r\n      <DrawerContentInner\r\n        initialFocus={initialFocus}\r\n        finalFocus={finalFocus}\r\n        footerVariant={footerVariant}\r\n        {...props}\r\n      />\r\n    </DrawerPortal>\r\n  );\r\n}\r\n\r\nfunction DrawerContentInner({\r\n  className,\r\n  children,\r\n  footerVariant = \"default\",\r\n  initialFocus,\r\n  finalFocus,\r\n  ...props\r\n}: DrawerContentProps) {\r\n  const {\r\n    direction,\r\n    variant,\r\n    snapPoints,\r\n    activeSnapPoint,\r\n    setActiveSnapPoint,\r\n    dismissible,\r\n    modal,\r\n    contentSize,\r\n    setContentSize,\r\n    isVertical,\r\n    setIsDragging,\r\n    dragProgress,\r\n    setDragProgress,\r\n    snapProgress,\r\n    setSnapProgress,\r\n    onOpenChange,\r\n    open,\r\n    isAnimating,\r\n    immediateClose,\r\n    setImmediateClose,\r\n    isDragging,\r\n    sequentialSnap,\r\n    repositionInputs,\r\n  } = useDrawer();\r\n\r\n  const activeSnapPointIndex = findSnapPointIndex(snapPoints, activeSnapPoint);\r\n\r\n  const handleSnapPointChange = React.useCallback(\r\n    (index: number) => {\r\n      setActiveSnapPoint(getSnapPointValue(snapPoints, index));\r\n    },\r\n    [snapPoints, setActiveSnapPoint],\r\n  );\r\n\r\n  const { keyboardHeight, isKeyboardVisible } = useVirtualKeyboard({\r\n    enabled: direction === \"bottom\",\r\n  });\r\n\r\n  // Provides real-time viewport height that updates with URL bar changes\r\n  const visualViewportHeight = useVisualViewportHeight({\r\n    enabled: !isVertical && modal !== true,\r\n  });\r\n\r\n  const handleDismiss = React.useCallback(() => {\r\n    onOpenChange(false, { reason: \"swipe-dismiss\" });\r\n  }, [onOpenChange]);\r\n\r\n  const handleImmediateClose = React.useCallback(() => {\r\n    setImmediateClose(true);\r\n  }, [setImmediateClose]);\r\n\r\n  // Skip progress updates during enter/exit animations (let CSS control backdrop)\r\n  const handleScrollProgress = React.useCallback(\r\n    (progress: number) => {\r\n      if (!isAnimating) {\r\n        setDragProgress(progress);\r\n      }\r\n    },\r\n    [isAnimating, setDragProgress],\r\n  );\r\n\r\n  const handleSnapProgress = React.useCallback(\r\n    (progress: number) => {\r\n      if (!isAnimating) {\r\n        setSnapProgress(progress);\r\n      }\r\n    },\r\n    [isAnimating, setSnapProgress],\r\n  );\r\n\r\n  const {\r\n    containerRef,\r\n    isScrolling,\r\n    setSnapTargetRef,\r\n    trackSize,\r\n    snapScrollPositions,\r\n    isInitialized,\r\n    isClosing,\r\n  } = useScrollSnap({\r\n    direction,\r\n    snapPoints,\r\n    activeSnapPointIndex,\r\n    onSnapPointChange: handleSnapPointChange,\r\n    onDismiss: handleDismiss,\r\n    dismissible,\r\n    contentSize,\r\n    open,\r\n    onScrollProgress: handleScrollProgress,\r\n    onSnapProgress: handleSnapProgress,\r\n    onImmediateClose: handleImmediateClose,\r\n    isAnimating,\r\n    onScrollingChange: setIsDragging,\r\n  });\r\n\r\n  const snapPointRatio = React.useMemo(() => {\r\n    if (typeof activeSnapPoint === \"number\") {\r\n      return activeSnapPoint;\r\n    }\r\n    const pixels = parsePixelValue(activeSnapPoint);\r\n    if (!pixels || !contentSize) return 1;\r\n    return pixels / contentSize;\r\n  }, [activeSnapPoint, contentSize]);\r\n\r\n  const firstSnapRatio =\r\n    contentSize != null\r\n      ? snapPointToRatio(snapPoints[0], contentSize)\r\n      : typeof snapPoints[0] === \"number\"\r\n        ? snapPoints[0]\r\n        : 1;\r\n  const lastSnapRatio =\r\n    contentSize != null\r\n      ? snapPointToRatio(snapPoints[snapPoints.length - 1], contentSize)\r\n      : typeof snapPoints[snapPoints.length - 1] === \"number\"\r\n        ? snapPoints[snapPoints.length - 1]\r\n        : 1;\r\n\r\n  const baseOffset =\r\n    typeof activeSnapPoint === \"number\"\r\n      ? `${activeSnapPoint * 100}%`\r\n      : activeSnapPoint;\r\n  const animationOffset =\r\n    variant === \"floating\" ? `calc(${baseOffset} + 1rem)` : baseOffset;\r\n\r\n  const targetBackdropOpacity = snapPointRatio;\r\n\r\n  const observerRef = React.useRef<ResizeObserver | null>(null);\r\n  const floatingMargin = variant === \"floating\" ? 16 : 0;\r\n\r\n  const measureRef = React.useCallback(\r\n    (node: HTMLDivElement | null) => {\r\n      observerRef.current?.disconnect();\r\n      observerRef.current = null;\r\n\r\n      if (!node) return;\r\n\r\n      const measure = () => {\r\n        const baseSize = isVertical ? node.offsetHeight : node.offsetWidth;\r\n        setContentSize(baseSize + floatingMargin);\r\n      };\r\n\r\n      measure();\r\n      observerRef.current = new ResizeObserver(measure);\r\n      observerRef.current.observe(node);\r\n    },\r\n    [isVertical, setContentSize, floatingMargin],\r\n  );\r\n\r\n  React.useEffect(() => () => observerRef.current?.disconnect(), []);\r\n\r\n  const useScrollDrivenAnimation =\r\n    supportsScrollTimeline && isInitialized && !isAnimating && !immediateClose;\r\n\r\n  const viewportStyle = React.useMemo<React.CSSProperties>(\r\n    () => ({\r\n      ...(visualViewportHeight != null && {\r\n        \"--visual-viewport-height\": `${visualViewportHeight}px`,\r\n      }),\r\n      ...(repositionInputs && {\r\n        \"--keyboard-height\": `${keyboardHeight}px`,\r\n      }),\r\n      \"--content-size\": `${contentSize ?? 0}px`,\r\n      \"--dismiss-buffer\": dismissible ? `${(contentSize ?? 0) * 0.3}px` : \"0px\",\r\n      \"--first-snap-ratio\": firstSnapRatio,\r\n      \"--last-snap-ratio\": lastSnapRatio,\r\n      scrollSnapType: isInitialized\r\n        ? isVertical\r\n          ? \"y mandatory\"\r\n          : \"x mandatory\"\r\n        : \"none\",\r\n      scrollBehavior: isInitialized ? \"smooth\" : \"auto\",\r\n      ...(useScrollDrivenAnimation\r\n        ? {\r\n            animationName: \"drawer-snap-progress\",\r\n            animationTimingFunction: \"linear\",\r\n            animationFillMode: \"both\",\r\n            animationTimeline: isVertical ? \"scroll(self)\" : \"scroll(self x)\",\r\n            ...(direction === \"top\" || direction === \"left\"\r\n              ? {\r\n                  animationRange: `calc(var(--content-size) * (1 - var(--last-snap-ratio))) calc(var(--content-size) * (1 - var(--first-snap-ratio)))`,\r\n                  animationDirection: \"reverse\",\r\n                }\r\n              : {\r\n                  animationRange: `calc(var(--dismiss-buffer) + var(--first-snap-ratio) * var(--content-size)) calc(var(--dismiss-buffer) + var(--last-snap-ratio) * var(--content-size))`,\r\n                }),\r\n          }\r\n        : {\r\n            \"--drawer-snap-progress\": snapProgress,\r\n          }),\r\n    }),\r\n    [\r\n      visualViewportHeight,\r\n      repositionInputs,\r\n      keyboardHeight,\r\n      contentSize,\r\n      dismissible,\r\n      firstSnapRatio,\r\n      lastSnapRatio,\r\n      isInitialized,\r\n      isVertical,\r\n      useScrollDrivenAnimation,\r\n      snapProgress,\r\n      direction,\r\n    ],\r\n  );\r\n\r\n  const popupStyle = React.useMemo<React.CSSProperties>(\r\n    () => ({\r\n      \"--drawer-offset\": animationOffset,\r\n      ...(supportsScrollTimeline && {\r\n        viewTimelineName: \"--drawer-panel\",\r\n        viewTimelineAxis: isVertical ? \"block\" : \"inline\",\r\n      }),\r\n    }),\r\n    [animationOffset, isVertical],\r\n  );\r\n\r\n  return (\r\n    <div\r\n      data-slot=\"drawer-timeline-scope\"\r\n      style={\r\n        supportsScrollTimeline\r\n          ? ({ timelineScope: \"--drawer-panel\" } as React.CSSProperties)\r\n          : undefined\r\n      }\r\n    >\r\n      {modal === true && (\r\n        <BaseDialog.Backdrop\r\n          data-slot=\"drawer-overlay\"\r\n          className={cn(\r\n            \"absolute inset-0 z-50 bg-black/35\",\r\n            \"[transform:translateZ(0)] will-change-[opacity]\",\r\n            isClosing ? \"pointer-events-none\" : \"pointer-events-auto\",\r\n            \"touch-none\",\r\n            immediateClose || (isDragging && !isAnimating)\r\n              ? \"transition-none\"\r\n              : \"ease-[cubic-bezier(0, 0, 0.58, 1)] transition-opacity duration-300\",\r\n            \"[&[data-starting-style]]:opacity-0!\",\r\n            // Exit animation overrides scroll-driven animation (transitions can't interpolate from animation-held values)\r\n            \"data-ending-style:animate-[drawer-backdrop-exit_300ms_cubic-bezier(0,0,0.58,1)_forwards]\",\r\n            isInitialized && !isAnimating && dismissible && dragProgress < 1\r\n              ? useScrollDrivenAnimation\r\n                ? backdropAnimationStyles[direction]\r\n                : `opacity-(--drawer-backdrop-dynamic-opacity)`\r\n              : `opacity-(--drawer-backdrop-static-opacity)`,\r\n          )}\r\n          style={\r\n            {\r\n              \"--drawer-backdrop-dynamic-opacity\": 1 - dragProgress,\r\n              \"--drawer-backdrop-static-opacity\": targetBackdropOpacity,\r\n            } as React.CSSProperties\r\n          }\r\n        />\r\n      )}\r\n\r\n      <BaseDialog.Viewport\r\n        ref={containerRef}\r\n        data-slot=\"drawer-viewport\"\r\n        data-direction={direction}\r\n        data-scrolling={isScrolling || undefined}\r\n        data-keyboard-visible={\r\n          direction === \"bottom\" && repositionInputs && isKeyboardVisible\r\n            ? \"true\"\r\n            : undefined\r\n        }\r\n        className={cn(\r\n          \"group/drawer\",\r\n          \"fixed inset-x-0 z-50 outline-hidden\",\r\n          // Bottom: -60px top buffer prevents URL bar collapse; non-modal uses lvh\r\n          direction === \"bottom\" &&\r\n            (modal === true\r\n              ? \"top-[-60px] bottom-[env(keyboard-inset-height,var(--keyboard-height,0))]\"\r\n              : \"top-auto! bottom-[env(keyboard-inset-height,var(--keyboard-height,0))] h-lvh\"),\r\n          direction === \"top\" && \"top-0! bottom-[-60px]!\",\r\n          !isVertical &&\r\n            (modal === true\r\n              ? \"top-0! bottom-0! h-dvh\"\r\n              : \"top-0! bottom-0 h-lvh\"),\r\n          isAnimating || isClosing || modal !== true\r\n            ? \"pointer-events-none\"\r\n            : \"pointer-events-auto\",\r\n          \"bg-transparent opacity-100! [&[data-ending-style]]:opacity-100! [&[data-starting-style]]:opacity-100!\",\r\n          \"[scrollbar-width:none_!important] [&::-webkit-scrollbar]:hidden!\",\r\n          isAnimating || isClosing\r\n            ? \"touch-none overflow-hidden\"\r\n            : isVertical\r\n              ? \"touch-pan-y overflow-x-hidden overflow-y-auto overscroll-y-none\"\r\n              : \"touch-pan-x overflow-x-auto overflow-y-hidden overscroll-x-none\",\r\n          isVertical ? \"touch-pan-y\" : \"touch-pan-x\",\r\n          \"motion-reduce:[scroll-behavior:auto]\",\r\n        )}\r\n        style={viewportStyle}\r\n      >\r\n        <div\r\n          data-slot=\"drawer-track\"\r\n          className={drawerTrackVariants({ direction })}\r\n          style={\r\n            {\r\n              [isVertical ? \"height\" : \"width\"]: `${trackSize}px`,\r\n              \"--content-size\": `${contentSize ?? 0}px`,\r\n              \"--dismiss-buffer\": dismissible\r\n                ? `${(contentSize ?? 0) * 0.3}px`\r\n                : \"0px\",\r\n            } as React.CSSProperties\r\n          }\r\n        >\r\n          {/* Snap targets with JS-calculated positions (CSS calc() has issues on iOS Safari) */}\r\n          {snapScrollPositions.map((position, index) => (\r\n            <div\r\n              key={index}\r\n              ref={(el) => setSnapTargetRef(index, el)}\r\n              data-slot=\"drawer-snap-target\"\r\n              data-snap-index={index}\r\n              className={cn(\r\n                \"pointer-events-none absolute\",\r\n                isVertical ? \"inset-x-0 h-px\" : \"inset-y-0 w-px\",\r\n              )}\r\n              style={\r\n                {\r\n                  [isVertical ? \"top\" : \"left\"]: `${position}px`,\r\n                  scrollSnapAlign: \"start\",\r\n                  scrollSnapStop: sequentialSnap ? \"always\" : undefined,\r\n                  ...(supportsScrollState && {\r\n                    containerType: \"scroll-state\",\r\n                  }),\r\n                } as React.CSSProperties\r\n              }\r\n              aria-hidden=\"true\"\r\n            />\r\n          ))}\r\n\r\n          <BaseDialog.Popup\r\n            ref={measureRef}\r\n            data-slot=\"drawer-content\"\r\n            data-footer-variant={footerVariant}\r\n            initialFocus={initialFocus}\r\n            finalFocus={finalFocus}\r\n            className={cn(\r\n              drawerContentVariants({ variant, direction }),\r\n              open && !isInitialized && \"opacity-0\",\r\n              isAnimating || isClosing\r\n                ? \"pointer-events-none\"\r\n                : \"pointer-events-auto\",\r\n              immediateClose && \"transition-none\",\r\n              // Safari iOS touch fix: 1px cross-axis overflow (WebKit bug #183870)\r\n              modal !== true && [\r\n                \"[@supports(-webkit-touch-callout:none)]:relative [@supports(-webkit-touch-callout:none)]:[scrollbar-width:none]\",\r\n                isVertical\r\n                  ? \"[@supports(-webkit-touch-callout:none)]:overflow-x-scroll [@supports(-webkit-touch-callout:none)]:overscroll-x-none [@supports(-webkit-touch-callout:none)]:after:pointer-events-none [@supports(-webkit-touch-callout:none)]:after:absolute [@supports(-webkit-touch-callout:none)]:after:inset-0 [@supports(-webkit-touch-callout:none)]:after:w-[calc(100%+0.5px)] [@supports(-webkit-touch-callout:none)]:after:content-['']\"\r\n                  : \"[@supports(-webkit-touch-callout:none)]:overflow-y-scroll [@supports(-webkit-touch-callout:none)]:overscroll-y-none [@supports(-webkit-touch-callout:none)]:after:pointer-events-none [@supports(-webkit-touch-callout:none)]:after:absolute [@supports(-webkit-touch-callout:none)]:after:inset-0 [@supports(-webkit-touch-callout:none)]:after:h-[calc(100%+1px)] [@supports(-webkit-touch-callout:none)]:after:content-['']\",\r\n              ],\r\n              className,\r\n            )}\r\n            style={popupStyle}\r\n            {...props}\r\n          >\r\n            {children}\r\n          </BaseDialog.Popup>\r\n        </div>\r\n\r\n        {SafariNavColorDetectors}\r\n      </BaseDialog.Viewport>\r\n    </div>\r\n  );\r\n}\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * DrawerHandle\r\n * -------------------------------------------------------------------------------------------------*/\r\n\r\ninterface DrawerHandleProps extends Omit<\r\n  React.ComponentProps<\"button\">,\r\n  \"children\"\r\n> {\r\n  hidden?: boolean;\r\n  preventClose?: boolean;\r\n}\r\n\r\nfunction DrawerHandle({\r\n  className,\r\n  hidden,\r\n  preventClose = false,\r\n  onClick,\r\n  ...props\r\n}: DrawerHandleProps) {\r\n  const { isVertical } = useDrawerConfig();\r\n  const { onOpenChange, isAnimating } = useDrawerAnimation();\r\n\r\n  if (hidden) return null;\r\n\r\n  const handleClick = (event: React.MouseEvent<HTMLButtonElement>) => {\r\n    onClick?.(event);\r\n    if (event.defaultPrevented) return;\r\n    if (isAnimating || preventClose) return;\r\n    onOpenChange(false);\r\n  };\r\n\r\n  return (\r\n    <button\r\n      type=\"button\"\r\n      data-slot=\"drawer-handle\"\r\n      aria-label=\"Close drawer\"\r\n      onClick={handleClick}\r\n      className={cn(\r\n        \"appearance-none border-0 bg-transparent p-0\",\r\n        \"focus-visible:ring-ring/50 rounded-sm outline-none focus-visible:ring-2 focus-visible:ring-offset-2\",\r\n        \"bg-muted-foreground/30 shrink-0 cursor-pointer rounded-full\",\r\n        isVertical ? \"mx-auto my-3 h-1.5 w-12\" : \"mx-3 my-auto h-12 w-1.5\",\r\n        \"hover:bg-muted-foreground/50 transition-colors\",\r\n        className,\r\n      )}\r\n      {...props}\r\n    />\r\n  );\r\n}\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * DrawerHeader\r\n * -------------------------------------------------------------------------------------------------*/\r\n\r\nfunction DrawerHeader({ className, ...props }: React.ComponentProps<\"div\">) {\r\n  return (\r\n    <div\r\n      data-slot=\"drawer-header\"\r\n      className={cn(\r\n        \"flex flex-col gap-1.5 px-5 pt-5 pb-3\",\r\n        \"not-has-[+[data-slot=drawer-body]]:has-[+[data-slot=drawer-footer]]:pb-1\",\r\n        \"not-has-[+[data-slot=drawer-body]]:not-has-[+[data-slot=drawer-footer]]:pb-5\",\r\n        \"in-data-[footer-variant=inset]:not-has-[+[data-slot=drawer-body]]:has-[+[data-slot=drawer-footer]]:pb-5\",\r\n        className,\r\n      )}\r\n      {...props}\r\n    />\r\n  );\r\n}\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * DrawerFooter\r\n * -------------------------------------------------------------------------------------------------*/\r\n\r\nfunction DrawerFooter({ className, ...props }: React.ComponentProps<\"div\">) {\r\n  return (\r\n    <div\r\n      data-slot=\"drawer-footer\"\r\n      className={cn(\r\n        \"bg-popover mt-auto flex flex-col gap-2 px-5 pt-3 pb-5\",\r\n        \"first:pt-5\",\r\n        \"in-data-[footer-variant=inset]:border-border in-data-[footer-variant=inset]:bg-muted in-data-[footer-variant=inset]:border-t in-data-[footer-variant=inset]:pt-4 in-data-[footer-variant=inset]:pb-4\",\r\n        className,\r\n      )}\r\n      {...props}\r\n    />\r\n  );\r\n}\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * DrawerTitle\r\n * -------------------------------------------------------------------------------------------------*/\r\n\r\nfunction DrawerTitle({\r\n  className,\r\n  ...props\r\n}: React.ComponentProps<typeof BaseDialog.Title>) {\r\n  return (\r\n    <BaseDialog.Title\r\n      data-slot=\"drawer-title\"\r\n      className={cn(\"text-foreground text-lg font-semibold text-balance\", className)}\r\n      {...props}\r\n    />\r\n  );\r\n}\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * DrawerDescription\r\n * -------------------------------------------------------------------------------------------------*/\r\n\r\nfunction DrawerDescription({\r\n  className,\r\n  ...props\r\n}: React.ComponentProps<typeof BaseDialog.Description>) {\r\n  return (\r\n    <BaseDialog.Description\r\n      data-slot=\"drawer-description\"\r\n      className={cn(\"text-muted-foreground text-sm text-pretty\", className)}\r\n      {...props}\r\n    />\r\n  );\r\n}\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * DrawerBody\r\n * -------------------------------------------------------------------------------------------------*/\r\n\r\nfunction DrawerBody({\r\n  className,\r\n  nativeScroll = false,\r\n  fadeEdges = false,\r\n  scrollbarGutter = false,\r\n  persistScrollbar,\r\n  hideScrollbar,\r\n  children,\r\n  ...props\r\n}: React.ComponentProps<\"div\"> & {\r\n  nativeScroll?: boolean;\r\n} & Pick<\r\n    ScrollAreaProps,\r\n    \"fadeEdges\" | \"scrollbarGutter\" | \"persistScrollbar\" | \"hideScrollbar\"\r\n  >) {\r\n  const { isVertical } = useDrawerConfig();\r\n\r\n  return (\r\n    <div\r\n      data-slot=\"drawer-body\"\r\n      className={cn(\r\n        // z-0: stays below sticky footer during iOS Safari enter animation\r\n        \"relative z-0 flex min-h-0 flex-1 flex-col overflow-hidden\",\r\n        \"first:pt-4\",\r\n        \"not-has-[+[data-slot=drawer-footer]]:pb-4\",\r\n        \"in-data-[footer-variant=inset]:has-[+[data-slot=drawer-footer]]:pb-4\",\r\n      )}\r\n    >\r\n      <ScrollArea\r\n        className=\"flex-1\"\r\n        fadeEdges={fadeEdges}\r\n        scrollbarGutter={scrollbarGutter}\r\n        persistScrollbar={persistScrollbar}\r\n        hideScrollbar={hideScrollbar}\r\n        nativeScroll={nativeScroll}\r\n        overscrollBehavior=\"auto\"\r\n        viewportClassName={isVertical ? \"touch-pan-y\" : \"touch-pan-x\"}\r\n      >\r\n        <div className={cn(\"px-5 py-1\", className)} {...props}>\r\n          {children}\r\n        </div>\r\n      </ScrollArea>\r\n    </div>\r\n  );\r\n}\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * Exports\r\n * -------------------------------------------------------------------------------------------------*/\r\n\r\nexport {\r\n  Drawer,\r\n  DrawerTrigger,\r\n  DrawerClose,\r\n  DrawerPortal,\r\n  DrawerContent,\r\n  DrawerHandle,\r\n  DrawerHeader,\r\n  DrawerFooter,\r\n  DrawerTitle,\r\n  DrawerDescription,\r\n  DrawerBody,\r\n  useDrawer,\r\n  useDrawerConfig,\r\n  useDrawerAnimation,\r\n  createDrawerHandle,\r\n};\r\n\r\nexport type { DrawerRenderProps, DrawerVariant };\r\n\r\nexport { supportsScrollTimeline, supportsScrollState };\r\n",
      "type": "registry:ui",
      "target": "components/ui/cubby-ui/drawer/drawer.tsx"
    },
    {
      "path": "registry/default/drawer/lib/drawer-utils.ts",
      "content": "/* -------------------------------------------------------------------------------------------------\r\n * Types\r\n * -------------------------------------------------------------------------------------------------*/\r\n\r\nexport type DrawerDirection = \"top\" | \"right\" | \"bottom\" | \"left\";\r\n\r\n/**\r\n * Snap point value:\r\n * - number (0-1): percentage of drawer visible (0 = closed, 1 = fully open)\r\n * - `${number}px`: fixed pixel height visible (e.g., \"200px\")\r\n */\r\nexport type SnapPoint = number | `${number}px`;\r\n\r\n/**\r\n * Direction configuration for drawer behavior.\r\n * Eliminates repeated conditionals throughout the codebase.\r\n */\r\nexport const DIRECTION_CONFIG = {\r\n  top: { isVertical: true, isInverted: true },\r\n  bottom: { isVertical: true, isInverted: false },\r\n  left: { isVertical: false, isInverted: true },\r\n  right: { isVertical: false, isInverted: false },\r\n} as const;\r\n\r\nexport type DirectionConfig = (typeof DIRECTION_CONFIG)[DrawerDirection];\r\n\r\n/**\r\n * Scroll geometry for drawer positioning calculations.\r\n */\r\nexport interface ScrollGeometry {\r\n  /** Total track size (viewport + content + dismiss buffer) */\r\n  trackSize: number;\r\n  /** Buffer space for dismiss gesture */\r\n  dismissBuffer: number;\r\n  /** Maximum scroll position */\r\n  maxScroll: number;\r\n  /** Whether scroll direction is inverted (top/left) */\r\n  isInverted: boolean;\r\n}\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * Browser Support Detection\r\n * -------------------------------------------------------------------------------------------------*/\r\n\r\nexport const supportsScrollEnd =\r\n  typeof window !== \"undefined\" && \"onscrollend\" in window;\r\n\r\n/**\r\n * Feature detection for scroll-driven animations (animation-timeline: scroll())\r\n * Chrome 115+, Safari 26+ (future), Firefox flag-only\r\n */\r\nexport const supportsScrollTimeline =\r\n  typeof CSS !== \"undefined\" &&\r\n  CSS.supports(\"animation-timeline\", \"scroll()\") &&\r\n  CSS.supports(\"timeline-scope\", \"--test\");\r\n\r\n/**\r\n * Feature detection for scroll snap events (scrollsnapchange, scrollsnapchanging)\r\n * Chrome 129+ only\r\n */\r\nexport const supportsScrollSnapChange =\r\n  typeof window !== \"undefined\" && \"onscrollsnapchange\" in window;\r\n\r\n/**\r\n * Feature detection for CSS scroll-state() container queries\r\n * Chrome 133+ only\r\n */\r\nexport const supportsScrollState =\r\n  typeof CSS !== \"undefined\" && CSS.supports(\"container-type\", \"scroll-state\");\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * Utility Functions\r\n * -------------------------------------------------------------------------------------------------*/\r\n\r\n/**\r\n * Parse a pixel value string (e.g., \"200px\") and return the number\r\n */\r\nexport function parsePixelValue(value: string): number | null {\r\n  const match = value.match(/^(\\d+(?:\\.\\d+)?)px$/);\r\n  return match ? parseFloat(match[1]) : null;\r\n}\r\n\r\n/**\r\n * Convert a snap point to a ratio (0-1).\r\n * For percentage snap points, returns the value directly.\r\n * For pixel snap points, divides by contentSize.\r\n */\r\nexport function snapPointToRatio(\r\n  snapPoint: SnapPoint,\r\n  contentSize: number,\r\n): number {\r\n  if (typeof snapPoint === \"number\") {\r\n    return snapPoint;\r\n  }\r\n  const pixels = parsePixelValue(snapPoint);\r\n  return pixels != null ? pixels / contentSize : 1;\r\n}\r\n\r\n/**\r\n * Find the index of a snap point value in the array\r\n * Returns the last index if value is null or not found\r\n */\r\nexport function findSnapPointIndex(\r\n  snapPoints: SnapPoint[],\r\n  value: SnapPoint | null,\r\n): number {\r\n  if (value === null) return snapPoints.length - 1;\r\n  const index = snapPoints.findIndex((sp) => sp === value);\r\n  return index === -1 ? snapPoints.length - 1 : index;\r\n}\r\n\r\n/**\r\n * Get the snap point value at a given index (clamped to valid range)\r\n */\r\nexport function getSnapPointValue(\r\n  snapPoints: SnapPoint[],\r\n  index: number,\r\n): SnapPoint {\r\n  return snapPoints[Math.max(0, Math.min(index, snapPoints.length - 1))];\r\n}\r\n\r\n/**\r\n * Wait for scroll to end on an element\r\n */\r\nexport function waitForScrollEnd(element: HTMLElement): Promise<void> {\r\n  return new Promise((resolve) => {\r\n    if (supportsScrollEnd) {\r\n      element.addEventListener(\"scrollend\", () => resolve(), { once: true });\r\n    } else {\r\n      // Fallback: debounced scroll detection\r\n      let timeout: ReturnType<typeof setTimeout>;\r\n      const handler = () => {\r\n        clearTimeout(timeout);\r\n        timeout = setTimeout(() => {\r\n          element.removeEventListener(\"scroll\", handler);\r\n          resolve();\r\n        }, 0);\r\n      };\r\n      element.addEventListener(\"scroll\", handler, { passive: true });\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Check if user prefers reduced motion\r\n */\r\nexport function prefersReducedMotion(): boolean {\r\n  if (typeof window === \"undefined\") return false;\r\n  return window.matchMedia(\"(prefers-reduced-motion: reduce)\").matches;\r\n}\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * Scroll Geometry Calculations\r\n * -------------------------------------------------------------------------------------------------*/\r\n\r\n/**\r\n * Calculate scroll geometry for drawer positioning.\r\n * These values determine track size and scroll positions for snap points.\r\n */\r\nexport function calculateScrollGeometry(\r\n  viewportSize: number,\r\n  contentSize: number,\r\n  dismissible: boolean,\r\n  isInverted: boolean,\r\n): ScrollGeometry {\r\n  // Caller is responsible for ensuring contentSize is valid (> 0)\r\n  const dismissBuffer = dismissible ? contentSize * 0.3 : 0;\r\n  const trackSize = viewportSize + contentSize + dismissBuffer;\r\n  const maxScroll = trackSize - viewportSize;\r\n\r\n  return {\r\n    trackSize,\r\n    dismissBuffer,\r\n    maxScroll,\r\n    isInverted,\r\n  };\r\n}\r\n\r\n/**\r\n * Calculate scroll positions for each snap point.\r\n * Returns an array where index 0 is dismiss position (if dismissible),\r\n * followed by positions for each snap point.\r\n */\r\nexport function calculateSnapScrollPositions(\r\n  snapPoints: SnapPoint[],\r\n  geometry: ScrollGeometry,\r\n  dismissible: boolean,\r\n  contentSize: number,\r\n): number[] {\r\n  const { maxScroll, dismissBuffer, isInverted } = geometry;\r\n  const positions: number[] = [];\r\n\r\n  // Add dismiss position first if dismissible\r\n  if (dismissible) {\r\n    positions.push(isInverted ? maxScroll : 0);\r\n  }\r\n\r\n  // Calculate positions for each snap point\r\n  // Note: contentSize here is effectiveSize (with fallback applied)\r\n  for (const snapPoint of snapPoints) {\r\n    const visibleRatio =\r\n      typeof snapPoint === \"string\"\r\n        ? (parsePixelValue(snapPoint) ?? contentSize) / contentSize\r\n        : snapPoint;\r\n\r\n    // Calculate scroll position based on direction\r\n    // Formula: dismissBuffer + visibleRatio * contentSize (non-inverted)\r\n    // Or: maxScroll - dismissBuffer - visibleRatio * contentSize (inverted)\r\n    const scrollPos = isInverted\r\n      ? maxScroll - dismissBuffer - visibleRatio * contentSize\r\n      : dismissBuffer + visibleRatio * contentSize;\r\n\r\n    positions.push(Math.min(maxScroll, Math.max(0, scrollPos)));\r\n  }\r\n\r\n  return positions;\r\n}\r\n\r\n/**\r\n * Calculate progress from scroll position (0 = fully open, 1 = fully closed).\r\n * Used for backdrop opacity animation.\r\n */\r\nexport function calculateScrollProgress(\r\n  scrollPos: number,\r\n  geometry: ScrollGeometry,\r\n  contentSize: number,\r\n): number {\r\n  const { dismissBuffer, isInverted } = geometry;\r\n\r\n  let progress: number;\r\n  if (isInverted) {\r\n    // Top/Left: scroll 0 = open (0), maxScroll = closed (1)\r\n    // openScrollPos simplifies to 0 (maxScroll - dismissBuffer - contentSize = 0)\r\n    progress = scrollPos / contentSize;\r\n  } else {\r\n    // Bottom/Right: 0 = closed (1), maxScroll = open (0)\r\n    progress = 1 - (scrollPos - dismissBuffer) / contentSize;\r\n  }\r\n\r\n  return Math.min(1, Math.max(0, progress));\r\n}\r\n\r\n/**\r\n * Calculate snap progress from scroll position (0 = first snap, 1 = last snap).\r\n * Used for crossfade effects between snap points.\r\n */\r\nexport function calculateSnapProgress(\r\n  scrollPos: number,\r\n  snapScrollPositions: number[],\r\n  dismissible: boolean,\r\n): number {\r\n  const firstSnapIndex = dismissible ? 1 : 0;\r\n  const lastSnapIndex = snapScrollPositions.length - 1;\r\n\r\n  // Handle edge cases\r\n  if (firstSnapIndex >= lastSnapIndex) return 0;\r\n\r\n  const firstSnapPos = snapScrollPositions[firstSnapIndex];\r\n  const lastSnapPos = snapScrollPositions[lastSnapIndex];\r\n\r\n  if (firstSnapPos === lastSnapPos) return 0;\r\n\r\n  const progress =\r\n    (scrollPos - firstSnapPos) / (lastSnapPos - firstSnapPos);\r\n  return Math.min(1, Math.max(0, progress));\r\n}\r\n",
      "type": "registry:lib",
      "target": "components/ui/cubby-ui/drawer/lib/drawer-utils.ts"
    },
    {
      "path": "registry/default/drawer/hooks/use-scroll-snap.ts",
      "content": "import * as React from \"react\";\r\n\r\nimport type {\r\n  DrawerDirection,\r\n  SnapPoint,\r\n  ScrollGeometry,\r\n} from \"../lib/drawer-utils\";\r\nimport {\r\n  DIRECTION_CONFIG,\r\n  supportsScrollEnd,\r\n  supportsScrollTimeline,\r\n  supportsScrollState,\r\n  supportsScrollSnapChange,\r\n  prefersReducedMotion,\r\n  waitForScrollEnd,\r\n  calculateScrollGeometry,\r\n  calculateSnapScrollPositions,\r\n  calculateScrollProgress,\r\n  calculateSnapProgress,\r\n} from \"../lib/drawer-utils\";\r\n\r\nexport interface UseScrollSnapOptions {\r\n  direction: DrawerDirection;\r\n  snapPoints: SnapPoint[];\r\n  activeSnapPointIndex: number;\r\n  onSnapPointChange: (index: number) => void;\r\n  onDismiss: () => void;\r\n  dismissible: boolean;\r\n  contentSize: number | null;\r\n  open: boolean;\r\n  /** 0 = open, 1 = closed */\r\n  onScrollProgress?: (progress: number) => void;\r\n  /** 0 = first snap, 1 = last snap */\r\n  onSnapProgress?: (progress: number) => void;\r\n  onImmediateClose?: () => void;\r\n  isAnimating?: boolean;\r\n  onScrollingChange?: (isScrolling: boolean) => void;\r\n}\r\n\r\nexport interface UseScrollSnapReturn {\r\n  containerRef: React.RefObject<HTMLDivElement | null>;\r\n  isScrolling: boolean;\r\n  setSnapTargetRef: (index: number, el: HTMLDivElement | null) => void;\r\n  trackSize: number;\r\n  snapScrollPositions: number[];\r\n  isInitialized: boolean;\r\n  isClosing: boolean;\r\n}\r\n\r\ninterface ScrollControlState {\r\n  isProgrammatic: boolean;\r\n  lastDetectedSnapIndex: number;\r\n  isFromDetection: boolean;\r\n}\r\n\r\ninterface InteractionState {\r\n  isClosing: boolean;\r\n  isPointerDown: boolean;\r\n  prevScrollPos: number | null;\r\n  /** Firefox: click stops momentum scroll, need to track if scrollend fired while pointer down */\r\n  scrollEndedWhilePointerDown: boolean;\r\n}\r\n\r\ninterface InitState {\r\n  hasInitialized: boolean;\r\n  retryTimeout: ReturnType<typeof setTimeout> | null;\r\n  rafId: number | null;\r\n  rafLastPos: number | null;\r\n  rafStableCount: number;\r\n}\r\n\r\nexport { supportsScrollTimeline, supportsScrollState };\r\n\r\nexport function useScrollSnap(\r\n  options: UseScrollSnapOptions,\r\n): UseScrollSnapReturn {\r\n  const {\r\n    direction,\r\n    snapPoints,\r\n    activeSnapPointIndex,\r\n    dismissible,\r\n    contentSize,\r\n    open,\r\n    onScrollProgress,\r\n    onSnapProgress,\r\n    onScrollingChange,\r\n  } = options;\r\n\r\n  // Get direction config (replaces repeated conditionals)\r\n  const { isVertical, isInverted } = DIRECTION_CONFIG[direction];\r\n\r\n  const containerRef = React.useRef<HTMLDivElement | null>(null);\r\n  const snapTargetRefs = React.useRef<(HTMLDivElement | null)[]>([]);\r\n\r\n  const scrollControlRef = React.useRef<ScrollControlState>({\r\n    isProgrammatic: false,\r\n    lastDetectedSnapIndex: activeSnapPointIndex,\r\n    isFromDetection: false,\r\n  });\r\n\r\n  const checkScrollStabilityRef = React.useRef<() => void>(() => {});\r\n\r\n  const interactionRef = React.useRef<InteractionState>({\r\n    isClosing: false,\r\n    isPointerDown: false,\r\n    prevScrollPos: null,\r\n    scrollEndedWhilePointerDown: false,\r\n  });\r\n\r\n  const initRef = React.useRef<InitState>({\r\n    hasInitialized: false,\r\n    retryTimeout: null,\r\n    rafId: null,\r\n    rafLastPos: null,\r\n    rafStableCount: 0,\r\n  });\r\n\r\n  const optionsRef = React.useRef(options);\r\n  React.useLayoutEffect(() => {\r\n    optionsRef.current = options;\r\n  });\r\n\r\n  const [isScrolling, setIsScrolling] = React.useState(false);\r\n  const [isClosing, setIsClosingState] = React.useState(false);\r\n  const [isInitialized, setIsInitialized] = React.useState(false);\r\n  const [viewportSize, setViewportSize] = React.useState(() => {\r\n    if (typeof window === \"undefined\") return 800;\r\n    return isVertical ? window.innerHeight : window.innerWidth;\r\n  });\r\n\r\n  const setIsClosing = React.useCallback((value: boolean) => {\r\n    interactionRef.current.isClosing = value;\r\n    setIsClosingState(value);\r\n  }, []);\r\n\r\n  const updateIsScrolling = React.useCallback(\r\n    (value: boolean) => {\r\n      setIsScrolling(value);\r\n      onScrollingChange?.(value);\r\n    },\r\n    [onScrollingChange],\r\n  );\r\n\r\n  // Fallback size until measured (prevents iOS Safari timing issues)\r\n  const effectiveSize = contentSize ?? viewportSize * 0.9;\r\n\r\n  const geometry = React.useMemo<ScrollGeometry>(\r\n    () =>\r\n      calculateScrollGeometry(\r\n        viewportSize,\r\n        effectiveSize,\r\n        dismissible,\r\n        isInverted,\r\n      ),\r\n    [viewportSize, effectiveSize, dismissible, isInverted],\r\n  );\r\n\r\n  const snapScrollPositions = React.useMemo(\r\n    () =>\r\n      calculateSnapScrollPositions(\r\n        snapPoints,\r\n        geometry,\r\n        dismissible,\r\n        effectiveSize,\r\n      ),\r\n    [snapPoints, geometry, dismissible, effectiveSize],\r\n  );\r\n\r\n  const getScrollPositionForSnapPoint = React.useCallback(\r\n    (index: number): number => {\r\n      const adjustedIndex = dismissible ? index + 1 : index;\r\n      return snapScrollPositions[adjustedIndex] ?? 0;\r\n    },\r\n    [snapScrollPositions, dismissible],\r\n  );\r\n\r\n  const findNearestSnapIndex = React.useCallback(\r\n    (scrollPos: number): { index: number; isDismiss: boolean } => {\r\n      let closestIndex = 0;\r\n      let closestDistance = Math.abs(\r\n        scrollPos - (snapScrollPositions[0] ?? 0),\r\n      );\r\n\r\n      for (let i = 1; i < snapScrollPositions.length; i++) {\r\n        const distance = Math.abs(scrollPos - snapScrollPositions[i]);\r\n        if (distance < closestDistance) {\r\n          closestDistance = distance;\r\n          closestIndex = i;\r\n        }\r\n      }\r\n\r\n      if (dismissible && closestIndex === 0) {\r\n        return { index: 0, isDismiss: true };\r\n      }\r\n\r\n      const snapIndex = dismissible ? closestIndex - 1 : closestIndex;\r\n      return { index: Math.max(0, snapIndex), isDismiss: false };\r\n    },\r\n    [snapScrollPositions, dismissible],\r\n  );\r\n\r\n  const detectAndNotifySnapChange = React.useCallback(\r\n    (scrollPos: number) => {\r\n      if (\r\n        scrollControlRef.current.isProgrammatic ||\r\n        interactionRef.current.isClosing\r\n      ) {\r\n        return;\r\n      }\r\n\r\n      const { index, isDismiss } = findNearestSnapIndex(scrollPos);\r\n      if (\r\n        !isDismiss &&\r\n        index !== scrollControlRef.current.lastDetectedSnapIndex\r\n      ) {\r\n        scrollControlRef.current.lastDetectedSnapIndex = index;\r\n        scrollControlRef.current.isFromDetection = true;\r\n        optionsRef.current.onSnapPointChange(index);\r\n      }\r\n    },\r\n    [findNearestSnapIndex],\r\n  );\r\n\r\n  const scrollToSnapPoint = React.useCallback(\r\n    (index: number, behavior: ScrollBehavior = \"smooth\") => {\r\n      const container = containerRef.current;\r\n      if (!container) return;\r\n\r\n      const scrollPos = getScrollPositionForSnapPoint(index);\r\n      const actualBehavior = prefersReducedMotion() ? \"auto\" : behavior;\r\n\r\n      scrollControlRef.current.isProgrammatic = true;\r\n      container.scrollTo({\r\n        [isVertical ? \"top\" : \"left\"]: scrollPos,\r\n        behavior: actualBehavior,\r\n      });\r\n\r\n      if (actualBehavior === \"auto\") {\r\n        scrollControlRef.current.isProgrammatic = false;\r\n      } else {\r\n        waitForScrollEnd(container).then(() => {\r\n          scrollControlRef.current.isProgrammatic = false;\r\n        });\r\n      }\r\n    },\r\n    [getScrollPositionForSnapPoint, isVertical],\r\n  );\r\n\r\n  const triggerImmediateDismiss = React.useCallback(() => {\r\n    if (interactionRef.current.isClosing) return;\r\n\r\n    const container = containerRef.current;\r\n    if (container) {\r\n      container.style.overflow = \"hidden\";\r\n      container.style.pointerEvents = \"none\";\r\n      container.style.touchAction = \"none\";\r\n    }\r\n\r\n    setIsClosing(true);\r\n    scrollControlRef.current.isProgrammatic = true;\r\n\r\n    optionsRef.current.onImmediateClose?.();\r\n    optionsRef.current.onDismiss();\r\n  }, [setIsClosing]);\r\n\r\n  // Fallback for browsers without scrollend event\r\n  const checkScrollStability = React.useCallback(() => {\r\n    const container = containerRef.current;\r\n    if (!container) return;\r\n\r\n    const { isVertical: isVert } =\r\n      DIRECTION_CONFIG[optionsRef.current.direction];\r\n    const currentPos = isVert ? container.scrollTop : container.scrollLeft;\r\n    const { rafLastPos } = initRef.current;\r\n\r\n    if (rafLastPos !== null && Math.abs(currentPos - rafLastPos) < 0.5) {\r\n      initRef.current.rafStableCount++;\r\n      // 3 stable frames (~50ms) = scroll ended (if not touching)\r\n      if (\r\n        initRef.current.rafStableCount >= 3 &&\r\n        !interactionRef.current.isPointerDown\r\n      ) {\r\n        updateIsScrolling(false);\r\n        detectAndNotifySnapChange(currentPos);\r\n\r\n        initRef.current.rafId = null;\r\n        initRef.current.rafLastPos = null;\r\n        initRef.current.rafStableCount = 0;\r\n        return;\r\n      }\r\n    } else {\r\n      initRef.current.rafStableCount = 0;\r\n    }\r\n\r\n    initRef.current.rafLastPos = currentPos;\r\n    initRef.current.rafId = requestAnimationFrame(\r\n      checkScrollStabilityRef.current,\r\n    );\r\n  }, [updateIsScrolling, detectAndNotifySnapChange]);\r\n\r\n  React.useLayoutEffect(() => {\r\n    checkScrollStabilityRef.current = checkScrollStability;\r\n  });\r\n\r\n  const startScrollStabilityCheck = React.useCallback(() => {\r\n    if (initRef.current.rafId === null) {\r\n      initRef.current.rafLastPos = null;\r\n      initRef.current.rafStableCount = 0;\r\n      initRef.current.rafId = requestAnimationFrame(checkScrollStability);\r\n    }\r\n  }, [checkScrollStability]);\r\n\r\n  const handleScroll = React.useCallback(() => {\r\n    if (!initRef.current.hasInitialized) return;\r\n\r\n    const container = containerRef.current;\r\n    if (!container) return;\r\n\r\n    const { isVertical: isVert } =\r\n      DIRECTION_CONFIG[optionsRef.current.direction];\r\n    const scrollPos = isVert ? container.scrollTop : container.scrollLeft;\r\n\r\n    const progress = calculateScrollProgress(scrollPos, geometry, effectiveSize);\r\n    optionsRef.current.onScrollProgress?.(progress);\r\n\r\n    const snapProg = calculateSnapProgress(\r\n      scrollPos,\r\n      snapScrollPositions,\r\n      optionsRef.current.dismissible,\r\n    );\r\n    optionsRef.current.onSnapProgress?.(snapProg);\r\n\r\n    // 2px threshold filters scroll-snap micro-adjustments\r\n    const positionChanged =\r\n      interactionRef.current.prevScrollPos !== null &&\r\n      Math.abs(scrollPos - interactionRef.current.prevScrollPos) > 2;\r\n\r\n    interactionRef.current.prevScrollPos = scrollPos;\r\n\r\n    if (!scrollControlRef.current.isProgrammatic && positionChanged) {\r\n      updateIsScrolling(true);\r\n      if (!supportsScrollEnd) {\r\n        startScrollStabilityCheck();\r\n      }\r\n    }\r\n\r\n    if (!scrollControlRef.current.isProgrammatic) {\r\n      if (\r\n        optionsRef.current.dismissible &&\r\n        !interactionRef.current.isClosing &&\r\n        progress >= 1\r\n      ) {\r\n        triggerImmediateDismiss();\r\n      }\r\n    }\r\n  }, [\r\n    effectiveSize,\r\n    geometry,\r\n    snapScrollPositions,\r\n    updateIsScrolling,\r\n    startScrollStabilityCheck,\r\n    triggerImmediateDismiss,\r\n  ]);\r\n\r\n  const handleScrollEnd = React.useCallback(() => {\r\n    // Firefox: clicking stops momentum, fires scrollend while pointer down\r\n    if (interactionRef.current.isPointerDown) {\r\n      interactionRef.current.scrollEndedWhilePointerDown = true;\r\n    } else {\r\n      updateIsScrolling(false);\r\n    }\r\n\r\n    const container = containerRef.current;\r\n    if (container) {\r\n      const { isVertical: isVert } =\r\n        DIRECTION_CONFIG[optionsRef.current.direction];\r\n      const scrollPos = isVert ? container.scrollTop : container.scrollLeft;\r\n      detectAndNotifySnapChange(scrollPos);\r\n    }\r\n  }, [updateIsScrolling, detectAndNotifySnapChange]);\r\n\r\n  const handleScrollSnapChange = React.useCallback((event: Event) => {\r\n    if (interactionRef.current.isClosing) return;\r\n\r\n    const snapEvent = event as Event & {\r\n      snapTargetBlock?: Element | null;\r\n      snapTargetInline?: Element | null;\r\n    };\r\n\r\n    const { isVertical: isVert } =\r\n      DIRECTION_CONFIG[optionsRef.current.direction];\r\n    const snapTarget = isVert\r\n      ? snapEvent.snapTargetBlock\r\n      : snapEvent.snapTargetInline;\r\n\r\n    if (!snapTarget) return;\r\n\r\n    const snapIndexAttr = snapTarget.getAttribute(\"data-snap-index\");\r\n    if (snapIndexAttr === null) return;\r\n\r\n    const rawIndex = parseInt(snapIndexAttr, 10);\r\n    if (isNaN(rawIndex)) return;\r\n\r\n    const actualIndex = optionsRef.current.dismissible\r\n      ? rawIndex - 1\r\n      : rawIndex;\r\n    if (actualIndex < 0) return;\r\n\r\n    if (actualIndex !== scrollControlRef.current.lastDetectedSnapIndex) {\r\n      scrollControlRef.current.lastDetectedSnapIndex = actualIndex;\r\n      scrollControlRef.current.isFromDetection = true;\r\n      optionsRef.current.onSnapPointChange(actualIndex);\r\n    }\r\n  }, []);\r\n\r\n  // Touch events only (not mouse) - iOS Safari has quirky pointer event behavior\r\n  const handleTouchStart = React.useCallback(() => {\r\n    interactionRef.current.isPointerDown = true;\r\n  }, []);\r\n\r\n  const handleTouchEnd = React.useCallback(() => {\r\n    interactionRef.current.isPointerDown = false;\r\n    initRef.current.rafStableCount = 0;\r\n\r\n    // Firefox: if scrollend fired while pointer down, start stability check\r\n    if (interactionRef.current.scrollEndedWhilePointerDown) {\r\n      interactionRef.current.scrollEndedWhilePointerDown = false;\r\n      startScrollStabilityCheck();\r\n    }\r\n  }, [startScrollStabilityCheck]);\r\n\r\n  // Initialization (DrawerContentInner unmounts on close, giving fresh state)\r\n  React.useEffect(() => {\r\n    if (!open) {\r\n      if (initRef.current.rafId !== null) {\r\n        cancelAnimationFrame(initRef.current.rafId);\r\n        initRef.current.rafId = null;\r\n      }\r\n      if (initRef.current.retryTimeout) {\r\n        clearTimeout(initRef.current.retryTimeout);\r\n        initRef.current.retryTimeout = null;\r\n      }\r\n      return;\r\n    }\r\n\r\n    if (contentSize === null) return;\r\n\r\n    if (!initRef.current.hasInitialized) {\r\n      const performInitialScroll = () => {\r\n        const container = containerRef.current;\r\n        if (!container) {\r\n          initRef.current.retryTimeout = setTimeout(performInitialScroll, 0);\r\n          return;\r\n        }\r\n\r\n        const size = isVertical\r\n          ? container.clientHeight\r\n          : container.clientWidth;\r\n        if (size === 0) {\r\n          initRef.current.retryTimeout = setTimeout(performInitialScroll, 0);\r\n          return;\r\n        }\r\n\r\n        initRef.current.hasInitialized = true;\r\n\r\n        if (size !== viewportSize) {\r\n          setViewportSize(size);\r\n        }\r\n\r\n        const targetIndex = dismissible\r\n          ? activeSnapPointIndex + 1\r\n          : activeSnapPointIndex;\r\n        const targetScrollPos = snapScrollPositions[targetIndex] ?? 0;\r\n\r\n        scrollControlRef.current.isProgrammatic = true;\r\n        scrollControlRef.current.lastDetectedSnapIndex = activeSnapPointIndex;\r\n\r\n        if (isVertical) {\r\n          container.scrollTop = targetScrollPos;\r\n        } else {\r\n          container.scrollLeft = targetScrollPos;\r\n        }\r\n\r\n        const initialProgress = calculateScrollProgress(\r\n          targetScrollPos,\r\n          geometry,\r\n          effectiveSize,\r\n        );\r\n        onScrollProgress?.(initialProgress);\r\n\r\n        const initialSnapProgress = calculateSnapProgress(\r\n          targetScrollPos,\r\n          snapScrollPositions,\r\n          dismissible,\r\n        );\r\n        onSnapProgress?.(initialSnapProgress);\r\n\r\n        setTimeout(() => {\r\n          scrollControlRef.current.isProgrammatic = false;\r\n        }, 0);\r\n\r\n        setIsInitialized(true);\r\n      };\r\n\r\n      initRef.current.retryTimeout = setTimeout(performInitialScroll, 0);\r\n    }\r\n\r\n    const currentInit = initRef.current;\r\n    return () => {\r\n      if (currentInit.retryTimeout) {\r\n        clearTimeout(currentInit.retryTimeout);\r\n        currentInit.retryTimeout = null;\r\n      }\r\n    };\r\n  }, [\r\n    open,\r\n    contentSize,\r\n    effectiveSize,\r\n    isVertical,\r\n    viewportSize,\r\n    dismissible,\r\n    activeSnapPointIndex,\r\n    snapScrollPositions,\r\n    geometry,\r\n    onScrollProgress,\r\n    onSnapProgress,\r\n  ]);\r\n\r\n  // Sync lastDetectedSnapIndex to prevent false isFromDetection after programmatic scrolls\r\n  React.useEffect(() => {\r\n    if (open) {\r\n      scrollControlRef.current.lastDetectedSnapIndex = activeSnapPointIndex;\r\n    }\r\n  }, [open, activeSnapPointIndex]);\r\n\r\n  // Handle controlled snap point changes\r\n  const prevSnapPointRef = React.useRef(activeSnapPointIndex);\r\n  React.useEffect(() => {\r\n    if (prevSnapPointRef.current !== activeSnapPointIndex && open) {\r\n      if (scrollControlRef.current.isFromDetection) {\r\n        scrollControlRef.current.isFromDetection = false;\r\n        prevSnapPointRef.current = activeSnapPointIndex;\r\n        return;\r\n      }\r\n\r\n      const container = containerRef.current;\r\n      if (container) {\r\n        const currentScrollPos = isVertical\r\n          ? container.scrollTop\r\n          : container.scrollLeft;\r\n        const targetScrollPos =\r\n          getScrollPositionForSnapPoint(activeSnapPointIndex);\r\n\r\n        if (Math.abs(currentScrollPos - targetScrollPos) > 10) {\r\n          scrollToSnapPoint(activeSnapPointIndex, \"smooth\");\r\n        }\r\n      }\r\n    }\r\n    prevSnapPointRef.current = activeSnapPointIndex;\r\n  }, [\r\n    activeSnapPointIndex,\r\n    open,\r\n    scrollToSnapPoint,\r\n    isVertical,\r\n    getScrollPositionForSnapPoint,\r\n  ]);\r\n\r\n  // Re-position when geometry changes (e.g., keyboard appears)\r\n  const prevTrackSizeRef = React.useRef(0);\r\n  React.useEffect(() => {\r\n    if (!open || !initRef.current.hasInitialized) return;\r\n\r\n    const { trackSize } = geometry;\r\n\r\n    if (\r\n      prevTrackSizeRef.current !== 0 &&\r\n      prevTrackSizeRef.current !== trackSize\r\n    ) {\r\n      const container = containerRef.current;\r\n      if (container && !scrollControlRef.current.isProgrammatic) {\r\n        const targetScrollPos =\r\n          getScrollPositionForSnapPoint(activeSnapPointIndex);\r\n        const prevScrollBehavior = container.style.scrollBehavior;\r\n\r\n        container.style.scrollBehavior = \"auto\";\r\n        if (isVertical) {\r\n          container.scrollTop = targetScrollPos;\r\n        } else {\r\n          container.scrollLeft = targetScrollPos;\r\n        }\r\n        container.style.scrollBehavior = prevScrollBehavior;\r\n      }\r\n    }\r\n\r\n    prevTrackSizeRef.current = trackSize;\r\n  }, [\r\n    open,\r\n    geometry,\r\n    isVertical,\r\n    activeSnapPointIndex,\r\n    getScrollPositionForSnapPoint,\r\n  ]);\r\n\r\n  React.useEffect(() => {\r\n    const container = containerRef.current;\r\n    if (!container || !open) return;\r\n\r\n    container.addEventListener(\"scroll\", handleScroll, { passive: true });\r\n    container.addEventListener(\"touchstart\", handleTouchStart, {\r\n      passive: true,\r\n    });\r\n    container.addEventListener(\"touchend\", handleTouchEnd, { passive: true });\r\n    container.addEventListener(\"touchcancel\", handleTouchEnd, {\r\n      passive: true,\r\n    });\r\n\r\n    if (supportsScrollEnd) {\r\n      container.addEventListener(\"scrollend\", handleScrollEnd);\r\n    }\r\n\r\n    if (supportsScrollSnapChange) {\r\n      container.addEventListener(\"scrollsnapchange\", handleScrollSnapChange);\r\n    }\r\n\r\n    const updateViewportSize = () => {\r\n      const size = isVertical ? container.clientHeight : container.clientWidth;\r\n      setViewportSize(size);\r\n    };\r\n    window.addEventListener(\"resize\", updateViewportSize);\r\n\r\n    return () => {\r\n      container.removeEventListener(\"scroll\", handleScroll);\r\n      container.removeEventListener(\"touchstart\", handleTouchStart);\r\n      container.removeEventListener(\"touchend\", handleTouchEnd);\r\n      container.removeEventListener(\"touchcancel\", handleTouchEnd);\r\n\r\n      if (supportsScrollEnd) {\r\n        container.removeEventListener(\"scrollend\", handleScrollEnd);\r\n      }\r\n\r\n      if (supportsScrollSnapChange) {\r\n        container.removeEventListener(\r\n          \"scrollsnapchange\",\r\n          handleScrollSnapChange,\r\n        );\r\n      }\r\n\r\n      window.removeEventListener(\"resize\", updateViewportSize);\r\n    };\r\n  }, [\r\n    open,\r\n    isVertical,\r\n    handleScroll,\r\n    handleScrollEnd,\r\n    handleScrollSnapChange,\r\n    handleTouchStart,\r\n    handleTouchEnd,\r\n  ]);\r\n\r\n  const setSnapTargetRef = React.useCallback(\r\n    (index: number, el: HTMLDivElement | null) => {\r\n      snapTargetRefs.current[index] = el;\r\n    },\r\n    [],\r\n  );\r\n\r\n  return {\r\n    containerRef,\r\n    isScrolling,\r\n    setSnapTargetRef,\r\n    trackSize: geometry.trackSize,\r\n    snapScrollPositions,\r\n    isInitialized,\r\n    isClosing,\r\n  };\r\n}\r\n",
      "type": "registry:hook",
      "target": "components/ui/cubby-ui/drawer/hooks/use-scroll-snap.ts"
    },
    {
      "path": "registry/default/drawer/hooks/use-virtual-keyboard.ts",
      "content": "import * as React from \"react\";\r\n\r\nexport interface UseVirtualKeyboardOptions {\r\n  /** Whether keyboard handling is enabled */\r\n  enabled?: boolean;\r\n}\r\n\r\nexport interface UseVirtualKeyboardReturn {\r\n  /** Current keyboard height in pixels (0 when closed) */\r\n  keyboardHeight: number;\r\n  /** Whether the virtual keyboard is currently visible */\r\n  isKeyboardVisible: boolean;\r\n}\r\n\r\n/**\r\n * Helper to check if element is an input that would trigger a virtual keyboard.\r\n */\r\nfunction isInput(element: HTMLElement | null): boolean {\r\n  if (!element) return false;\r\n  const tagName = element.tagName.toLowerCase();\r\n  return (\r\n    tagName === \"input\" ||\r\n    tagName === \"textarea\" ||\r\n    tagName === \"select\" ||\r\n    element.isContentEditable\r\n  );\r\n}\r\n\r\n/**\r\n * Detect Firefox mobile which natively handles keyboard repositioning.\r\n * We skip our custom transform on Firefox to avoid double-repositioning.\r\n */\r\nconst isFirefoxMobile =\r\n  typeof navigator !== \"undefined\" &&\r\n  /Firefox/i.test(navigator.userAgent) &&\r\n  /Android|Mobile/i.test(navigator.userAgent);\r\n\r\n/**\r\n * Hook to detect virtual keyboard visibility and height using the Visual Viewport API.\r\n *\r\n * On mobile devices, when a virtual keyboard appears, it reduces the visual viewport height.\r\n * This hook tracks that change so components can adjust their layout accordingly.\r\n *\r\n * Simplified approach:\r\n * - Keyboard is visible if viewport is significantly smaller (>100px) AND an input is focused\r\n * - No complex toggle state that can get out of sync\r\n */\r\nexport function useVirtualKeyboard({\r\n  enabled = true,\r\n}: UseVirtualKeyboardOptions = {}): UseVirtualKeyboardReturn {\r\n  const [keyboardHeight, setKeyboardHeight] = React.useState(0);\r\n\r\n  React.useEffect(() => {\r\n    // Firefox mobile natively handles keyboard repositioning, so we skip\r\n    // our custom detection to avoid double-repositioning the drawer\r\n    if (!enabled || typeof window === \"undefined\" || isFirefoxMobile) return;\r\n\r\n    // Enable Virtual Keyboard API to get env(keyboard-inset-*) CSS variables\r\n    // This tells the browser that we'll handle the virtual keyboard geometry ourselves\r\n    if (\"virtualKeyboard\" in navigator) {\r\n      (navigator as Navigator & { virtualKeyboard: { overlaysContent: boolean } })\r\n        .virtualKeyboard.overlaysContent = true;\r\n    }\r\n\r\n    const visualViewport = window.visualViewport;\r\n    if (!visualViewport) return;\r\n\r\n    const handleResize = () => {\r\n      const focusedElement = document.activeElement as HTMLElement;\r\n      const isInputFocused = isInput(focusedElement);\r\n\r\n      // If no input is focused, keyboard can't be open for our purposes\r\n      if (!isInputFocused) {\r\n        setKeyboardHeight(0);\r\n        return;\r\n      }\r\n\r\n      const visualViewportHeight = visualViewport.height;\r\n      const totalHeight = window.innerHeight;\r\n      const diff = totalHeight - visualViewportHeight;\r\n\r\n      // Keyboard is visible if viewport is significantly smaller (>100px threshold)\r\n      // This avoids false positives from address bar changes\r\n      if (diff > 100) {\r\n        setKeyboardHeight(diff);\r\n      } else {\r\n        setKeyboardHeight(0);\r\n      }\r\n    };\r\n\r\n    visualViewport.addEventListener(\"resize\", handleResize);\r\n\r\n    // Initial check in case keyboard is already open\r\n    handleResize();\r\n\r\n    return () => visualViewport.removeEventListener(\"resize\", handleResize);\r\n  }, [enabled]);\r\n\r\n  return {\r\n    keyboardHeight,\r\n    isKeyboardVisible: keyboardHeight > 0,\r\n  };\r\n}\r\n",
      "type": "registry:hook",
      "target": "components/ui/cubby-ui/drawer/hooks/use-virtual-keyboard.ts"
    },
    {
      "path": "registry/default/drawer/hooks/use-visual-viewport-height.ts",
      "content": "import * as React from \"react\";\r\n\r\nexport interface UseVisualViewportHeightOptions {\r\n  /** Whether tracking is enabled */\r\n  enabled?: boolean;\r\n}\r\n\r\n/**\r\n * Hook to track the visual viewport height using the Visual Viewport API.\r\n *\r\n * On mobile devices, the visual viewport height changes when the URL bar\r\n * collapses/expands. This hook provides real-time tracking of the actual\r\n * visible viewport height, which can be used to size elements that need\r\n * to fill the visible area regardless of URL bar state.\r\n *\r\n * @returns The current visual viewport height in pixels, or null if not available\r\n */\r\nexport function useVisualViewportHeight({\r\n  enabled = true,\r\n}: UseVisualViewportHeightOptions = {}): number | null {\r\n  const [height, setHeight] = React.useState<number | null>(() => {\r\n    if (typeof window === \"undefined\") return null;\r\n    return window.visualViewport?.height ?? null;\r\n  });\r\n\r\n  React.useEffect(() => {\r\n    if (!enabled || typeof window === \"undefined\") return;\r\n\r\n    const visualViewport = window.visualViewport;\r\n    if (!visualViewport) return;\r\n\r\n    const handleResize = () => {\r\n      setHeight(visualViewport.height);\r\n    };\r\n\r\n    // Set initial value\r\n    handleResize();\r\n\r\n    visualViewport.addEventListener(\"resize\", handleResize);\r\n    return () => visualViewport.removeEventListener(\"resize\", handleResize);\r\n  }, [enabled]);\r\n\r\n  return height;\r\n}\r\n",
      "type": "registry:hook",
      "target": "components/ui/cubby-ui/drawer/hooks/use-visual-viewport-height.ts"
    },
    {
      "path": "registry/default/drawer/drawer.css",
      "content": "/* Scroll-Driven Animations (Chrome 115+, Safari 26+, Firefox flag-only) */\r\n\r\n/**\r\n * Consumers can animate based on snap progress:\r\n * .mini-player { opacity: calc(1 - var(--drawer-snap-progress, 0)); }\r\n */\r\n@property --drawer-snap-progress {\r\n  syntax: \"<number>\";\r\n  inherits: true;\r\n  initial-value: 0;\r\n}\r\n\r\n@keyframes drawer-snap-progress {\r\n  from {\r\n    --drawer-snap-progress: 0;\r\n  }\r\n  to {\r\n    --drawer-snap-progress: 1;\r\n  }\r\n}\r\n\r\n@keyframes drawer-backdrop-fade {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n/* Overrides scroll-driven animation on exit (transitions can't interpolate from animation values) */\r\n@keyframes drawer-backdrop-exit {\r\n  to {\r\n    opacity: 0;\r\n  }\r\n}\r\n\r\n/* Horizontal drawers: prevent page scroll interference */\r\nhtml:has([data-slot=\"drawer-viewport\"][data-direction=\"left\"]),\r\nhtml:has([data-slot=\"drawer-viewport\"][data-direction=\"right\"]) {\r\n  overscroll-behavior: none;\r\n  scrollbar-width: none;\r\n}\r\n\r\nhtml:has(\r\n    [data-slot=\"drawer-viewport\"][data-direction=\"left\"]\r\n  )::-webkit-scrollbar,\r\nhtml:has(\r\n    [data-slot=\"drawer-viewport\"][data-direction=\"right\"]\r\n  )::-webkit-scrollbar {\r\n  display: none !important;\r\n}\r\n",
      "type": "registry:file",
      "target": "components/ui/cubby-ui/drawer/drawer.css"
    }
  ]
}