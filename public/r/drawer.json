{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "drawer",
  "type": "registry:ui",
  "title": "Drawer",
  "description": "A drawer component.",
  "files": [
    {
      "path": "registry/default/drawer/drawer.tsx",
      "content": "\"use client\";\r\n\r\nimport * as React from \"react\";\r\nimport { Dialog as BaseDialog } from \"@base-ui-components/react/dialog\";\r\nimport { mergeProps } from \"@base-ui-components/react/merge-props\";\r\nimport { useRender } from \"@base-ui-components/react/use-render\";\r\n\r\nimport { cn } from \"@/lib/utils\";\r\n\r\n// Drawer-specific CSS animations (scroll-driven animations for progressive enhancement)\r\nimport \"./drawer.css\";\r\n\r\nimport type { SnapPoint, DrawerDirection } from \"./hooks/use-snap-points\";\r\nimport {\r\n  useScrollSnap,\r\n  supportsScrollTimeline,\r\n  supportsScrollState,\r\n} from \"./hooks/use-scroll-snap\";\r\nimport { useVirtualKeyboard } from \"./hooks/use-virtual-keyboard\";\r\nimport { useBodyScrollLock } from \"./hooks/use-body-scroll-lock\";\r\n\r\n// Re-export types for consumers\r\nexport type { SnapPoint, DrawerDirection };\r\n\r\n/**\r\n * Parse a pixel value string (e.g., \"200px\") and return the number\r\n */\r\nfunction parsePixelValue(value: string): number | null {\r\n  const match = value.match(/^(\\d+(?:\\.\\d+)?)px$/);\r\n  return match ? parseFloat(match[1]) : null;\r\n}\r\n\r\n/**\r\n * Find the index of a snap point value in the array\r\n * Returns the last index if value is null or not found\r\n */\r\nfunction findSnapPointIndex(\r\n  snapPoints: SnapPoint[],\r\n  value: SnapPoint | null,\r\n): number {\r\n  if (value === null) return snapPoints.length - 1;\r\n  const index = snapPoints.findIndex((sp) => sp === value);\r\n  return index === -1 ? snapPoints.length - 1 : index;\r\n}\r\n\r\n/**\r\n * Get the snap point value at a given index (clamped to valid range)\r\n */\r\nfunction getSnapPointValue(snapPoints: SnapPoint[], index: number): SnapPoint {\r\n  return snapPoints[Math.max(0, Math.min(index, snapPoints.length - 1))];\r\n}\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * Drawer Context\r\n * -------------------------------------------------------------------------------------------------*/\r\n\r\ninterface DrawerContextValue {\r\n  direction: DrawerDirection;\r\n  snapPoints: SnapPoint[];\r\n  activeSnapPoint: SnapPoint;\r\n  setActiveSnapPoint: (snapPoint: SnapPoint) => void;\r\n  dismissible: boolean;\r\n  isDragging: boolean;\r\n  setIsDragging: (dragging: boolean) => void;\r\n  dragProgress: number;\r\n  setDragProgress: (progress: number) => void;\r\n  /** Progress between snap points (0 = first snap, 1 = last snap) */\r\n  snapProgress: number;\r\n  setSnapProgress: (progress: number) => void;\r\n  open: boolean;\r\n  onOpenChange: (open: boolean, eventDetails?: { reason?: string }) => void;\r\n\r\n  contentSize: number | null;\r\n  setContentSize: (size: number | null) => void;\r\n  isVertical: boolean;\r\n  isAnimating: boolean;\r\n  immediateClose: boolean;\r\n  setImmediateClose: (value: boolean) => void;\r\n  sequentialSnap: boolean;\r\n}\r\n\r\nconst DrawerContext = React.createContext<DrawerContextValue | null>(null);\r\n\r\nfunction useDrawer() {\r\n  const context = React.useContext(DrawerContext);\r\n  if (!context) {\r\n    throw new Error(\"Drawer components must be used within a <Drawer />\");\r\n  }\r\n  return context;\r\n}\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * Drawer (Root)\r\n * -------------------------------------------------------------------------------------------------*/\r\n\r\n/** Props passed to render function children */\r\ninterface DrawerRenderProps {\r\n  /** Progress between snap points (0 = first snap, 1 = last snap) */\r\n  snapProgress: number;\r\n  /** Progress toward closed (0 = open, 1 = closed) */\r\n  dragProgress: number;\r\n  /** Whether currently being dragged/scrolled */\r\n  isDragging: boolean;\r\n  /** Current active snap point value */\r\n  activeSnapPoint: SnapPoint;\r\n}\r\n\r\ninterface DrawerProps\r\n  extends Omit<\r\n    React.ComponentProps<typeof BaseDialog.Root>,\r\n    \"modal\" | \"children\"\r\n  > {\r\n  /** Direction the drawer opens from. Default: \"bottom\" */\r\n  direction?: DrawerDirection;\r\n  /** Snap points as percentages (0-1) or pixel values. Default: [1] (fully open) */\r\n  snapPoints?: SnapPoint[];\r\n  /** Initial snap point value when opened. Default: first snap point */\r\n  defaultSnapPoint?: SnapPoint;\r\n  /** Controlled snap point value (the actual value, not index) */\r\n  activeSnapPoint?: SnapPoint | null;\r\n  /** Callback when snap point changes - receives the actual value */\r\n  onActiveSnapPointChange?: (snapPoint: SnapPoint) => void;\r\n  /** Whether dismissible by swipe. Default: true */\r\n  dismissible?: boolean;\r\n\r\n  /** When true, prevents skipping snap points during fast swipes. Default: false */\r\n  sequentialSnap?: boolean;\r\n  /** Children - can be ReactNode or render function for access to drag state */\r\n  children?: React.ReactNode | ((props: DrawerRenderProps) => React.ReactNode);\r\n}\r\n\r\nfunction Drawer({\r\n  direction = \"bottom\",\r\n  snapPoints = [1],\r\n  defaultSnapPoint,\r\n  activeSnapPoint: controlledSnapPoint,\r\n  onActiveSnapPointChange,\r\n  dismissible = true,\r\n  sequentialSnap = false,\r\n  open: controlledOpen,\r\n  defaultOpen,\r\n  onOpenChange: controlledOnOpenChange,\r\n  children,\r\n  ...props\r\n}: DrawerProps) {\r\n  // Internal open state (uncontrolled mode)\r\n  const [uncontrolledOpen, setUncontrolledOpen] = React.useState(\r\n    defaultOpen ?? false,\r\n  );\r\n  const isOpenControlled = controlledOpen !== undefined;\r\n  const open = isOpenControlled ? controlledOpen : uncontrolledOpen;\r\n\r\n  // Convert default value to index (defaults to first snap point)\r\n  const defaultSnapPointIndex =\r\n    defaultSnapPoint !== undefined\r\n      ? findSnapPointIndex(snapPoints, defaultSnapPoint)\r\n      : 0;\r\n\r\n  // Internal snap point state (uses index internally)\r\n  const [internalSnapPointIndex, setInternalSnapPointIndex] = React.useState(\r\n    defaultSnapPointIndex,\r\n  );\r\n\r\n  // Controlled mode: convert value to index\r\n  const isSnapPointControlled = controlledSnapPoint !== undefined;\r\n  const activeSnapPointIndex = isSnapPointControlled\r\n    ? findSnapPointIndex(snapPoints, controlledSnapPoint)\r\n    : internalSnapPointIndex;\r\n\r\n  // The actual value for context\r\n  const activeSnapPointValue = getSnapPointValue(\r\n    snapPoints,\r\n    activeSnapPointIndex,\r\n  );\r\n\r\n  // Drag state (now represents scroll state)\r\n  const [isDragging, setIsDragging] = React.useState(false);\r\n  // Start at 1 (backdrop invisible) - will be updated by scroll events\r\n  const [dragProgress, setDragProgress] = React.useState(1);\r\n  // Progress between snap points (0 = first snap, 1 = last snap)\r\n  const [snapProgress, setSnapProgress] = React.useState(0);\r\n\r\n  // Content size for measurements (set by DrawerContent)\r\n  const [contentSize, setContentSize] = React.useState<number | null>(null);\r\n\r\n  // Track CSS animation state to prevent interaction during transitions\r\n  const [isAnimating, setIsAnimating] = React.useState(false);\r\n\r\n  // Track immediate close for swipe dismiss (skip exit animation)\r\n  const [immediateClose, setImmediateClose] = React.useState(false);\r\n\r\n  const isVertical = direction === \"top\" || direction === \"bottom\";\r\n\r\n  // Clear animating when CSS animation completes\r\n  const handleOpenChangeComplete = React.useCallback(() => {\r\n    setIsAnimating(false);\r\n  }, []);\r\n\r\n  // Lock body scroll when drawer is open or animating (prevents URL bar collapse/expand on mobile)\r\n  // Keep locked during exit animation so page can't be scrolled until animation completes\r\n  // useBodyScrollLock(open || isAnimating);\r\n\r\n  // Handle open change\r\n  const handleOpenChange = React.useCallback(\r\n    (nextOpen: boolean, eventDetails?: { reason?: string }) => {\r\n      // Prevent state changes during animations (user can't interrupt enter/exit)\r\n      if (isAnimating) return;\r\n      // Prevent closing while actively scrolling/dragging (swipe momentum)\r\n      // BUT allow swipe dismiss (which passes reason: \"swipe-dismiss\")\r\n      if (!nextOpen && isDragging && eventDetails?.reason !== \"swipe-dismiss\")\r\n        return;\r\n\r\n      // Start animation state - will be cleared by onOpenChangeComplete\r\n      setIsAnimating(true);\r\n\r\n      if (!isOpenControlled) {\r\n        setUncontrolledOpen(nextOpen);\r\n      }\r\n      controlledOnOpenChange?.(nextOpen, eventDetails as never);\r\n\r\n      // Reset to default snap point when opening (only in uncontrolled mode)\r\n      if (nextOpen && !isSnapPointControlled) {\r\n        setInternalSnapPointIndex(defaultSnapPointIndex);\r\n        const defaultSnapValue = getSnapPointValue(\r\n          snapPoints,\r\n          defaultSnapPointIndex,\r\n        );\r\n        onActiveSnapPointChange?.(defaultSnapValue);\r\n      }\r\n\r\n      // Reset drag progress when opening (backdrop starts invisible, fades in with drawer)\r\n      if (nextOpen) {\r\n        setDragProgress(1); // 1 = closed/invisible, will animate to 0 = open/visible\r\n        // Only reset snapProgress in uncontrolled mode\r\n        // Controlled mode: scroll handler will set correct value when drawer positions itself\r\n        if (!isSnapPointControlled) {\r\n          // Calculate snapProgress based on default snap point\r\n          const progress =\r\n            snapPoints.length > 1\r\n              ? defaultSnapPointIndex / (snapPoints.length - 1)\r\n              : 0;\r\n          setSnapProgress(progress);\r\n        }\r\n        setImmediateClose(false); // Reset immediate close flag\r\n      }\r\n    },\r\n    [\r\n      isAnimating,\r\n      isDragging,\r\n      isOpenControlled,\r\n      controlledOnOpenChange,\r\n      snapPoints,\r\n      isSnapPointControlled,\r\n      onActiveSnapPointChange,\r\n      defaultSnapPointIndex,\r\n    ],\r\n  );\r\n\r\n  // Handle snap point change (accepts value, converts to index internally)\r\n  const setActiveSnapPoint = React.useCallback(\r\n    (value: SnapPoint) => {\r\n      const index = findSnapPointIndex(snapPoints, value);\r\n      if (!isSnapPointControlled) {\r\n        setInternalSnapPointIndex(index);\r\n      }\r\n      onActiveSnapPointChange?.(value);\r\n    },\r\n    [snapPoints, isSnapPointControlled, onActiveSnapPointChange],\r\n  );\r\n\r\n  const contextValue = React.useMemo(\r\n    () => ({\r\n      direction,\r\n      snapPoints,\r\n      activeSnapPoint: activeSnapPointValue,\r\n      setActiveSnapPoint,\r\n      dismissible,\r\n      isDragging,\r\n      setIsDragging,\r\n      dragProgress,\r\n      setDragProgress,\r\n      snapProgress,\r\n      setSnapProgress,\r\n      open,\r\n      onOpenChange: handleOpenChange,\r\n      contentSize,\r\n      setContentSize,\r\n      isVertical,\r\n      isAnimating,\r\n      immediateClose,\r\n      setImmediateClose,\r\n      sequentialSnap,\r\n    }),\r\n    [\r\n      direction,\r\n      snapPoints,\r\n      activeSnapPointValue,\r\n      setActiveSnapPoint,\r\n      dismissible,\r\n      isDragging,\r\n      dragProgress,\r\n      snapProgress,\r\n      open,\r\n      handleOpenChange,\r\n      contentSize,\r\n      isVertical,\r\n      isAnimating,\r\n      immediateClose,\r\n      sequentialSnap,\r\n    ],\r\n  );\r\n\r\n  // Resolve render function children\r\n  const resolvedChildren =\r\n    typeof children === \"function\"\r\n      ? children({\r\n          snapProgress,\r\n          dragProgress,\r\n          isDragging,\r\n          activeSnapPoint: activeSnapPointValue,\r\n        })\r\n      : children;\r\n\r\n  return (\r\n    <DrawerContext.Provider value={contextValue}>\r\n      <BaseDialog.Root\r\n        data-slot=\"drawer\"\r\n        open={open}\r\n        onOpenChange={handleOpenChange}\r\n        onOpenChangeComplete={handleOpenChangeComplete}\r\n        // Use \"trap-focus\" to keep focus trapping but let us handle scroll lock\r\n        // (modal={true} has its own scroll lock that conflicts with ours)\r\n        // modal=\"trap-focus\"\r\n        // modal={true}\r\n        {...props}\r\n      >\r\n        {resolvedChildren}\r\n      </BaseDialog.Root>\r\n    </DrawerContext.Provider>\r\n  );\r\n}\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * DrawerTrigger\r\n * -------------------------------------------------------------------------------------------------*/\r\n\r\nfunction DrawerTrigger({\r\n  ...props\r\n}: React.ComponentProps<typeof BaseDialog.Trigger>) {\r\n  return <BaseDialog.Trigger data-slot=\"drawer-trigger\" {...props} />;\r\n}\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * DrawerClose\r\n * -------------------------------------------------------------------------------------------------*/\r\n\r\ninterface DrawerCloseProps extends useRender.ComponentProps<\"button\"> {\r\n  onClick?: (event: React.MouseEvent) => void;\r\n}\r\n\r\nfunction DrawerClose({\r\n  onClick,\r\n  className,\r\n  render,\r\n  ...props\r\n}: DrawerCloseProps) {\r\n  const { onOpenChange, isAnimating } = useDrawer();\r\n\r\n  const handleClick = React.useCallback(\r\n    (event: React.MouseEvent) => {\r\n      onClick?.(event);\r\n      if (event.defaultPrevented) return;\r\n      // Prevent closing during animations\r\n      if (isAnimating) return;\r\n\r\n      // Let Base UI handle the exit animation via data-ending-style\r\n      onOpenChange(false);\r\n    },\r\n    [onClick, onOpenChange, isAnimating],\r\n  );\r\n\r\n  // Don't use BaseDialog.Close - it has its own close handler that bypasses our animation\r\n  const mergedProps = mergeProps<\"button\">(\r\n    {\r\n      type: \"button\",\r\n      className,\r\n      onClick: handleClick,\r\n    } as React.ComponentProps<\"button\">,\r\n    props,\r\n  );\r\n\r\n  const element = useRender({\r\n    render,\r\n    defaultTagName: \"button\",\r\n    props: { ...mergedProps, \"data-slot\": \"drawer-close\" },\r\n  });\r\n\r\n  return element;\r\n}\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * DrawerPortal\r\n * -------------------------------------------------------------------------------------------------*/\r\n\r\nfunction DrawerPortal({\r\n  ...props\r\n}: React.ComponentProps<typeof BaseDialog.Portal>) {\r\n  return <BaseDialog.Portal data-slot=\"drawer-portal\" {...props} />;\r\n}\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * DrawerContent\r\n * -------------------------------------------------------------------------------------------------*/\r\n\r\nfunction DrawerContent({\r\n  className,\r\n  children,\r\n  ...props\r\n}: BaseDialog.Popup.Props) {\r\n  const {\r\n    direction,\r\n    snapPoints,\r\n    activeSnapPoint,\r\n    setActiveSnapPoint,\r\n    dismissible,\r\n    contentSize,\r\n    setContentSize,\r\n    isVertical,\r\n    setIsDragging,\r\n    dragProgress,\r\n    setDragProgress,\r\n    setSnapProgress,\r\n    onOpenChange,\r\n    open,\r\n    isAnimating,\r\n    immediateClose,\r\n    setImmediateClose,\r\n    isDragging,\r\n    sequentialSnap,\r\n  } = useDrawer();\r\n\r\n  // Derive index locally - single conversion point for hooks\r\n  const activeSnapPointIndex = findSnapPointIndex(snapPoints, activeSnapPoint);\r\n\r\n  // Handler converts index back to value for context\r\n  const handleSnapPointChange = React.useCallback(\r\n    (index: number) => {\r\n      setActiveSnapPoint(getSnapPointValue(snapPoints, index));\r\n    },\r\n    [snapPoints, setActiveSnapPoint],\r\n  );\r\n\r\n  // Virtual keyboard handling (for bottom drawers with form inputs)\r\n  const { keyboardHeight } = useVirtualKeyboard({\r\n    enabled: direction === \"bottom\",\r\n  });\r\n\r\n  // Memoize dismiss handler to prevent effect re-runs\r\n  const handleDismiss = React.useCallback(() => {\r\n    onOpenChange(false, { reason: \"swipe-dismiss\" });\r\n  }, [onOpenChange]);\r\n\r\n  // Handler for immediate close (swipe dismiss - skip exit animation)\r\n  const handleImmediateClose = React.useCallback(() => {\r\n    setImmediateClose(true);\r\n  }, [setImmediateClose]);\r\n\r\n  // Wrap scroll progress callback to skip updates during enter/exit animations\r\n  // This lets CSS transitions control the backdrop opacity during animations\r\n  const handleScrollProgress = React.useCallback(\r\n    (progress: number) => {\r\n      if (!isAnimating) {\r\n        setDragProgress(progress);\r\n      }\r\n    },\r\n    [isAnimating, setDragProgress],\r\n  );\r\n\r\n  // Wrap snap progress callback to skip updates during enter/exit animations\r\n  const handleSnapProgress = React.useCallback(\r\n    (progress: number) => {\r\n      if (!isAnimating) {\r\n        setSnapProgress(progress);\r\n      }\r\n    },\r\n    [isAnimating, setSnapProgress],\r\n  );\r\n\r\n  // Scroll snap hook - containerRef now attaches to Viewport\r\n  const {\r\n    containerRef,\r\n    isScrolling,\r\n    snapTargetRefs,\r\n    trackSize,\r\n    snapScrollPositions,\r\n    isInitialized,\r\n    isClosing,\r\n    firstSnapScrollPos,\r\n    lastSnapScrollPos,\r\n  } = useScrollSnap({\r\n    direction,\r\n    snapPoints,\r\n    activeSnapPointIndex,\r\n    onSnapPointChange: handleSnapPointChange,\r\n    onDismiss: handleDismiss,\r\n    dismissible,\r\n    contentSize,\r\n    open,\r\n    onScrollProgress: handleScrollProgress,\r\n    onSnapProgress: handleSnapProgress,\r\n    onImmediateClose: handleImmediateClose,\r\n    isAnimating,\r\n  });\r\n\r\n  // Sync scrolling state to context\r\n  React.useEffect(() => {\r\n    setIsDragging(isScrolling);\r\n  }, [isScrolling, setIsDragging]);\r\n\r\n  // Calculate snap point ratio (0-1) for backdrop opacity\r\n  // This represents how \"open\" the drawer is at the target snap point\r\n  const snapPointRatio = React.useMemo(() => {\r\n    if (typeof activeSnapPoint === \"number\") {\r\n      return activeSnapPoint;\r\n    }\r\n    // Pixel value - need contentSize to calculate ratio\r\n    const pixels = parsePixelValue(activeSnapPoint);\r\n    if (!pixels || !contentSize) return 1;\r\n    return pixels / contentSize;\r\n  }, [activeSnapPoint, contentSize]);\r\n\r\n  // Starting offset for enter/exit animations (drawer slides in by this amount)\r\n  // For pixel snap points, use the value directly (e.g., \"92px\")\r\n  // For percentage snap points, convert to percentage (e.g., 0.1 -> \"10%\")\r\n  const startingOffset =\r\n    typeof activeSnapPoint === \"number\"\r\n      ? `${activeSnapPoint * 100}%`\r\n      : activeSnapPoint;\r\n\r\n  // Target backdrop opacity based on snap point (0.25 snap = 0.25 opacity)\r\n  const targetBackdropOpacity = snapPointRatio;\r\n\r\n  // Measure the drawer content size (now measures the Popup element)\r\n  const observerRef = React.useRef<ResizeObserver | null>(null);\r\n\r\n  const measureRef = React.useCallback(\r\n    (node: HTMLDivElement | null) => {\r\n      // Cleanup previous observer\r\n      observerRef.current?.disconnect();\r\n      observerRef.current = null;\r\n\r\n      if (!node) return;\r\n\r\n      const measure = () => {\r\n        setContentSize(isVertical ? node.offsetHeight : node.offsetWidth);\r\n      };\r\n\r\n      measure();\r\n      observerRef.current = new ResizeObserver(measure);\r\n      observerRef.current.observe(node);\r\n    },\r\n    [isVertical, setContentSize],\r\n  );\r\n\r\n  // Cleanup on unmount\r\n  React.useEffect(() => () => observerRef.current?.disconnect(), []);\r\n\r\n  // Determine if scroll-driven animations should be active\r\n  // Requires: browser support + initialized + not during enter/exit animation\r\n  const useScrollDrivenAnimation =\r\n    supportsScrollTimeline && isInitialized && !isAnimating && !immediateClose;\r\n\r\n  return (\r\n    <DrawerPortal>\r\n      {/* Timeline scope wrapper - enables cross-element timeline references */}\r\n      {/* Required for backdrop to reference drawer panel's view timeline */}\r\n      <div\r\n        style={\r\n          supportsScrollTimeline\r\n            ? ({ timelineScope: \"--drawer-panel\" } as React.CSSProperties)\r\n            : undefined\r\n        }\r\n      >\r\n        {/* Backdrop - view-driven opacity (Chrome 115+) with JS fallback */}\r\n        <BaseDialog.Backdrop\r\n          data-slot=\"drawer-overlay\"\r\n          className={cn(\r\n            \"absolute inset-0 z-40 bg-black/35\",\r\n            // Force GPU layer to prevent repaint flicker\r\n            \"[transform:translateZ(0)] will-change-[opacity]\",\r\n            // Disable pointer events during closing to avoid interfering with swipe dismiss\r\n            isClosing ? \"pointer-events-none\" : \"pointer-events-auto\",\r\n            // Prevent touch-drag on backdrop from scrolling the page underneath\r\n            \"touch-none\",\r\n            // Transition for smooth enter/exit (skip on immediate close or while dragging)\r\n            immediateClose || (isDragging && !isAnimating)\r\n              ? \"transition-none\"\r\n              : \"ease-[cubic-bezier(0, 0, 0.58, 1)] transition-opacity duration-450\",\r\n            // Enter: start at opacity 0, transition animates to target\r\n            \"[&[data-starting-style]]:opacity-0!\",\r\n            // Exit: use animation to override scroll-driven animation (transition can't interpolate from animation-held values)\r\n            \"[&[data-ending-style]]:[animation:drawer-backdrop-exit_450ms_cubic-bezier(0,0,0.58,1)_forwards]\",\r\n\r\n            isInitialized && !isAnimating && dragProgress < 1\r\n              ? useScrollDrivenAnimation\r\n                ? // Scroll-driven backdrop animation (Chrome 115+)\r\n                  // Bottom/Right: drawer enters from below/right → use entry range (0→1 opacity)\r\n                  // Top/Left: drawer exits toward top/left → use exit range with reversed keyframe (1→0 opacity)\r\n                  direction === \"top\" || direction === \"left\"\r\n                  ? \"[animation-fill-mode:both] [animation-name:drawer-backdrop-fade-reverse] [animation-range:exit_0%_exit_100%] [animation-timeline:--drawer-panel] [animation-timing-function:linear]\"\r\n                  : \"[animation-fill-mode:both] [animation-name:drawer-backdrop-fade] [animation-range:entry_0%_entry_100%] [animation-timeline:--drawer-panel] [animation-timing-function:linear]\"\r\n                : `opacity-(--drawer-backdrop-dynamic-opacity)`\r\n              : `opacity-(--drawer-backdrop-static-opacity)`,\r\n          )}\r\n          style={\r\n            {\r\n              \"--drawer-backdrop-dynamic-opacity\": 1 - dragProgress,\r\n              \"--drawer-backdrop-static-opacity\": targetBackdropOpacity,\r\n            } as React.CSSProperties\r\n          }\r\n        />\r\n\r\n        {/* Viewport - scroll container for scroll-snap gestures */}\r\n        <BaseDialog.Viewport\r\n          ref={containerRef}\r\n          data-slot=\"drawer-viewport\"\r\n          data-direction={direction}\r\n          data-scrolling={isScrolling || undefined}\r\n          className={cn(\r\n            // Group for propagating data-starting-style/data-ending-style to children\r\n            \"group/drawer\",\r\n            // Fixed positioning for the scroll container\r\n            \"fixed z-50 outline-hidden\",\r\n            // Extra 60px height prevents URL bar from responding to touch gestures\r\n            // Offset position so extra space is outside viewport (prevents content cutoff)\r\n            \"left-0 w-dvw\",\r\n            direction === \"bottom\" && \"-top-[60px]\",\r\n            direction === \"top\" && \"top-0\",\r\n            direction === \"left\" && \"top-0\",\r\n            direction === \"right\" && \"top-0\",\r\n            // Disable all interaction when animating or closing\r\n            isAnimating || isClosing\r\n              ? \"pointer-events-none\"\r\n              : \"pointer-events-auto\",\r\n            // Prevent Base UI's default animation and ensure transparent background\r\n            \"bg-transparent opacity-100! [&[data-ending-style]]:opacity-100! [&[data-starting-style]]:opacity-100!\",\r\n            // Transform transition for exit animation - Base UI detects this and waits before removing\r\n            // Skip transition on immediate close (swipe dismiss)\r\n            immediateClose\r\n              ? \"transition-none\"\r\n              : \"ease-[cubic-bezier(0, 0, 0.58, 1)] transition-transform duration-450\",\r\n\r\n            // Hide scrollbar\r\n            \"[scrollbar-width:none] [&::-webkit-scrollbar]:hidden\",\r\n            // Scroll snap configuration - disable scrolling when animating or closing\r\n            isAnimating || isClosing\r\n              ? \"overflow-hidden\"\r\n              : isVertical\r\n                ? \"overflow-y-scroll\"\r\n                : \"overflow-x-scroll\",\r\n            isAnimating || isClosing\r\n              ? \"overflow-hidden\"\r\n              : isVertical\r\n                ? \"overflow-x-hidden\"\r\n                : \"overflow-y-hidden\",\r\n            // Prevent scroll chaining to parent (none is more aggressive than contain)\r\n            \"overscroll-none\",\r\n            // Constrain touch gestures to drawer scroll direction only (prevents URL bar collapse/expand)\r\n            isVertical ? \"touch-pan-y\" : \"touch-pan-x\",\r\n            // Reduced motion: instant behavior\r\n            \"motion-reduce:[scroll-behavior:auto]\",\r\n            // Progressive enhancement for viewport height via Tailwind arbitrary variants:\r\n            // 1. Default: vh fallback for old browsers (Firefox old, IE)\r\n            isVertical ? \"h-[calc(100vh+60px)]\" : \"h-[100vh]\",\r\n            // 2. Modern browsers: dvh adjusts with URL bar (Android Chrome)\r\n            isVertical && \"[@supports(height:1dvh)]:h-[calc(100dvh+60px)]\",\r\n            !isVertical && \"[@supports(height:1dvh)]:h-dvh\",\r\n            // 3. Safari: max(dvh, lvh) - self-detects iOS SFSafariViewController bug\r\n            // Normal iOS Safari: lvh > dvh → picks lvh (stable)\r\n            // Buggy iOS in-app browser: lvh < dvh → picks dvh (workaround)\r\n            isVertical &&\r\n              \"[@supports(-webkit-touch-callout:none)]:h-[calc(max(100dvh,100lvh)+60px)]\",\r\n            !isVertical &&\r\n              \"[@supports(-webkit-touch-callout:none)]:h-[max(100dvh,100lvh)]\",\r\n          )}\r\n          style={\r\n            {\r\n              scrollSnapType: isVertical ? \"y mandatory\" : \"x mandatory\",\r\n              scrollBehavior: \"smooth\",\r\n              // Constrain touch to scroll direction only (prevents URL bar collapse on mobile)\r\n              // Disable touch entirely during animations or closing\r\n              touchAction:\r\n                isAnimating || isClosing\r\n                  ? \"none\"\r\n                  : isVertical\r\n                    ? \"pan-y\"\r\n                    : \"pan-x\",\r\n              // Adjust for keyboard on bottom drawer\r\n              paddingBottom:\r\n                direction === \"bottom\" && keyboardHeight > 0\r\n                  ? `${keyboardHeight}px`\r\n                  : undefined,\r\n              // Animate --drawer-snap-progress CSS custom property (Chrome 115+)\r\n              // Consumers can use: opacity: var(--drawer-snap-progress) for crossfades\r\n              ...(useScrollDrivenAnimation && {\r\n                animationName: \"drawer-snap-progress\",\r\n                animationTimingFunction: \"linear\",\r\n                animationFillMode: \"both\",\r\n                animationTimeline: \"scroll(self)\",\r\n                animationRange: `${firstSnapScrollPos}px ${lastSnapScrollPos}px`,\r\n              }),\r\n            } as React.CSSProperties\r\n          }\r\n        >\r\n          {/* Scroll track - creates the scrollable area */}\r\n          <div\r\n            data-slot=\"drawer-track\"\r\n            className={cn(\r\n              \"pointer-events-none relative\",\r\n              // Track sizing\r\n              isVertical ? \"w-full\" : \"h-full\",\r\n              // Flex layout to position drawer\r\n              // Bottom/Right: drawer at end, scroll 0 = hidden\r\n              // Top/Left: drawer at start, scroll MAX = hidden (inverted)\r\n              \"flex\",\r\n              direction === \"bottom\" && \"flex-col justify-end\",\r\n              direction === \"top\" && \"flex-col justify-start\",\r\n              direction === \"right\" && \"flex-row justify-end\",\r\n              direction === \"left\" && \"flex-row justify-start\",\r\n            )}\r\n            style={{\r\n              // Track size: creates the scrollable space\r\n              [isVertical ? \"height\" : \"width\"]: `${trackSize}px`,\r\n            }}\r\n          >\r\n            {/* Snap targets - invisible elements for scroll-snap-align */}\r\n            {/* Also serve as scroll-state containers for CSS queries (Chrome 133+) */}\r\n            {snapScrollPositions.map((position, index) => (\r\n              <div\r\n                key={index}\r\n                ref={(el) => {\r\n                  snapTargetRefs.current[index] = el;\r\n                }}\r\n                data-slot=\"drawer-snap-target\"\r\n                data-snap-index={index}\r\n                className={cn(\r\n                  \"pointer-events-none absolute\",\r\n                  isVertical ? \"right-0 left-0 h-px\" : \"top-0 bottom-0 w-px\",\r\n                )}\r\n                style={\r\n                  {\r\n                    [isVertical ? \"top\" : \"left\"]: `${position}px`,\r\n                    scrollSnapAlign: \"start\",\r\n                    scrollSnapStop: sequentialSnap ? \"always\" : undefined,\r\n                    // CSS scroll-state() container queries (Chrome 133+)\r\n                    // Enables: @container scroll-state(snapped: block) { ... }\r\n                    ...(supportsScrollState && {\r\n                      containerType: \"scroll-state\",\r\n                    }),\r\n                  } as React.CSSProperties\r\n                }\r\n                aria-hidden=\"true\"\r\n              />\r\n            ))}\r\n\r\n            {/* Popup - the actual drawer panel (dialog element with accessibility) */}\r\n            <BaseDialog.Popup\r\n              ref={measureRef}\r\n              data-slot=\"drawer-content\"\r\n              className={cn(\r\n                // Base styles\r\n                \"bg-popover text-popover-foreground flex flex-col\",\r\n                // Positioning and layering\r\n                \"relative z-10\",\r\n                // Hide until scroll is initialized to prevent flash at wrong position (iOS Safari)\r\n                // Only apply when opening (open=true), not during close animation\r\n                open && !isInitialized && \"invisible\",\r\n                // Disable pointer events during enter/exit animations to prevent interruption\r\n                isAnimating || isClosing\r\n                  ? \"pointer-events-none\"\r\n                  : \"pointer-events-auto\",\r\n                // Direction-specific styling (use dvh for mobile)\r\n                direction === \"bottom\" && \"max-h-[95dvh] w-full rounded-t-xl\",\r\n                direction === \"top\" && \"max-h-[95dvh] w-full rounded-b-xl\",\r\n                direction === \"right\" && \"h-dvh w-[85vw] max-w-md rounded-l-xl\",\r\n                direction === \"left\" && \"h-dvh w-[85vw] max-w-md rounded-r-xl\",\r\n                // Shadow and border\r\n                // \"border-transparent ring-1 ring-transparent outline-transparent\",\r\n                // direction === \"bottom\" && \"border-t\",\r\n                // direction === \"top\" && \"border-b\",\r\n                // direction === \"right\" && \"border-l\",\r\n                // direction === \"left\" && \"border-r\",\r\n                // CSS transitions for enter/exit animations\r\n                // Skip transition on immediate close (swipe dismiss)\r\n                immediateClose\r\n                  ? \"transition-none\"\r\n                  : \"ease-[cubic-bezier(0, 0, 0.58, 1)] transition-transform duration-450\",\r\n                // Starting style (entering) - off-screen by snap point ratio\r\n                // Uses CSS variable for dynamic offset based on target snap point\r\n                direction === \"bottom\" &&\r\n                  \"[&[data-starting-style]]:translate-y-[var(--drawer-start-offset)]\",\r\n                direction === \"top\" &&\r\n                  \"[&[data-starting-style]]:-translate-y-[var(--drawer-start-offset)]\",\r\n                direction === \"right\" &&\r\n                  \"[&[data-starting-style]]:translate-x-[var(--drawer-start-offset)]\",\r\n                direction === \"left\" &&\r\n                  \"[&[data-starting-style]]:-translate-x-[var(--drawer-start-offset)]\",\r\n                // Ending style (exiting) - off-screen by snap point ratio\r\n                // Uses same CSS variable so exit matches current snap point position\r\n                direction === \"bottom\" &&\r\n                  \"[&[data-ending-style]]:translate-y-[var(--drawer-start-offset)]\",\r\n                direction === \"top\" &&\r\n                  \"[&[data-ending-style]]:-translate-y-[var(--drawer-start-offset)]\",\r\n                direction === \"right\" &&\r\n                  \"[&[data-ending-style]]:translate-x-[var(--drawer-start-offset)]\",\r\n                direction === \"left\" &&\r\n                  \"[&[data-ending-style]]:-translate-x-[var(--drawer-start-offset)]\",\r\n                // Reduced motion: instant transitions\r\n                \"motion-reduce:transition-none\",\r\n                className,\r\n              )}\r\n              style={\r\n                {\r\n                  scrollSnapAlign: \"start\",\r\n\r\n                  // Dynamic starting offset for enter animation\r\n                  \"--drawer-start-offset\": startingOffset,\r\n\r\n                  // View timeline for backdrop animation (Chrome 115+)\r\n                  // Backdrop opacity tracks how much of drawer is visible\r\n                  ...(supportsScrollTimeline && {\r\n                    viewTimelineName: \"--drawer-panel\",\r\n                    viewTimelineAxis: isVertical ? \"block\" : \"inline\",\r\n                  }),\r\n                } as React.CSSProperties\r\n              }\r\n              {...props}\r\n            >\r\n              {children}\r\n            </BaseDialog.Popup>\r\n          </div>\r\n\r\n          {/* iOS 26 Safari: Fixed element at bottom for nav bar color detection */}\r\n          {/* Must be: within 3px of bottom, ≥80% wide, ≥3px tall */}\r\n          {/* Only visible on Safari; slides with drawer during exit */}\r\n          {(direction === \"bottom\" ||\r\n            direction === \"left\" ||\r\n            direction === \"right\") && (\r\n            <div\r\n              aria-hidden=\"true\"\r\n              className={cn(\r\n                \"bg-popover pointer-events-none fixed inset-x-0 bottom-0 hidden h-10 bg-clip-text [@supports(-webkit-touch-callout:none)]:block\",\r\n              )}\r\n            />\r\n          )}\r\n        </BaseDialog.Viewport>\r\n      </div>\r\n    </DrawerPortal>\r\n  );\r\n}\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * DrawerHandle\r\n * -------------------------------------------------------------------------------------------------*/\r\n\r\ninterface DrawerHandleProps extends React.ComponentProps<\"div\"> {\r\n  /** Hide the handle visually */\r\n  hidden?: boolean;\r\n}\r\n\r\nfunction DrawerHandle({ className, hidden, ...props }: DrawerHandleProps) {\r\n  const { direction } = useDrawer();\r\n  const isVertical = direction === \"top\" || direction === \"bottom\";\r\n\r\n  if (hidden) return null;\r\n\r\n  return (\r\n    <div\r\n      data-slot=\"drawer-handle\"\r\n      aria-hidden=\"true\"\r\n      className={cn(\r\n        \"bg-muted-foreground/30 shrink-0 rounded-full\",\r\n        isVertical ? \"mx-auto my-3 h-1.5 w-12\" : \"mx-3 my-auto h-12 w-1.5\",\r\n        className,\r\n      )}\r\n      {...props}\r\n    />\r\n  );\r\n}\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * DrawerHeader\r\n * -------------------------------------------------------------------------------------------------*/\r\n\r\nfunction DrawerHeader({ className, ...props }: React.ComponentProps<\"div\">) {\r\n  return (\r\n    <div\r\n      data-slot=\"drawer-header\"\r\n      className={cn(\"flex flex-col gap-1.5 px-4 pt-2 pb-0\", className)}\r\n      {...props}\r\n    />\r\n  );\r\n}\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * DrawerFooter\r\n * -------------------------------------------------------------------------------------------------*/\r\n\r\nfunction DrawerFooter({ className, ...props }: React.ComponentProps<\"div\">) {\r\n  return (\r\n    <div\r\n      data-slot=\"drawer-footer\"\r\n      className={cn(\"mt-auto flex flex-col gap-2 p-4\", className)}\r\n      {...props}\r\n    />\r\n  );\r\n}\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * DrawerTitle\r\n * -------------------------------------------------------------------------------------------------*/\r\n\r\nfunction DrawerTitle({\r\n  className,\r\n  ...props\r\n}: React.ComponentProps<typeof BaseDialog.Title>) {\r\n  return (\r\n    <BaseDialog.Title\r\n      data-slot=\"drawer-title\"\r\n      className={cn(\"text-foreground text-lg font-semibold\", className)}\r\n      {...props}\r\n    />\r\n  );\r\n}\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * DrawerDescription\r\n * -------------------------------------------------------------------------------------------------*/\r\n\r\nfunction DrawerDescription({\r\n  className,\r\n  ...props\r\n}: React.ComponentProps<typeof BaseDialog.Description>) {\r\n  return (\r\n    <BaseDialog.Description\r\n      data-slot=\"drawer-description\"\r\n      className={cn(\"text-muted-foreground text-sm\", className)}\r\n      {...props}\r\n    />\r\n  );\r\n}\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * DrawerBody\r\n * -------------------------------------------------------------------------------------------------*/\r\n\r\nfunction DrawerBody({ className, ...props }: React.ComponentProps<\"div\">) {\r\n  return (\r\n    <div\r\n      data-slot=\"drawer-body\"\r\n      className={cn(\"flex-1 overflow-y-auto px-4 py-2\", className)}\r\n      {...props}\r\n    />\r\n  );\r\n}\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * Exports\r\n * -------------------------------------------------------------------------------------------------*/\r\n\r\nexport {\r\n  Drawer,\r\n  DrawerTrigger,\r\n  DrawerClose,\r\n  DrawerPortal,\r\n  DrawerContent,\r\n  DrawerHandle,\r\n  DrawerHeader,\r\n  DrawerFooter,\r\n  DrawerTitle,\r\n  DrawerDescription,\r\n  DrawerBody,\r\n  useDrawer,\r\n};\r\n\r\nexport type { DrawerRenderProps };\r\n\r\n// Re-export feature detection for consumers who want to check browser support\r\nexport {\r\n  supportsScrollTimeline,\r\n  supportsScrollState,\r\n} from \"./hooks/use-scroll-snap\";\r\n",
      "type": "registry:ui",
      "target": "components/ui/cubby-ui/drawer.tsx"
    },
    {
      "path": "registry/default/drawer/lib/easing.ts",
      "content": "/**\r\n * Easing presets for drawer animations\r\n * Uses smooth ease-out curves without bounce for natural feel\r\n */\r\n\r\nexport const EASING_PRESETS = {\r\n  /** Fast, responsive animation for small movements */\r\n  snappy: {\r\n    duration: 200,\r\n    easing: \"cubic-bezier(0.32, 0.72, 0, 1)\",\r\n  },\r\n  /** Default animation for most drawer movements */\r\n  smooth: {\r\n    duration: 300,\r\n    easing: \"cubic-bezier(0.32, 0.72, 0, 1)\",\r\n  },\r\n  /** Slower animation for larger movements */\r\n  relaxed: {\r\n    duration: 400,\r\n    easing: \"cubic-bezier(0.32, 0.72, 0, 1)\",\r\n  },\r\n} as const;\r\n\r\nexport type EasingPreset = keyof typeof EASING_PRESETS;\r\n\r\n/**\r\n * Get easing configuration for a given preset\r\n */\r\nexport function getEasing(preset: EasingPreset = \"smooth\") {\r\n  return EASING_PRESETS[preset];\r\n}\r\n\r\n/**\r\n * CSS custom properties for drawer animations\r\n * These can be used in Tailwind classes or inline styles\r\n */\r\nexport const DRAWER_CSS_VARS = {\r\n  duration: \"--drawer-duration\",\r\n  easing: \"--drawer-easing\",\r\n  translate: \"--drawer-translate\",\r\n  opacity: \"--drawer-opacity\",\r\n} as const;\r\n",
      "type": "registry:lib",
      "target": "lib/cubby-ui/easing.ts"
    },
    {
      "path": "registry/default/drawer/hooks/use-body-scroll-lock.ts",
      "content": "import * as React from \"react\";\r\n\r\n/**\r\n * Lock body scroll when drawer is open\r\n * This prevents background content from scrolling on mobile and stops\r\n * URL bar from collapsing/expanding on touch gestures\r\n */\r\nexport function useBodyScrollLock(enabled: boolean) {\r\n  React.useEffect(() => {\r\n    if (!enabled) return;\r\n    const body = document.body;\r\n    const html = document.documentElement;\r\n\r\n    // Store original styles\r\n\r\n    const originalOverflow = body.style.overflow;\r\n\r\n    const originalHtmlStyles = {\r\n      overscrollBehavior: html.style.overscrollBehavior,\r\n    };\r\n\r\n    body.style.overflow = \"hidden\";\r\n    body.style.overscrollBehavior = \"none\";\r\n\r\n    html.style.overscrollBehavior = \"none\";\r\n\r\n    return () => {\r\n      // Restore original styles\r\n      body.style.overflow = originalOverflow;\r\n      html.style.overscrollBehavior = originalHtmlStyles.overscrollBehavior;\r\n    };\r\n  }, [enabled]);\r\n}\r\n",
      "type": "registry:hook",
      "target": "hooks/cubby-ui/use-body-scroll-lock.ts"
    },
    {
      "path": "registry/default/drawer/hooks/use-drawer-gesture.ts",
      "content": "import * as React from \"react\";\r\n\r\nimport type { DrawerDirection } from \"./use-snap-points\";\r\n\r\nexport interface UseDrawerGestureOptions {\r\n  /** Direction the drawer opens from */\r\n  direction: DrawerDirection;\r\n  /** Whether the drawer can be dismissed by swiping */\r\n  dismissible: boolean;\r\n  /** Current active snap point index */\r\n  activeSnapPointIndex: number;\r\n  /** Snap positions in pixels */\r\n  snapPositions: number[];\r\n  /** Maximum drag distance for progress calculation (typically content size) */\r\n  maxDragDistance: number;\r\n  /** Callback when gesture ends and a new snap point should be selected */\r\n  onSnapPointChange: (snapPointIndex: number) => void;\r\n  /** Callback when drawer should be dismissed (swipe past lowest snap point) */\r\n  onDismiss?: () => void;\r\n  /** Callback during drag with progress (0-1) */\r\n  onDragProgress?: (progress: number) => void;\r\n  /** Callback when drag starts */\r\n  onDragStart?: () => void;\r\n  /** Callback when drag ends */\r\n  onDragEnd?: () => void;\r\n  /** Velocity threshold for flick gestures (px/ms) */\r\n  velocityThreshold?: number;\r\n  /** Distance threshold to dismiss as percentage of remaining distance past lowest snap point (0-1). Default: 0.5 (50%) */\r\n  dismissThreshold?: number;\r\n  /** Whether gesture handling is enabled */\r\n  enabled?: boolean;\r\n}\r\n\r\nexport interface UseDrawerGestureReturn {\r\n  /** Props to spread on the draggable element */\r\n  gestureProps: {\r\n    onPointerDown: (e: React.PointerEvent) => void;\r\n    onPointerMove: (e: React.PointerEvent) => void;\r\n    onPointerUp: (e: React.PointerEvent) => void;\r\n    onPointerCancel: (e: React.PointerEvent) => void;\r\n  };\r\n  /** Current drag offset in pixels */\r\n  dragOffset: number;\r\n  /** Whether currently dragging */\r\n  isDragging: boolean;\r\n  /** Reset position to current snap point */\r\n  resetPosition: () => void;\r\n}\r\n\r\ninterface VelocityTracker {\r\n  positions: Array<{ position: number; time: number }>;\r\n  add: (position: number) => void;\r\n  getVelocity: () => number;\r\n  reset: () => void;\r\n}\r\n\r\nfunction createVelocityTracker(): VelocityTracker {\r\n  const positions: Array<{ position: number; time: number }> = [];\r\n  const maxSamples = 5;\r\n\r\n  return {\r\n    positions,\r\n    add(position: number) {\r\n      const now = performance.now();\r\n      positions.push({ position, time: now });\r\n      // Keep only recent samples\r\n      while (positions.length > maxSamples) {\r\n        positions.shift();\r\n      }\r\n    },\r\n    getVelocity(): number {\r\n      if (positions.length < 2) return 0;\r\n\r\n      const first = positions[0];\r\n      const last = positions[positions.length - 1];\r\n      const dt = last.time - first.time;\r\n\r\n      if (dt === 0) return 0;\r\n\r\n      return (last.position - first.position) / dt;\r\n    },\r\n    reset() {\r\n      positions.length = 0;\r\n    },\r\n  };\r\n}\r\n\r\n/**\r\n * Hook to handle drawer gesture/swipe interactions\r\n *\r\n * Uses pointer events for precise control over:\r\n * - Drag detection and tracking\r\n * - Velocity calculation for flick gestures\r\n * - Determining snap target based on position and velocity\r\n */\r\nexport function useDrawerGesture({\r\n  direction,\r\n  dismissible,\r\n  activeSnapPointIndex,\r\n  snapPositions,\r\n  maxDragDistance,\r\n  onSnapPointChange,\r\n  onDismiss,\r\n  onDragProgress,\r\n  onDragStart,\r\n  onDragEnd,\r\n  velocityThreshold = 0.5,\r\n  dismissThreshold = 0.5,\r\n  enabled = true,\r\n}: UseDrawerGestureOptions): UseDrawerGestureReturn {\r\n  const [isDragging, setIsDragging] = React.useState(false);\r\n  const [dragOffset, setDragOffset] = React.useState(0);\r\n\r\n  // Refs for tracking gesture state\r\n  const startPositionRef = React.useRef(0);\r\n  const currentPositionRef = React.useRef(0);\r\n  const velocityTrackerRef = React.useRef<VelocityTracker>(\r\n    createVelocityTracker(),\r\n  );\r\n  const isDraggingRef = React.useRef(false);\r\n  const hasMovedRef = React.useRef(false);\r\n  const pointerIdRef = React.useRef<number | null>(null);\r\n  const targetElementRef = React.useRef<HTMLElement | null>(null);\r\n\r\n  const isVertical = direction === \"top\" || direction === \"bottom\";\r\n\r\n  // Get the current snap point position\r\n  const currentSnapPointPosition = snapPositions[activeSnapPointIndex] ?? 0;\r\n\r\n  // Calculate drag direction multiplier\r\n  // For bottom/right: positive drag = closing (translate increases)\r\n  // For top/left: positive drag = opening (translate decreases)\r\n  const dragMultiplier =\r\n    direction === \"bottom\" || direction === \"right\" ? 1 : -1;\r\n\r\n  // Get pointer position based on direction\r\n  const getPointerPosition = React.useCallback(\r\n    (e: React.PointerEvent) => {\r\n      return isVertical ? e.clientY : e.clientX;\r\n    },\r\n    [isVertical],\r\n  );\r\n\r\n  // Find the lowest snap point position (highest pixel value = most closed)\r\n  // Snap positions are sorted with index 0 being the most closed\r\n  const lowestSnapPosition = snapPositions[0] ?? 0;\r\n\r\n  // Get nearest snap point considering velocity\r\n  // Returns { index, shouldDismiss }\r\n  const getSnapTarget = React.useCallback(\r\n    (\r\n      position: number,\r\n      velocity: number,\r\n    ): { index: number; shouldDismiss: boolean } => {\r\n      // Check if we should dismiss\r\n      // Threshold is calculated as percentage of distance from lowest snap point to fully closed\r\n      // This means \"50% of the way past the lowest snap point\" triggers dismiss\r\n      if (dismissible) {\r\n        const distanceToFullyClosed = maxDragDistance - lowestSnapPosition;\r\n        const dismissPosition =\r\n          lowestSnapPosition + distanceToFullyClosed * dismissThreshold;\r\n        const isFlickingClosed = velocity > velocityThreshold;\r\n\r\n        if (\r\n          position > dismissPosition ||\r\n          (isFlickingClosed && position > lowestSnapPosition)\r\n        ) {\r\n          return { index: 0, shouldDismiss: true };\r\n        }\r\n      }\r\n\r\n      // FIRST: If velocity is significant, use velocity-based snapping\r\n      if (Math.abs(velocity) > velocityThreshold) {\r\n        const isClosingDirection = velocity > 0;\r\n\r\n        if (isClosingDirection) {\r\n          // Find next snap point towards closed (higher position value)\r\n          for (let i = 0; i < snapPositions.length; i++) {\r\n            if (snapPositions[i] > position) {\r\n              return { index: i, shouldDismiss: false };\r\n            }\r\n          }\r\n          // Already past all snap points\r\n          return { index: 0, shouldDismiss: false };\r\n        } else {\r\n          // Find next snap point towards open (lower position value)\r\n          for (let i = snapPositions.length - 1; i >= 0; i--) {\r\n            if (snapPositions[i] < position) {\r\n              return { index: i, shouldDismiss: false };\r\n            }\r\n          }\r\n          return { index: snapPositions.length - 1, shouldDismiss: false };\r\n        }\r\n      }\r\n\r\n      // SECOND: Low velocity - snap to nearest snap point\r\n      let closestIndex = 0;\r\n      let closestDistance = Math.abs(position - snapPositions[0]);\r\n\r\n      for (let i = 1; i < snapPositions.length; i++) {\r\n        const distance = Math.abs(position - snapPositions[i]);\r\n        if (distance < closestDistance) {\r\n          closestDistance = distance;\r\n          closestIndex = i;\r\n        }\r\n      }\r\n\r\n      return { index: closestIndex, shouldDismiss: false };\r\n    },\r\n    [\r\n      dismissible,\r\n      dismissThreshold,\r\n      lowestSnapPosition,\r\n      maxDragDistance,\r\n      snapPositions,\r\n      velocityThreshold,\r\n    ],\r\n  );\r\n\r\n  // Handle pointer down\r\n  const handlePointerDown = React.useCallback(\r\n    (e: React.PointerEvent) => {\r\n      if (!enabled) return;\r\n\r\n      // Only handle primary pointer (touch or left mouse)\r\n      if (e.button !== 0) return;\r\n\r\n      // Don't prevent default here - allow clicks on interactive elements\r\n      // We'll prevent default in handlePointerMove once drag threshold is crossed\r\n\r\n      startPositionRef.current = getPointerPosition(e);\r\n      currentPositionRef.current = startPositionRef.current;\r\n      velocityTrackerRef.current.reset();\r\n      velocityTrackerRef.current.add(0);\r\n      hasMovedRef.current = false;\r\n      isDraggingRef.current = true;\r\n      pointerIdRef.current = e.pointerId;\r\n      targetElementRef.current = e.currentTarget as HTMLElement;\r\n\r\n      // Don't capture pointer yet - we'll capture in handlePointerMove\r\n      // after the drag threshold is crossed. This allows clicks to work normally.\r\n    },\r\n    [enabled, getPointerPosition],\r\n  );\r\n\r\n  // Handle pointer move\r\n  const handlePointerMove = React.useCallback(\r\n    (e: React.PointerEvent) => {\r\n      if (!isDraggingRef.current) return;\r\n      if (pointerIdRef.current !== e.pointerId) return;\r\n\r\n      const currentPos = getPointerPosition(e);\r\n      let delta = (currentPos - startPositionRef.current) * dragMultiplier;\r\n\r\n      // Clamp delta to prevent dragging past open position\r\n      const minDelta = -currentSnapPointPosition; // Can't go past fully open (position 0)\r\n\r\n      // When dismissible, allow dragging past the lowest snap point (for dismiss gesture)\r\n      // Otherwise, clamp to the lowest snap point\r\n      const maxDelta = dismissible\r\n        ? Infinity // Allow dragging past for dismiss\r\n        : lowestSnapPosition - currentSnapPointPosition;\r\n      delta = Math.max(minDelta, Math.min(maxDelta, delta));\r\n\r\n      // Calculate new position (current snap point position + drag delta)\r\n      const newPosition = currentSnapPointPosition + delta;\r\n\r\n      // Track velocity\r\n      velocityTrackerRef.current.add(newPosition);\r\n\r\n      // Update state\r\n      currentPositionRef.current = currentPos;\r\n      setDragOffset(delta);\r\n\r\n      // Calculate progress (0 = open, 1 = closed)\r\n      const progress = Math.min(1, Math.max(0, newPosition / maxDragDistance));\r\n      onDragProgress?.(progress);\r\n\r\n      // Start dragging state after some movement\r\n      if (!hasMovedRef.current && Math.abs(delta) > 5) {\r\n        hasMovedRef.current = true;\r\n        setIsDragging(true);\r\n        onDragStart?.();\r\n        // Prevent default once drag starts to stop text selection\r\n        e.preventDefault();\r\n        // Now capture the pointer for reliable tracking\r\n        if (targetElementRef.current) {\r\n          targetElementRef.current.setPointerCapture(e.pointerId);\r\n        }\r\n      } else if (hasMovedRef.current) {\r\n        // Continue preventing default during drag\r\n        e.preventDefault();\r\n      }\r\n    },\r\n    [\r\n      getPointerPosition,\r\n      dragMultiplier,\r\n      currentSnapPointPosition,\r\n      dismissible,\r\n      lowestSnapPosition,\r\n      maxDragDistance,\r\n      onDragProgress,\r\n      onDragStart,\r\n    ],\r\n  );\r\n\r\n  // Handle pointer up\r\n  const handlePointerUp = React.useCallback(\r\n    (e: React.PointerEvent) => {\r\n      if (!isDraggingRef.current) return;\r\n      if (pointerIdRef.current !== e.pointerId) return;\r\n\r\n      isDraggingRef.current = false;\r\n      pointerIdRef.current = null;\r\n\r\n      // Release pointer capture if we captured it\r\n      if (hasMovedRef.current && targetElementRef.current) {\r\n        try {\r\n          targetElementRef.current.releasePointerCapture(e.pointerId);\r\n        } catch {\r\n          // Ignore if already released\r\n        }\r\n      }\r\n      targetElementRef.current = null;\r\n\r\n      if (!hasMovedRef.current) {\r\n        // No significant movement - this was a click, let it pass through\r\n        setDragOffset(0);\r\n        return;\r\n      }\r\n\r\n      // Calculate final position and velocity\r\n      const delta =\r\n        (currentPositionRef.current - startPositionRef.current) *\r\n        dragMultiplier;\r\n      const finalPosition = currentSnapPointPosition + delta;\r\n      const velocity = velocityTrackerRef.current.getVelocity();\r\n\r\n      // Determine target snap point or dismiss\r\n      const { index: targetSnapPoint, shouldDismiss } = getSnapTarget(\r\n        finalPosition,\r\n        velocity,\r\n      );\r\n\r\n      // Reset drag state\r\n      setDragOffset(0);\r\n      setIsDragging(false);\r\n      onDragEnd?.();\r\n\r\n      // Handle dismiss or snap point change\r\n      if (shouldDismiss) {\r\n        onDismiss?.();\r\n      } else if (targetSnapPoint !== activeSnapPointIndex) {\r\n        onSnapPointChange(targetSnapPoint);\r\n      }\r\n    },\r\n    [\r\n      dragMultiplier,\r\n      currentSnapPointPosition,\r\n      getSnapTarget,\r\n      activeSnapPointIndex,\r\n      onSnapPointChange,\r\n      onDismiss,\r\n      onDragEnd,\r\n    ],\r\n  );\r\n\r\n  // Handle pointer cancel\r\n  const handlePointerCancel = React.useCallback(\r\n    (e: React.PointerEvent) => {\r\n      if (!isDraggingRef.current) return;\r\n      if (pointerIdRef.current !== e.pointerId) return;\r\n\r\n      // Release pointer capture if we captured it\r\n      if (hasMovedRef.current && targetElementRef.current) {\r\n        try {\r\n          targetElementRef.current.releasePointerCapture(e.pointerId);\r\n        } catch {\r\n          // Ignore if already released\r\n        }\r\n      }\r\n\r\n      isDraggingRef.current = false;\r\n      pointerIdRef.current = null;\r\n      targetElementRef.current = null;\r\n      hasMovedRef.current = false;\r\n      setDragOffset(0);\r\n      setIsDragging(false);\r\n      onDragEnd?.();\r\n    },\r\n    [onDragEnd],\r\n  );\r\n\r\n  // Reset to current snap point position\r\n  const resetPosition = React.useCallback(() => {\r\n    setDragOffset(0);\r\n  }, []);\r\n\r\n  return {\r\n    gestureProps: {\r\n      onPointerDown: handlePointerDown,\r\n      onPointerMove: handlePointerMove,\r\n      onPointerUp: handlePointerUp,\r\n      onPointerCancel: handlePointerCancel,\r\n    },\r\n    dragOffset,\r\n    isDragging,\r\n    resetPosition,\r\n  };\r\n}\r\n",
      "type": "registry:hook",
      "target": "hooks/cubby-ui/use-drawer-gesture.ts"
    },
    {
      "path": "registry/default/drawer/hooks/use-nested-scroll.ts",
      "content": "import * as React from \"react\";\r\n\r\nimport type { DrawerDirection } from \"./use-snap-points\";\r\n\r\nexport interface UseNestedScrollOptions {\r\n  /** Ref to the drawer content container */\r\n  containerRef: React.RefObject<HTMLElement | null>;\r\n  /** Direction the drawer opens from */\r\n  direction: DrawerDirection;\r\n  /** Whether nested scroll detection is enabled */\r\n  enabled?: boolean;\r\n}\r\n\r\nexport interface UseNestedScrollReturn {\r\n  /**\r\n   * Whether the active scrollable element is at its boundary\r\n   * in the direction that would dismiss the drawer.\r\n   *\r\n   * - For bottom drawer: true when scrolled to top\r\n   * - For top drawer: true when scrolled to bottom\r\n   * - For right drawer: true when scrolled to left\r\n   * - For left drawer: true when scrolled to right\r\n   */\r\n  isAtScrollBoundary: boolean;\r\n\r\n  /**\r\n   * The currently active scrollable element (if any)\r\n   */\r\n  activeScrollableElement: HTMLElement | null;\r\n}\r\n\r\n/**\r\n * Hook to detect when nested scrollable content is at its boundary\r\n *\r\n * This enables the drawer to be dismissed by swiping only when:\r\n * 1. There is no nested scrollable content, OR\r\n * 2. The nested scrollable content is at its boundary in the dismiss direction\r\n *\r\n * Mark scrollable areas with `data-drawer-scrollable` attribute to enable detection.\r\n */\r\nexport function useNestedScroll({\r\n  containerRef,\r\n  direction,\r\n  enabled = true,\r\n}: UseNestedScrollOptions): UseNestedScrollReturn {\r\n  const [isAtScrollBoundary, setIsAtScrollBoundary] = React.useState(true);\r\n  const [activeScrollableElement, setActiveScrollableElement] =\r\n    React.useState<HTMLElement | null>(null);\r\n\r\n  const isVertical = direction === \"top\" || direction === \"bottom\";\r\n\r\n  // Check if element is at the relevant scroll boundary\r\n  const checkBoundary = React.useCallback(\r\n    (element: HTMLElement): boolean => {\r\n      if (isVertical) {\r\n        const atTop = element.scrollTop <= 1; // Small threshold for rounding\r\n        const atBottom =\r\n          element.scrollTop + element.clientHeight >= element.scrollHeight - 1;\r\n\r\n        // For bottom drawer, we dismiss by swiping down, so check if at top\r\n        // For top drawer, we dismiss by swiping up, so check if at bottom\r\n        return direction === \"bottom\" ? atTop : atBottom;\r\n      } else {\r\n        const atLeft = element.scrollLeft <= 1;\r\n        const atRight =\r\n          element.scrollLeft + element.clientWidth >= element.scrollWidth - 1;\r\n\r\n        // For right drawer, we dismiss by swiping right, so check if at left\r\n        // For left drawer, we dismiss by swiping left, so check if at right\r\n        return direction === \"right\" ? atLeft : atRight;\r\n      }\r\n    },\r\n    [direction, isVertical],\r\n  );\r\n\r\n  // Handle scroll events on scrollable elements\r\n  React.useEffect(() => {\r\n    const container = containerRef.current;\r\n    if (!container || !enabled) return;\r\n\r\n    // Find all scrollable elements\r\n    const scrollableElements = container.querySelectorAll<HTMLElement>(\r\n      \"[data-drawer-scrollable]\",\r\n    );\r\n\r\n    if (scrollableElements.length === 0) {\r\n      // No scrollable elements - always allow dismiss\r\n      setIsAtScrollBoundary(true);\r\n      setActiveScrollableElement(null);\r\n      return;\r\n    }\r\n\r\n    const handleScroll = (e: Event) => {\r\n      const target = e.target as HTMLElement;\r\n      setActiveScrollableElement(target);\r\n      setIsAtScrollBoundary(checkBoundary(target));\r\n    };\r\n\r\n    // Check boundary on pointer/touch start to determine if we should allow the gesture\r\n    // This runs synchronously before the gesture handler processes the event\r\n    const handlePointerStart = (e: PointerEvent | TouchEvent) => {\r\n      // Find the scrollable element that contains the pointer target\r\n      const target =\r\n        e instanceof TouchEvent\r\n          ? (e.touches[0]?.target as HTMLElement)\r\n          : (e.target as HTMLElement);\r\n\r\n      if (!target) return;\r\n\r\n      const scrollableParent = target.closest<HTMLElement>(\r\n        \"[data-drawer-scrollable]\",\r\n      );\r\n\r\n      if (scrollableParent) {\r\n        setActiveScrollableElement(scrollableParent);\r\n        setIsAtScrollBoundary(checkBoundary(scrollableParent));\r\n      } else {\r\n        // Not inside a scrollable area - allow dismiss\r\n        setActiveScrollableElement(null);\r\n        setIsAtScrollBoundary(true);\r\n      }\r\n    };\r\n\r\n    // Attach scroll listeners to all scrollable elements\r\n    scrollableElements.forEach((el) => {\r\n      el.addEventListener(\"scroll\", handleScroll, { passive: true });\r\n    });\r\n\r\n    // Attach pointer down to container (fires before gesture handler)\r\n    // Use capture phase to ensure we run first\r\n    container.addEventListener(\"pointerdown\", handlePointerStart, {\r\n      capture: true,\r\n      passive: true,\r\n    });\r\n    container.addEventListener(\"touchstart\", handlePointerStart, {\r\n      capture: true,\r\n      passive: true,\r\n    });\r\n\r\n    // Initial check - set boundary state based on first scrollable element\r\n    const firstScrollable = scrollableElements[0];\r\n    if (firstScrollable) {\r\n      setIsAtScrollBoundary(checkBoundary(firstScrollable));\r\n    }\r\n\r\n    return () => {\r\n      scrollableElements.forEach((el) => {\r\n        el.removeEventListener(\"scroll\", handleScroll);\r\n      });\r\n      container.removeEventListener(\"pointerdown\", handlePointerStart, {\r\n        capture: true,\r\n      });\r\n      container.removeEventListener(\"touchstart\", handlePointerStart, {\r\n        capture: true,\r\n      });\r\n    };\r\n  }, [containerRef, enabled, checkBoundary]);\r\n\r\n  return {\r\n    isAtScrollBoundary,\r\n    activeScrollableElement,\r\n  };\r\n}\r\n",
      "type": "registry:hook",
      "target": "hooks/cubby-ui/use-nested-scroll.ts"
    },
    {
      "path": "registry/default/drawer/hooks/use-scroll-snap.ts",
      "content": "import * as React from \"react\";\r\n\r\nimport type { DrawerDirection, SnapPoint } from \"./use-snap-points\";\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * Types\r\n * -------------------------------------------------------------------------------------------------*/\r\n\r\nexport interface UseScrollSnapOptions {\r\n  /** Direction the drawer opens from */\r\n  direction: DrawerDirection;\r\n  /** Snap points configuration */\r\n  snapPoints: SnapPoint[];\r\n  /** Current active snap point index */\r\n  activeSnapPointIndex: number;\r\n  /** Callback when snap point changes */\r\n  onSnapPointChange: (index: number) => void;\r\n  /** Callback when drawer should be dismissed */\r\n  onDismiss: () => void;\r\n  /** Whether drawer can be dismissed by swiping */\r\n  dismissible: boolean;\r\n  /** Size of the drawer content */\r\n  contentSize: number | null;\r\n  /** Whether the drawer is open */\r\n  open: boolean;\r\n  /** Callback during scroll with progress (0-1, where 0 = open, 1 = closed) */\r\n  onScrollProgress?: (progress: number) => void;\r\n  /** Callback during scroll with snap progress (0 = first snap, 1 = last snap) */\r\n  onSnapProgress?: (progress: number) => void;\r\n  /** Callback to signal immediate close (skip exit animation) for swipe dismiss */\r\n  onImmediateClose?: () => void;\r\n  /** Whether the drawer is currently animating (enter/exit CSS transition) */\r\n  isAnimating?: boolean;\r\n}\r\n\r\nexport interface UseScrollSnapReturn {\r\n  /** Ref for the scroll container */\r\n  containerRef: React.RefObject<HTMLDivElement | null>;\r\n  /** Current scroll progress (0 = fully open, 1 = fully closed) */\r\n  scrollProgress: number;\r\n  /** Progress between snap points (0 = first snap, 1 = last snap) */\r\n  snapProgress: number;\r\n  /** Whether currently scrolling/dragging */\r\n  isScrolling: boolean;\r\n  /** Programmatically scroll to a snap point */\r\n  scrollToSnapPoint: (index: number, behavior?: ScrollBehavior) => void;\r\n  /** Scroll to closed position (for close animation) */\r\n  scrollToClose: (behavior?: ScrollBehavior) => Promise<void>;\r\n  /** Snap target refs for the snap elements */\r\n  snapTargetRefs: React.RefObject<(HTMLDivElement | null)[]>;\r\n  /** Track size for the scroll container */\r\n  trackSize: number;\r\n  /** Snap positions (scroll positions for each snap point) */\r\n  snapScrollPositions: number[];\r\n  /** Whether the initial scroll positioning is complete */\r\n  isInitialized: boolean;\r\n  /** Whether the drawer is in the process of closing (pointer events should be disabled) */\r\n  isClosing: boolean;\r\n  /** Scroll position for first snap point (for CSS animation-range) */\r\n  firstSnapScrollPos: number;\r\n  /** Scroll position for last snap point (for CSS animation-range) */\r\n  lastSnapScrollPos: number;\r\n  /** Scroll position for dismiss (0 or last depending on direction, for CSS animation-range) */\r\n  dismissScrollPos: number;\r\n}\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * Browser Support Detection\r\n * -------------------------------------------------------------------------------------------------*/\r\n\r\nconst supportsScrollEnd =\r\n  typeof window !== \"undefined\" && \"onscrollend\" in window;\r\n\r\n/**\r\n * Feature detection for scroll-driven animations (animation-timeline: scroll())\r\n * Chrome 115+, Safari 26+ (future), Firefox flag-only\r\n */\r\nexport const supportsScrollTimeline =\r\n  typeof CSS !== \"undefined\" &&\r\n  CSS.supports(\"animation-timeline\", \"scroll()\") &&\r\n  CSS.supports(\"timeline-scope\", \"--test\");\r\n\r\n/**\r\n * Feature detection for scroll snap events (scrollsnapchange, scrollsnapchanging)\r\n * Chrome 129+ only\r\n */\r\nexport const supportsScrollSnapChange =\r\n  typeof window !== \"undefined\" && \"onscrollsnapchange\" in window;\r\n\r\n/**\r\n * Feature detection for CSS scroll-state() container queries\r\n * Chrome 133+ only\r\n */\r\nexport const supportsScrollState =\r\n  typeof CSS !== \"undefined\" && CSS.supports(\"container-type\", \"scroll-state\");\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * Utilities\r\n * -------------------------------------------------------------------------------------------------*/\r\n\r\n/**\r\n * Parse a pixel value string (e.g., \"200px\") and return the number\r\n */\r\nfunction parsePixelValue(value: string): number | null {\r\n  const match = value.match(/^(\\d+(?:\\.\\d+)?)px$/);\r\n  return match ? parseFloat(match[1]) : null;\r\n}\r\n\r\n/**\r\n * Wait for scroll to end on an element\r\n */\r\nfunction waitForScrollEnd(element: HTMLElement): Promise<void> {\r\n  return new Promise((resolve) => {\r\n    if (supportsScrollEnd) {\r\n      element.addEventListener(\"scrollend\", () => resolve(), { once: true });\r\n    } else {\r\n      // Fallback: debounced scroll detection\r\n      let timeout: ReturnType<typeof setTimeout>;\r\n      const handler = () => {\r\n        clearTimeout(timeout);\r\n        timeout = setTimeout(() => {\r\n          element.removeEventListener(\"scroll\", handler);\r\n          resolve();\r\n        }, 0);\r\n      };\r\n      element.addEventListener(\"scroll\", handler, { passive: true });\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Check if user prefers reduced motion\r\n */\r\nfunction prefersReducedMotion(): boolean {\r\n  if (typeof window === \"undefined\") return false;\r\n  return window.matchMedia(\"(prefers-reduced-motion: reduce)\").matches;\r\n}\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * Hook Implementation\r\n * -------------------------------------------------------------------------------------------------*/\r\n\r\nexport function useScrollSnap({\r\n  direction,\r\n  snapPoints,\r\n  activeSnapPointIndex,\r\n  onSnapPointChange,\r\n  onDismiss,\r\n  dismissible,\r\n  contentSize,\r\n  open,\r\n  onScrollProgress,\r\n  onSnapProgress,\r\n  onImmediateClose,\r\n  isAnimating,\r\n}: UseScrollSnapOptions): UseScrollSnapReturn {\r\n  const containerRef = React.useRef<HTMLDivElement | null>(null);\r\n  const snapTargetRefs = React.useRef<(HTMLDivElement | null)[]>([]);\r\n  const [scrollProgress, setScrollProgress] = React.useState(0);\r\n  const [snapProgress, setSnapProgress] = React.useState(0);\r\n  const [isScrolling, setIsScrolling] = React.useState(false);\r\n  const [isClosing, setIsClosing] = React.useState(false);\r\n\r\n  // Track whether we're programmatically scrolling (to avoid triggering snap change callbacks)\r\n  const isProgrammaticScrollRef = React.useRef(false);\r\n\r\n  // Track closing state with ref to avoid stale closures in scroll handler\r\n  const isClosingRef = React.useRef(false);\r\n  React.useEffect(() => {\r\n    isClosingRef.current = isClosing;\r\n  }, [isClosing]);\r\n\r\n  const isVertical = direction === \"top\" || direction === \"bottom\";\r\n\r\n  // Use CSS viewport units for more reliable mobile measurements\r\n  const [viewportSize, setViewportSize] = React.useState(() => {\r\n    if (typeof window === \"undefined\") return 800;\r\n    return isVertical ? window.innerHeight : window.innerWidth;\r\n  });\r\n\r\n  const effectiveSize = contentSize ?? viewportSize * 0.9;\r\n\r\n  // Calculate track size (viewport + drawer size + dismiss buffer)\r\n  const dismissBuffer = dismissible ? effectiveSize * 0.3 : 0;\r\n  const trackSize = viewportSize + effectiveSize + dismissBuffer;\r\n\r\n  // Determine if this direction uses inverted scroll (drawer at start of track)\r\n  const isInvertedScroll = direction === \"top\" || direction === \"left\";\r\n\r\n  // Calculate snap scroll positions\r\n  const snapScrollPositions = React.useMemo(() => {\r\n    const positions: number[] = [];\r\n    const maxScroll = trackSize - viewportSize;\r\n    const visibleRange = maxScroll - dismissBuffer;\r\n\r\n    // Add dismiss position first if dismissible\r\n    // Bottom/Right: dismiss at scroll 0 (drawer hidden at end)\r\n    // Top/Left: dismiss at maxScroll (drawer hidden at start)\r\n    if (dismissible) {\r\n      positions.push(isInvertedScroll ? maxScroll : 0);\r\n    }\r\n\r\n    // Calculate positions for each snap point\r\n    snapPoints.forEach((snapPoint) => {\r\n      let visibleRatio: number;\r\n\r\n      if (typeof snapPoint === \"string\") {\r\n        const pixels = parsePixelValue(snapPoint);\r\n        visibleRatio = (pixels ?? effectiveSize) / effectiveSize;\r\n      } else {\r\n        visibleRatio = snapPoint;\r\n      }\r\n\r\n      // Calculate scroll position\r\n      // Bottom/Right: more visible = higher scroll position\r\n      // Top/Left: more visible = lower scroll position (inverted)\r\n      let scrollPos: number;\r\n      if (isInvertedScroll) {\r\n        // Inverted: maxScroll (closed) -> 0 (fully open)\r\n        scrollPos = maxScroll - dismissBuffer - visibleRatio * visibleRange;\r\n      } else {\r\n        // Normal: 0 (closed) -> maxScroll (fully open)\r\n        scrollPos = dismissBuffer + visibleRatio * visibleRange;\r\n      }\r\n\r\n      positions.push(Math.min(maxScroll, Math.max(0, scrollPos)));\r\n    });\r\n\r\n    return positions;\r\n  }, [\r\n    snapPoints,\r\n    trackSize,\r\n    viewportSize,\r\n    effectiveSize,\r\n    dismissible,\r\n    dismissBuffer,\r\n    isInvertedScroll,\r\n  ]);\r\n\r\n  // Get the scroll position for the active snap point\r\n  const getScrollPositionForSnapPoint = React.useCallback(\r\n    (index: number): number => {\r\n      const adjustedIndex = dismissible ? index + 1 : index;\r\n      return snapScrollPositions[adjustedIndex] ?? 0;\r\n    },\r\n    [snapScrollPositions, dismissible],\r\n  );\r\n\r\n  // Find nearest snap point index from scroll position\r\n  const findNearestSnapIndex = React.useCallback(\r\n    (scrollPos: number): { index: number; isDismiss: boolean } => {\r\n      let closestIndex = 0;\r\n      let closestDistance = Infinity;\r\n\r\n      snapScrollPositions.forEach((pos, i) => {\r\n        const distance = Math.abs(scrollPos - pos);\r\n        if (distance < closestDistance) {\r\n          closestDistance = distance;\r\n          closestIndex = i;\r\n        }\r\n      });\r\n\r\n      if (dismissible && closestIndex === 0) {\r\n        return { index: 0, isDismiss: true };\r\n      }\r\n\r\n      const snapIndex = dismissible ? closestIndex - 1 : closestIndex;\r\n      return { index: Math.max(0, snapIndex), isDismiss: false };\r\n    },\r\n    [snapScrollPositions, dismissible],\r\n  );\r\n\r\n  // Calculate progress from scroll position\r\n  // Progress: 0 = fully open, 1 = fully closed\r\n  const calculateProgress = React.useCallback(\r\n    (scrollPos: number): number => {\r\n      const maxScroll = trackSize - viewportSize;\r\n      const visibleRange = maxScroll - dismissBuffer;\r\n\r\n      let progress: number;\r\n      if (isInvertedScroll) {\r\n        // Top/Left: maxScroll = closed (1), 0 = open (0)\r\n        // Open position is at: maxScroll - dismissBuffer - visibleRange\r\n        const openScrollPos = maxScroll - dismissBuffer - visibleRange;\r\n        progress = (scrollPos - openScrollPos) / visibleRange;\r\n      } else {\r\n        // Bottom/Right: 0 = closed (1), maxScroll = open (0)\r\n        progress = 1 - (scrollPos - dismissBuffer) / visibleRange;\r\n      }\r\n\r\n      return Math.min(1, Math.max(0, progress));\r\n    },\r\n    [trackSize, viewportSize, dismissBuffer, isInvertedScroll],\r\n  );\r\n\r\n  // Calculate snap progress from scroll position\r\n  // Snap progress: 0 = at first snap point, 1 = at last snap point\r\n  const calculateSnapProgress = React.useCallback(\r\n    (scrollPos: number): number => {\r\n      // Get first and last snap positions (excluding dismiss position)\r\n      const firstSnapIndex = dismissible ? 1 : 0;\r\n      const lastSnapIndex = snapScrollPositions.length - 1;\r\n\r\n      // Handle edge case of single snap point\r\n      if (firstSnapIndex >= lastSnapIndex) return 0;\r\n\r\n      const firstSnapPos = snapScrollPositions[firstSnapIndex];\r\n      const lastSnapPos = snapScrollPositions[lastSnapIndex];\r\n\r\n      // Handle edge case of same positions\r\n      if (firstSnapPos === lastSnapPos) return 0;\r\n\r\n      // Normalize scroll position to 0-1 between first and last snap\r\n      const progress =\r\n        (scrollPos - firstSnapPos) / (lastSnapPos - firstSnapPos);\r\n      return Math.min(1, Math.max(0, progress));\r\n    },\r\n    [snapScrollPositions, dismissible],\r\n  );\r\n\r\n  // Scroll to a specific snap point\r\n  const scrollToSnapPoint = React.useCallback(\r\n    (index: number, behavior: ScrollBehavior = \"smooth\") => {\r\n      const container = containerRef.current;\r\n      if (!container) return;\r\n\r\n      const scrollPos = getScrollPositionForSnapPoint(index);\r\n      const actualBehavior = prefersReducedMotion() ? \"auto\" : behavior;\r\n\r\n      isProgrammaticScrollRef.current = true;\r\n      container.scrollTo({\r\n        [isVertical ? \"top\" : \"left\"]: scrollPos,\r\n        behavior: actualBehavior,\r\n      });\r\n\r\n      if (actualBehavior === \"auto\") {\r\n        isProgrammaticScrollRef.current = false;\r\n      } else {\r\n        waitForScrollEnd(container).then(() => {\r\n          isProgrammaticScrollRef.current = false;\r\n        });\r\n      }\r\n    },\r\n    [getScrollPositionForSnapPoint, isVertical],\r\n  );\r\n\r\n  // Scroll to close position\r\n  const scrollToClose = React.useCallback(\r\n    async (behavior: ScrollBehavior = \"smooth\"): Promise<void> => {\r\n      const container = containerRef.current;\r\n      if (!container) return;\r\n\r\n      const actualBehavior = prefersReducedMotion() ? \"auto\" : behavior;\r\n\r\n      // Mark as closing to disable all pointer events\r\n      setIsClosing(true);\r\n      isProgrammaticScrollRef.current = true;\r\n\r\n      container.scrollTo({\r\n        [isVertical ? \"top\" : \"left\"]: 0,\r\n        behavior: actualBehavior,\r\n      });\r\n\r\n      if (actualBehavior !== \"auto\") {\r\n        await waitForScrollEnd(container);\r\n      }\r\n      isProgrammaticScrollRef.current = false;\r\n      // Note: isClosing stays true since dialog is about to close anyway\r\n    },\r\n    [isVertical],\r\n  );\r\n\r\n  // Track if we've done initial scroll for this open\r\n  const hasInitializedRef = React.useRef(false);\r\n  const retryTimeoutRef = React.useRef<ReturnType<typeof setTimeout> | null>(\r\n    null,\r\n  );\r\n  // Track if initial scroll is complete (used to skip dismiss detection during init)\r\n  const [isInitialized, setIsInitialized] = React.useState(false);\r\n\r\n  // Initial scroll positioning - wait for contentSize to be measured\r\n  React.useEffect(() => {\r\n    if (!open) {\r\n      // Reset all state when drawer closes\r\n      hasInitializedRef.current = false;\r\n      setIsInitialized(false);\r\n      setIsClosing(false);\r\n      setIsScrolling(false);\r\n      isProgrammaticScrollRef.current = false;\r\n      prevScrollPosRef.current = null;\r\n      isTouchingRef.current = false;\r\n      // Cancel any running RAF stability check\r\n      if (rafStateRef.current.rafId !== null) {\r\n        cancelAnimationFrame(rafStateRef.current.rafId);\r\n        rafStateRef.current.rafId = null;\r\n      }\r\n      rafStateRef.current.lastScrollPos = null;\r\n      rafStateRef.current.stableCount = 0;\r\n      if (retryTimeoutRef.current) {\r\n        clearTimeout(retryTimeoutRef.current);\r\n        retryTimeoutRef.current = null;\r\n      }\r\n      return;\r\n    }\r\n\r\n    // CRITICAL: Wait for contentSize to be measured before scrolling\r\n    // Otherwise track height will change and clamp our scroll position\r\n    if (contentSize === null) return;\r\n\r\n    // Don't re-run if already initialized with measured contentSize\r\n    if (hasInitializedRef.current) return;\r\n\r\n    const performInitialScroll = () => {\r\n      const container = containerRef.current;\r\n      if (!container) {\r\n        retryTimeoutRef.current = setTimeout(performInitialScroll, 0);\r\n        return;\r\n      }\r\n\r\n      // Measure the actual container size\r\n      const size = isVertical ? container.clientHeight : container.clientWidth;\r\n      if (size === 0) {\r\n        retryTimeoutRef.current = setTimeout(performInitialScroll, 0);\r\n        return;\r\n      }\r\n\r\n      hasInitializedRef.current = true;\r\n\r\n      if (size !== viewportSize) {\r\n        setViewportSize(size);\r\n      }\r\n\r\n      // Use the actual snap position from our pre-calculated array\r\n      const targetIndex = dismissible\r\n        ? activeSnapPointIndex + 1\r\n        : activeSnapPointIndex;\r\n      const targetScrollPos = snapScrollPositions[targetIndex] ?? 0;\r\n\r\n      // Mark as programmatic scroll to prevent isScrolling from being set\r\n      isProgrammaticScrollRef.current = true;\r\n\r\n      // Disable scroll-snap AND scroll-behavior for instant positioning\r\n      container.style.scrollSnapType = \"none\";\r\n      container.style.scrollBehavior = \"auto\";\r\n\r\n      if (isVertical) {\r\n        container.scrollTop = targetScrollPos;\r\n      } else {\r\n        container.scrollLeft = targetScrollPos;\r\n      }\r\n\r\n      // Calculate and emit initial progress for backdrop opacity\r\n      const initialProgress = calculateProgress(targetScrollPos);\r\n      setScrollProgress(initialProgress);\r\n      onScrollProgress?.(initialProgress);\r\n\r\n      // Calculate and emit initial snap progress\r\n      const initialSnapProgress = calculateSnapProgress(targetScrollPos);\r\n      setSnapProgress(initialSnapProgress);\r\n      onSnapProgress?.(initialSnapProgress);\r\n\r\n      // Re-enable scroll-snap and smooth behavior\r\n      container.style.scrollSnapType = isVertical\r\n        ? \"y mandatory\"\r\n        : \"x mandatory\";\r\n      container.style.scrollBehavior = \"smooth\";\r\n\r\n      // Clear programmatic flag after a tick (after scroll events have fired)\r\n      setTimeout(() => {\r\n        isProgrammaticScrollRef.current = false;\r\n      }, 0);\r\n\r\n      // Mark as initialized\r\n      setIsInitialized(true);\r\n    };\r\n\r\n    // Small delay to let DOM settle\r\n    retryTimeoutRef.current = setTimeout(performInitialScroll, 0);\r\n\r\n    return () => {\r\n      if (retryTimeoutRef.current) {\r\n        clearTimeout(retryTimeoutRef.current);\r\n        retryTimeoutRef.current = null;\r\n      }\r\n    };\r\n  }, [\r\n    open,\r\n    isVertical,\r\n    viewportSize,\r\n    contentSize,\r\n    dismissible,\r\n    snapPoints,\r\n    activeSnapPointIndex,\r\n    snapScrollPositions,\r\n    calculateProgress,\r\n    calculateSnapProgress,\r\n    onScrollProgress,\r\n    onSnapProgress,\r\n  ]);\r\n\r\n  // Track the last detected snap index to avoid duplicate callbacks\r\n  const lastDetectedSnapIndexRef = React.useRef(activeSnapPointIndex);\r\n\r\n  // Track if the state change came from detection (vs external like button click)\r\n  // When true, the controlled effect should skip programmatic scrolling\r\n  const isStateFromDetectionRef = React.useRef(false);\r\n\r\n  // Track previous scroll position to detect actual movement\r\n  // This prevents spurious scroll events (common on iOS Safari for Bottom/Right drawers)\r\n  // from keeping isScrolling stuck as true\r\n  const prevScrollPosRef = React.useRef<number | null>(null);\r\n\r\n  // Persist RAF stability check state across effect re-runs\r\n  // This is critical because the effect may re-run during scroll (due to dependency changes)\r\n  // and we don't want to lose the RAF state\r\n  const rafStateRef = React.useRef({\r\n    rafId: null as number | null,\r\n    lastScrollPos: null as number | null,\r\n    stableCount: 0,\r\n  });\r\n\r\n  // Track whether user is actively touching (to distinguish hold vs momentum)\r\n  const isTouchingRef = React.useRef(false);\r\n\r\n  // Reset last detected snap index when drawer opens\r\n  React.useEffect(() => {\r\n    if (open) {\r\n      lastDetectedSnapIndexRef.current = activeSnapPointIndex;\r\n    }\r\n  }, [open, activeSnapPointIndex]);\r\n\r\n  // Handle scroll events for progress tracking and snap detection\r\n  React.useEffect(() => {\r\n    const container = containerRef.current;\r\n    if (!container || !open) return;\r\n\r\n    // Helper to trigger dismiss immediately when drawer exits viewport\r\n    const triggerImmediateDismiss = () => {\r\n      if (isClosingRef.current) return; // Guard against multiple calls\r\n\r\n      // Immediately disable interaction (don't wait for React state update)\r\n      container.style.overflow = \"hidden\";\r\n      container.style.pointerEvents = \"none\";\r\n      container.style.touchAction = \"none\";\r\n\r\n      setIsClosing(true);\r\n      isClosingRef.current = true;\r\n      isProgrammaticScrollRef.current = true;\r\n\r\n      // Signal immediate close (skip exit animation) then dismiss\r\n      onImmediateClose?.();\r\n      onDismiss();\r\n    };\r\n\r\n    // RAF-based scroll end detection - more reliable than scrollend event\r\n    // Detects when scroll position stops changing for a few frames\r\n    // Uses rafStateRef to persist state across effect re-runs\r\n\r\n    const checkScrollStability = () => {\r\n      const currentPos = isVertical\r\n        ? container.scrollTop\r\n        : container.scrollLeft;\r\n\r\n      const { lastScrollPos } = rafStateRef.current;\r\n\r\n      if (\r\n        lastScrollPos !== null &&\r\n        Math.abs(currentPos - lastScrollPos) < 0.5\r\n      ) {\r\n        rafStateRef.current.stableCount++;\r\n        // After 3 stable frames (~50ms), consider scroll ended\r\n        // But only if user is not actively touching - they might be holding still\r\n        if (rafStateRef.current.stableCount >= 3 && !isTouchingRef.current) {\r\n          handleScrollEnd();\r\n          rafStateRef.current.rafId = null;\r\n          rafStateRef.current.lastScrollPos = null;\r\n          rafStateRef.current.stableCount = 0;\r\n          return;\r\n        }\r\n      } else {\r\n        rafStateRef.current.stableCount = 0;\r\n      }\r\n\r\n      rafStateRef.current.lastScrollPos = currentPos;\r\n      rafStateRef.current.rafId = requestAnimationFrame(checkScrollStability);\r\n    };\r\n\r\n    const startScrollStabilityCheck = () => {\r\n      if (rafStateRef.current.rafId === null) {\r\n        rafStateRef.current.lastScrollPos = null;\r\n        rafStateRef.current.stableCount = 0;\r\n        rafStateRef.current.rafId = requestAnimationFrame(checkScrollStability);\r\n      }\r\n    };\r\n\r\n    const handleScroll = () => {\r\n      // Skip during initialization (scroll position is 0 before init)\r\n      if (!isInitialized) return;\r\n\r\n      const scrollPos = isVertical ? container.scrollTop : container.scrollLeft;\r\n      const progress = calculateProgress(scrollPos);\r\n      setScrollProgress(progress);\r\n      onScrollProgress?.(progress);\r\n\r\n      // Calculate and emit snap progress\r\n      const snapProg = calculateSnapProgress(scrollPos);\r\n      setSnapProgress(snapProg);\r\n      onSnapProgress?.(snapProg);\r\n\r\n      // Only mark as scrolling for user-initiated scrolls, not programmatic\r\n      // Programmatic scrolls (especially with behavior: 'auto') don't trigger scrollend,\r\n      // which would leave isScrolling stuck as true forever\r\n      // Use 2px threshold to filter out scroll-snap micro-adjustments when settling\r\n      const positionChanged =\r\n        prevScrollPosRef.current !== null &&\r\n        Math.abs(scrollPos - prevScrollPosRef.current) > 2;\r\n\r\n      // Always update the position baseline (for both programmatic and user scrolls)\r\n      prevScrollPosRef.current = scrollPos;\r\n\r\n      // Only set isScrolling for user-initiated scrolls with actual movement\r\n      if (!isProgrammaticScrollRef.current && positionChanged) {\r\n        setIsScrolling(true);\r\n        // Start RAF-based stability check only for browsers without native scrollend\r\n        // Chrome's scrollend already has correct touch-awareness built in\r\n        if (!supportsScrollEnd) {\r\n          startScrollStabilityCheck();\r\n        }\r\n      }\r\n\r\n      // Only do snap detection for user drags, not programmatic scroll\r\n      if (!isProgrammaticScrollRef.current) {\r\n        // Trigger dismiss when drawer exits viewport (progress >= 1)\r\n        if (dismissible && !isClosingRef.current && progress >= 1) {\r\n          triggerImmediateDismiss();\r\n          return;\r\n        }\r\n\r\n        // Snap detection is handled by:\r\n        // - scrollsnapchange (Chrome 129+): native event after snap completes\r\n        // - scrollend (Firefox 109+, Chrome 114+): position-based detection after scroll ends\r\n        // - RAF stability check: detects when scroll position stops changing\r\n        // All browsers update snap point only after scrolling ends, not during drag\r\n      }\r\n    };\r\n\r\n    const handleScrollEnd = () => {\r\n      setIsScrolling(false);\r\n\r\n      // Fallback snap detection for scrollend (catches cases where scrollsnapchange didn't fire)\r\n      // This is especially important for fast swipes where scrollsnapchange may be unreliable\r\n      if (!isProgrammaticScrollRef.current && !isClosingRef.current) {\r\n        const scrollPos = isVertical\r\n          ? container.scrollTop\r\n          : container.scrollLeft;\r\n        const { index, isDismiss } = findNearestSnapIndex(scrollPos);\r\n\r\n        if (!isDismiss && index !== lastDetectedSnapIndexRef.current) {\r\n          lastDetectedSnapIndexRef.current = index;\r\n          isStateFromDetectionRef.current = true;\r\n          onSnapPointChange(index);\r\n        }\r\n      }\r\n    };\r\n\r\n    // Native scroll snap change event (Chrome 129+)\r\n    // Provides the actual snapped element, more reliable than position-based detection\r\n    const handleScrollSnapChange = (event: Event) => {\r\n      // Skip during closing only - not during programmatic scroll\r\n      // scrollsnapchange fires AFTER scroll completes, so it's safe to process\r\n      // even for programmatic scrolls (calling onSnapPointChange with same value is a no-op)\r\n      // This ensures user swipes that happen right after programmatic scrolls are caught\r\n      if (isClosingRef.current) return;\r\n\r\n      // Get the snapped element from the event\r\n      // TypeScript doesn't have types for this yet, so we need to cast\r\n      const snapEvent = event as Event & {\r\n        snapTargetBlock?: Element | null;\r\n        snapTargetInline?: Element | null;\r\n      };\r\n      const snapTarget = isVertical\r\n        ? snapEvent.snapTargetBlock\r\n        : snapEvent.snapTargetInline;\r\n\r\n      if (!snapTarget) return;\r\n\r\n      // Get snap index from data attribute\r\n      const snapIndexAttr = snapTarget.getAttribute(\"data-snap-index\");\r\n      if (snapIndexAttr === null) return;\r\n\r\n      const rawIndex = parseInt(snapIndexAttr, 10);\r\n      if (isNaN(rawIndex)) return;\r\n\r\n      // Adjust for dismiss target (index 0 is dismiss when dismissible)\r\n      const actualIndex = dismissible ? rawIndex - 1 : rawIndex;\r\n\r\n      // Index -1 means dismiss target was snapped (shouldn't happen normally,\r\n      // as dismiss is handled by progress >= 1 check, but handle gracefully)\r\n      if (actualIndex < 0) return;\r\n\r\n      if (actualIndex !== lastDetectedSnapIndexRef.current) {\r\n        lastDetectedSnapIndexRef.current = actualIndex;\r\n        isStateFromDetectionRef.current = true;\r\n        onSnapPointChange(actualIndex);\r\n      }\r\n    };\r\n\r\n    // Touch/mouse tracking to distinguish \"holding still\" from \"released with momentum\"\r\n    const handleTouchStart = () => {\r\n      isTouchingRef.current = true;\r\n    };\r\n\r\n    const handleTouchEnd = () => {\r\n      isTouchingRef.current = false;\r\n      // Reset stable count so we don't immediately fire handleScrollEnd\r\n      // from counts accumulated while user was holding still\r\n      // This gives momentum scroll time to start\r\n      rafStateRef.current.stableCount = 0;\r\n    };\r\n\r\n    container.addEventListener(\"scroll\", handleScroll, { passive: true });\r\n    container.addEventListener(\"touchstart\", handleTouchStart, {\r\n      passive: true,\r\n    });\r\n    container.addEventListener(\"touchend\", handleTouchEnd, { passive: true });\r\n    container.addEventListener(\"touchcancel\", handleTouchEnd, { passive: true });\r\n    container.addEventListener(\"mousedown\", handleTouchStart);\r\n    container.addEventListener(\"mouseup\", handleTouchEnd);\r\n\r\n    // Also use native scrollend if available (may fire faster than RAF check)\r\n    if (supportsScrollEnd) {\r\n      container.addEventListener(\"scrollend\", handleScrollEnd);\r\n    }\r\n\r\n    if (supportsScrollSnapChange) {\r\n      container.addEventListener(\"scrollsnapchange\", handleScrollSnapChange);\r\n    }\r\n\r\n    return () => {\r\n      container.removeEventListener(\"scroll\", handleScroll);\r\n      container.removeEventListener(\"touchstart\", handleTouchStart);\r\n      container.removeEventListener(\"touchend\", handleTouchEnd);\r\n      container.removeEventListener(\"touchcancel\", handleTouchEnd);\r\n      container.removeEventListener(\"mousedown\", handleTouchStart);\r\n      container.removeEventListener(\"mouseup\", handleTouchEnd);\r\n      // Don't cancel RAF on cleanup - let it complete to detect scroll end\r\n      // The ref persists across effect re-runs\r\n      if (supportsScrollEnd) {\r\n        container.removeEventListener(\"scrollend\", handleScrollEnd);\r\n      }\r\n      if (supportsScrollSnapChange) {\r\n        container.removeEventListener(\r\n          \"scrollsnapchange\",\r\n          handleScrollSnapChange,\r\n        );\r\n      }\r\n    };\r\n  }, [\r\n    isVertical,\r\n    calculateProgress,\r\n    calculateSnapProgress,\r\n    open,\r\n    isInitialized,\r\n    dismissible,\r\n    findNearestSnapIndex,\r\n    onScrollProgress,\r\n    onSnapProgress,\r\n    onDismiss,\r\n    onImmediateClose,\r\n    onSnapPointChange,\r\n  ]);\r\n\r\n  // Update viewport size when container is mounted and on resize\r\n  React.useEffect(() => {\r\n    const container = containerRef.current;\r\n    if (!container) return;\r\n\r\n    const updateViewportSize = () => {\r\n      const size = isVertical ? container.clientHeight : container.clientWidth;\r\n      setViewportSize(size);\r\n    };\r\n\r\n    updateViewportSize();\r\n\r\n    window.addEventListener(\"resize\", updateViewportSize);\r\n    return () => window.removeEventListener(\"resize\", updateViewportSize);\r\n  }, [isVertical]);\r\n\r\n  // Handle controlled snap point changes (from external sources like buttons)\r\n  const prevSnapPointRef = React.useRef(activeSnapPointIndex);\r\n  React.useEffect(() => {\r\n    if (prevSnapPointRef.current !== activeSnapPointIndex && open) {\r\n      // Skip if this change came from detection (CSS scroll-snap already handled it)\r\n      if (isStateFromDetectionRef.current) {\r\n        isStateFromDetectionRef.current = false;\r\n        prevSnapPointRef.current = activeSnapPointIndex;\r\n        return;\r\n      }\r\n\r\n      // Only scroll if we're not already at the target position\r\n      const container = containerRef.current;\r\n      if (container) {\r\n        const currentScrollPos = isVertical\r\n          ? container.scrollTop\r\n          : container.scrollLeft;\r\n        const targetScrollPos =\r\n          getScrollPositionForSnapPoint(activeSnapPointIndex);\r\n        const tolerance = 10; // pixels\r\n\r\n        if (Math.abs(currentScrollPos - targetScrollPos) > tolerance) {\r\n          scrollToSnapPoint(activeSnapPointIndex, \"smooth\");\r\n        }\r\n      }\r\n    }\r\n    prevSnapPointRef.current = activeSnapPointIndex;\r\n  }, [\r\n    activeSnapPointIndex,\r\n    open,\r\n    scrollToSnapPoint,\r\n    isVertical,\r\n    getScrollPositionForSnapPoint,\r\n  ]);\r\n\r\n  // Calculate scroll positions for CSS animation-range\r\n  const firstSnapIndex = dismissible ? 1 : 0;\r\n  const lastSnapIndex = snapScrollPositions.length - 1;\r\n  const firstSnapScrollPos = snapScrollPositions[firstSnapIndex] ?? 0;\r\n  const lastSnapScrollPos = snapScrollPositions[lastSnapIndex] ?? 0;\r\n  const dismissScrollPos = snapScrollPositions[0] ?? 0;\r\n\r\n  return {\r\n    containerRef,\r\n    scrollProgress,\r\n    snapProgress,\r\n    isScrolling,\r\n    scrollToSnapPoint,\r\n    scrollToClose,\r\n    snapTargetRefs,\r\n    trackSize,\r\n    snapScrollPositions,\r\n    isInitialized,\r\n    isClosing,\r\n    firstSnapScrollPos,\r\n    lastSnapScrollPos,\r\n    dismissScrollPos,\r\n  };\r\n}\r\n",
      "type": "registry:hook",
      "target": "hooks/cubby-ui/use-scroll-snap.ts"
    },
    {
      "path": "registry/default/drawer/hooks/use-snap-points.ts",
      "content": "import * as React from \"react\";\r\n\r\nexport type DrawerDirection = \"top\" | \"right\" | \"bottom\" | \"left\";\r\n\r\n/**\r\n * Snap point value:\r\n * - number (0-1): percentage of drawer visible (0 = closed, 1 = fully open)\r\n * - `${number}px`: fixed pixel height visible (e.g., \"200px\")\r\n */\r\nexport type SnapPoint = number | `${number}px`;\r\n\r\n/**\r\n * Parse a pixel value string (e.g., \"200px\") and return the number\r\n */\r\nfunction parsePixelValue(value: string): number | null {\r\n  const match = value.match(/^(\\d+(?:\\.\\d+)?)px$/);\r\n  return match ? parseFloat(match[1]) : null;\r\n}\r\n\r\nexport interface UseSnapPointsOptions {\r\n  /** Array of snap point values (0-1 or pixel values) */\r\n  snapPoints: SnapPoint[];\r\n  /** Direction the drawer opens from */\r\n  direction: DrawerDirection;\r\n  /** Size of the drawer content (height for vertical, width for horizontal) */\r\n  contentSize: number | null;\r\n  /** Size of the viewport (height for vertical, width for horizontal) */\r\n  viewportSize: number;\r\n}\r\n\r\nexport interface UseSnapPointsReturn {\r\n  /**\r\n   * Calculated snap positions in pixels\r\n   * Each position represents how far the drawer is translated from its fully-open position\r\n   */\r\n  snapPositions: number[];\r\n\r\n  /**\r\n   * Get the snap point index for a given position\r\n   */\r\n  getSnapPointForPosition: (position: number, velocity?: number) => number;\r\n\r\n  /**\r\n   * Get the pixel position for a given snap point index\r\n   */\r\n  getPositionForSnapPoint: (snapPointIndex: number) => number;\r\n\r\n  /**\r\n   * Get the nearest snap point index based on position and velocity\r\n   */\r\n  getNearestSnapPoint: (\r\n    position: number,\r\n    velocity: number,\r\n    velocityThreshold?: number,\r\n  ) => number;\r\n\r\n  /**\r\n   * Check if direction is vertical (top/bottom)\r\n   */\r\n  isVertical: boolean;\r\n\r\n  /**\r\n   * Get the maximum drag distance (for progress calculations)\r\n   */\r\n  maxDragDistance: number;\r\n}\r\n\r\n/**\r\n * Hook to manage drawer snap point calculations\r\n *\r\n * Snap points represent how much of the drawer is visible:\r\n * - 0 = fully hidden (dismissed)\r\n * - 0.5 = half visible\r\n * - 1 = fully visible\r\n *\r\n * The hook converts these to pixel positions based on drawer and viewport sizes.\r\n */\r\nexport function useSnapPoints({\r\n  snapPoints,\r\n  direction,\r\n  contentSize,\r\n  viewportSize,\r\n}: UseSnapPointsOptions): UseSnapPointsReturn {\r\n  const isVertical = direction === \"top\" || direction === \"bottom\";\r\n\r\n  // Calculate the effective size (use viewport if content size unknown)\r\n  const effectiveSize = contentSize ?? viewportSize;\r\n\r\n  // Calculate snap positions in pixels\r\n  // Position 0 = fully open, position = effectiveSize means fully closed\r\n  const snapPositions = React.useMemo(() => {\r\n    return snapPoints.map((snapPoint) => {\r\n      // Handle pixel values (e.g., \"200px\")\r\n      if (typeof snapPoint === \"string\") {\r\n        const pixels = parsePixelValue(snapPoint);\r\n        if (pixels !== null) {\r\n          // Pixel value: how many pixels of drawer should be visible\r\n          // position = effectiveSize - pixels (clamped to 0)\r\n          return Math.max(0, effectiveSize - pixels);\r\n        }\r\n        // Invalid string format, treat as fully open\r\n        return 0;\r\n      }\r\n\r\n      // Convert snap point (0-1) to pixel position\r\n      // snapPoint 0 = position = effectiveSize (fully hidden)\r\n      // snapPoint 1 = position = 0 (fully visible)\r\n      return effectiveSize * (1 - snapPoint);\r\n    });\r\n  }, [snapPoints, effectiveSize]);\r\n\r\n  // Maximum drag distance (from fully open to fully closed)\r\n  const maxDragDistance = effectiveSize;\r\n\r\n  // Get position for a specific snap point index\r\n  const getPositionForSnapPoint = React.useCallback(\r\n    (snapPointIndex: number): number => {\r\n      const clampedIndex = Math.max(\r\n        0,\r\n        Math.min(snapPointIndex, snapPositions.length - 1),\r\n      );\r\n      return snapPositions[clampedIndex];\r\n    },\r\n    [snapPositions],\r\n  );\r\n\r\n  // Get the snap point index closest to a given position\r\n  const getSnapPointForPosition = React.useCallback(\r\n    (position: number): number => {\r\n      let closestIndex = 0;\r\n      let closestDistance = Math.abs(position - snapPositions[0]);\r\n\r\n      for (let i = 1; i < snapPositions.length; i++) {\r\n        const distance = Math.abs(position - snapPositions[i]);\r\n        if (distance < closestDistance) {\r\n          closestDistance = distance;\r\n          closestIndex = i;\r\n        }\r\n      }\r\n\r\n      return closestIndex;\r\n    },\r\n    [snapPositions],\r\n  );\r\n\r\n  // Get nearest snap point considering velocity\r\n  const getNearestSnapPoint = React.useCallback(\r\n    (\r\n      position: number,\r\n      velocity: number,\r\n      velocityThreshold: number = 0.5,\r\n    ): number => {\r\n      // If velocity is significant, bias towards the direction of movement\r\n      if (Math.abs(velocity) > velocityThreshold) {\r\n        // For bottom/right drawers: positive velocity = closing, negative = opening\r\n        // For top/left drawers: negative velocity = closing, positive = opening\r\n        const isClosingDirection =\r\n          direction === \"bottom\" || direction === \"right\"\r\n            ? velocity > 0\r\n            : velocity < 0;\r\n\r\n        // Find snap points in the direction of movement\r\n        const currentSnapPoint = getSnapPointForPosition(position);\r\n        const currentPosition = snapPositions[currentSnapPoint];\r\n\r\n        if (isClosingDirection) {\r\n          // Moving towards closed - find next snap point with larger position value\r\n          for (let i = 0; i < snapPositions.length; i++) {\r\n            if (snapPositions[i] > currentPosition) {\r\n              return i;\r\n            }\r\n          }\r\n          // Already at most closed position\r\n          return snapPositions.length - 1;\r\n        } else {\r\n          // Moving towards open - find next snap point with smaller position value\r\n          for (let i = snapPositions.length - 1; i >= 0; i--) {\r\n            if (snapPositions[i] < currentPosition) {\r\n              return i;\r\n            }\r\n          }\r\n          // Already at most open position\r\n          return 0;\r\n        }\r\n      }\r\n\r\n      // Low velocity - snap to nearest snap point\r\n      return getSnapPointForPosition(position);\r\n    },\r\n    [direction, snapPositions, getSnapPointForPosition],\r\n  );\r\n\r\n  return {\r\n    snapPositions,\r\n    getSnapPointForPosition,\r\n    getPositionForSnapPoint,\r\n    getNearestSnapPoint,\r\n    isVertical,\r\n    maxDragDistance,\r\n  };\r\n}\r\n",
      "type": "registry:hook",
      "target": "hooks/cubby-ui/use-snap-points.ts"
    },
    {
      "path": "registry/default/drawer/hooks/use-virtual-keyboard.ts",
      "content": "import * as React from \"react\";\r\n\r\nexport interface UseVirtualKeyboardOptions {\r\n  /** Whether keyboard handling is enabled */\r\n  enabled?: boolean;\r\n}\r\n\r\nexport interface UseVirtualKeyboardReturn {\r\n  /** Current keyboard height in pixels (0 when closed) */\r\n  keyboardHeight: number;\r\n  /** Whether the virtual keyboard is currently visible */\r\n  isKeyboardVisible: boolean;\r\n}\r\n\r\n/**\r\n * Hook to detect virtual keyboard visibility and height using the Visual Viewport API.\r\n *\r\n * On mobile devices, when a virtual keyboard appears, it reduces the visual viewport height.\r\n * This hook tracks that change so components can adjust their layout accordingly.\r\n */\r\nexport function useVirtualKeyboard({\r\n  enabled = true,\r\n}: UseVirtualKeyboardOptions = {}): UseVirtualKeyboardReturn {\r\n  const [keyboardHeight, setKeyboardHeight] = React.useState(0);\r\n  const [isKeyboardVisible, setIsKeyboardVisible] = React.useState(false);\r\n\r\n  React.useEffect(() => {\r\n    if (!enabled || typeof window === \"undefined\") return;\r\n\r\n    const visualViewport = window.visualViewport;\r\n    if (!visualViewport) return;\r\n\r\n    // Store initial viewport height to compare against\r\n    let initialHeight = visualViewport.height;\r\n\r\n    const handleResize = () => {\r\n      // The keyboard height is the difference between the initial viewport height\r\n      // and the current viewport height\r\n      const currentHeight = visualViewport.height;\r\n      const heightDiff = initialHeight - currentHeight;\r\n\r\n      // Only consider it a keyboard if the difference is significant (> 100px)\r\n      // This avoids false positives from address bar hiding, etc.\r\n      const isKeyboard = heightDiff > 100;\r\n\r\n      setKeyboardHeight(isKeyboard ? heightDiff : 0);\r\n      setIsKeyboardVisible(isKeyboard);\r\n    };\r\n\r\n    // Also handle scroll to keep track when keyboard scrolls content\r\n    const handleScroll = () => {\r\n      // Re-check on scroll as the viewport may have changed\r\n      handleResize();\r\n    };\r\n\r\n    // Update initial height on orientation change\r\n    const handleOrientationChange = () => {\r\n      // Wait a bit for the viewport to settle\r\n      setTimeout(() => {\r\n        initialHeight = visualViewport.height;\r\n        handleResize();\r\n      }, 100);\r\n    };\r\n\r\n    visualViewport.addEventListener(\"resize\", handleResize);\r\n    visualViewport.addEventListener(\"scroll\", handleScroll);\r\n    window.addEventListener(\"orientationchange\", handleOrientationChange);\r\n\r\n    // Initial check\r\n    handleResize();\r\n\r\n    return () => {\r\n      visualViewport.removeEventListener(\"resize\", handleResize);\r\n      visualViewport.removeEventListener(\"scroll\", handleScroll);\r\n      window.removeEventListener(\"orientationchange\", handleOrientationChange);\r\n    };\r\n  }, [enabled]);\r\n\r\n  return {\r\n    keyboardHeight,\r\n    isKeyboardVisible,\r\n  };\r\n}\r\n",
      "type": "registry:hook",
      "target": "hooks/cubby-ui/use-virtual-keyboard.ts"
    },
    {
      "path": "registry/default/drawer/drawer.css",
      "content": "/* -------------------------------------------------------------------------------------------------\r\n * Drawer Scroll-Driven Animations (Progressive Enhancement)\r\n * Chrome 115+, Safari 26+ (future), Firefox flag-only\r\n * -------------------------------------------------------------------------------------------------*/\r\n\r\n/**\r\n * CSS Custom Property for scroll-driven drawer animations\r\n * Allows consumers to animate content based on snap progress:\r\n * .mini-player { opacity: calc(1 - var(--drawer-snap-progress, 0)); }\r\n * .full-player { opacity: var(--drawer-snap-progress, 0); }\r\n */\r\n@property --drawer-snap-progress {\r\n  syntax: \"<number>\";\r\n  inherits: true;\r\n  initial-value: 0;\r\n}\r\n\r\n/**\r\n * Animates --drawer-snap-progress from 0 to 1 based on scroll position\r\n * Applied to drawer viewport with animation-timeline: scroll()\r\n */\r\n@keyframes drawer-snap-progress {\r\n  from {\r\n    --drawer-snap-progress: 0;\r\n  }\r\n  to {\r\n    --drawer-snap-progress: 1;\r\n  }\r\n}\r\n\r\n/**\r\n * Animates backdrop opacity based on drawer panel visibility (view timeline)\r\n * Uses view() timeline - opacity naturally scales with how much drawer is visible\r\n * Applied to drawer backdrop with animation-timeline: --drawer-panel\r\n */\r\n@keyframes drawer-backdrop-fade {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n/**\r\n * Reversed backdrop fade for top/left drawers\r\n * These use exit range where 0% = visible, 100% = hidden\r\n */\r\n@keyframes drawer-backdrop-fade-reverse {\r\n  from {\r\n    opacity: 1;\r\n  }\r\n  to {\r\n    opacity: 0;\r\n  }\r\n}\r\n\r\n/**\r\n * Exit animation for drawer backdrop\r\n * Animates from current opacity to 0 (no 'from' = starts from computed value)\r\n * Used to override scroll-driven animations which transitions can't interpolate from\r\n */\r\n@keyframes drawer-backdrop-exit {\r\n  to {\r\n    opacity: 0;\r\n  }\r\n}\r\n",
      "type": "registry:file",
      "target": "components/ui/cubby-ui/drawer.css"
    }
  ]
}