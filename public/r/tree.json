{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "tree",
  "type": "registry:ui",
  "title": "Tree",
  "description": "A tree component.",
  "dependencies": [
    "lucide-react"
  ],
  "registryDependencies": [
    "@cubby-ui/checkbox"
  ],
  "files": [
    {
      "path": "registry/default/tree/tree.tsx",
      "content": "\"use client\";\n\nimport * as React from \"react\";\nimport { Collapsible as BaseCollapsible } from \"@base-ui/react/collapsible\";\nimport { CheckboxGroup } from \"@base-ui/react/checkbox-group\";\nimport { Checkbox } from \"@/registry/default/checkbox/checkbox\";\nimport { ChevronRightIcon, Loader2Icon } from \"lucide-react\";\nimport { mergeProps } from \"@base-ui/react/merge-props\";\nimport { useRender } from \"@base-ui/react/use-render\";\nimport { cn } from \"@/lib/utils\";\nimport {\n  getAllDescendantIds,\n  getLeafNodeIds,\n  buildParentMap,\n  collectVisibleIds,\n  handleTreeKeyboardNavigation,\n} from \"./lib/tree-utils\";\n\n// ============================================================================\n// Types\n// ============================================================================\n\nexport interface TreeNodeBase<\n  TData extends Record<string, unknown> = Record<string, unknown>,\n> {\n  id: string;\n  name: string;\n  data?: TData;\n  disabled?: boolean;\n  loading?: boolean;\n  icon?: React.ReactNode;\n  badge?: React.ReactNode;\n}\n\nexport interface TreeLeafNode<\n  TData extends Record<string, unknown> = Record<string, unknown>,\n> extends TreeNodeBase<TData> {\n  children?: never;\n}\n\nexport interface TreeParentNode<\n  TData extends Record<string, unknown> = Record<string, unknown>,\n> extends TreeNodeBase<TData> {\n  children: TreeNode<TData>[];\n  iconOpen?: React.ReactNode;\n  onLoadChildren?: () => Promise<TreeNode<TData>[]>;\n}\n\nexport type TreeNode<\n  TData extends Record<string, unknown> = Record<string, unknown>,\n> = TreeLeafNode<TData> | TreeParentNode<TData>;\n\nexport interface TreeSelectEvent<\n  TData extends Record<string, unknown> = Record<string, unknown>,\n> {\n  nodeId: string;\n  node: TreeNode<TData>;\n  event: React.MouseEvent | React.KeyboardEvent;\n}\n\nexport interface TreeExpandEvent {\n  nodeId: string;\n  expanded: boolean;\n}\n\ntype TreeVariant = \"default\" | \"filled\" | \"outline\";\ntype TreeMode = \"single\" | \"multiple\" | \"none\";\n\n// ============================================================================\n// Context\n// ============================================================================\n\ninterface TreeContextValue<\n  TData extends Record<string, unknown> = Record<string, unknown>,\n> {\n  // Tree-level state\n  selectedNode?: string | null;\n  onNodeSelect?: (nodeId: string) => void;\n  expandedNodes: Set<string>;\n  onToggleNode: (nodeId: string) => void | Promise<void>;\n  checkedNodes?: Set<string>;\n  onCheckedNodesChange?: (checked: string[]) => void;\n  renderItem: (item: TreeNode<TData>) => React.ReactElement;\n  variant: TreeVariant;\n  showLines: boolean;\n  enableBulkActions: boolean;\n  disableSelection: boolean;\n  focusableNodes: React.MutableRefObject<Map<string, HTMLElement>>;\n  visibleNodeIds: string[];\n  disabledNodesMap: Map<string, boolean>;\n  loadingNodesMap: Map<string, boolean>;\n  parentNodeMap: Map<string, string>;\n  lastFocusedNodeId: string | null;\n  setLastFocusedNodeId: (nodeId: string | null) => void;\n  data: TreeNode<TData>[];\n  // Item-level state\n  item?: TreeNode<TData>;\n  depth?: number;\n  isExpanded?: boolean;\n  isSelected?: boolean;\n  hasChildren?: boolean;\n  isLoading?: boolean;\n}\n\nconst TreeContext = React.createContext<TreeContextValue | null>(null);\n\nfunction useTreeContext<\n  TData extends Record<string, unknown> = Record<string, unknown>,\n>(): TreeContextValue<TData> {\n  const context = React.useContext(\n    TreeContext,\n  ) as TreeContextValue<TData> | null;\n  if (!context) {\n    throw new Error(\"Tree components must be used within a Tree\");\n  }\n  return context;\n}\n\n// Extracts item-level state from context for TreeItem subcomponents\nfunction useTreeItemContext<\n  TData extends Record<string, unknown> = Record<string, unknown>,\n>(): Required<\n  Pick<\n    TreeContextValue<TData>,\n    \"item\" | \"depth\" | \"isExpanded\" | \"isSelected\" | \"hasChildren\" | \"isLoading\"\n  >\n> {\n  const context = useTreeContext<TData>();\n  if (!context.item) {\n    throw new Error(\"TreeItem subcomponents must be used within TreeItem\");\n  }\n  return {\n    item: context.item,\n    depth: context.depth!,\n    isExpanded: context.isExpanded!,\n    isSelected: context.isSelected!,\n    hasChildren: context.hasChildren!,\n    isLoading: context.isLoading!,\n  };\n}\n\n// ============================================================================\n// Tree Root\n// ============================================================================\n\nexport interface TreeProps<\n  TData extends Record<string, unknown> = Record<string, unknown>,\n> extends Omit<useRender.ComponentProps<\"div\">, \"children\"> {\n  data: TreeNode<TData>[];\n  children: (item: TreeNode<TData>) => React.ReactElement;\n  selectedNode?: string | null;\n  onNodeSelect?: (nodeId: string) => void;\n  defaultExpanded?: string[];\n  expanded?: string[];\n  onExpandedChange?: (expanded: string[]) => void;\n  checkedNodes?: string[];\n  onCheckedNodesChange?: (checked: string[]) => void;\n  variant?: TreeVariant;\n  showLines?: boolean;\n  mode?: TreeMode;\n}\n\nfunction Tree<TData extends Record<string, unknown> = Record<string, unknown>>({\n  data,\n  children: renderItem,\n  selectedNode,\n  onNodeSelect,\n  defaultExpanded = [],\n  expanded,\n  onExpandedChange,\n  checkedNodes,\n  onCheckedNodesChange,\n  variant = \"default\",\n  showLines = false,\n  mode = \"single\",\n  className,\n  render,\n  ...props\n}: TreeProps<TData>): React.ReactElement {\n  // Derive internal flags from mode\n  const enableBulkActions = mode === \"multiple\";\n  const disableSelection = mode === \"none\";\n  // Validate tree structure in development\n  if (process.env.NODE_ENV === \"development\") {\n    React.useEffect(() => {\n      try {\n        const { validateTreeStructure } = require(\"./lib/tree-utils\");\n        validateTreeStructure(data);\n      } catch (error) {\n        console.error(\"Tree validation error:\", error);\n      }\n    }, [data]);\n  }\n\n  // Store renderItem in ref for stable context reference\n  const renderItemRef = React.useRef(renderItem);\n  renderItemRef.current = renderItem;\n\n  const [internalExpanded, setInternalExpanded] = React.useState<Set<string>>(\n    () => new Set(defaultExpanded),\n  );\n\n  const focusableNodes = React.useRef<Map<string, HTMLElement>>(new Map());\n  const [lastFocusedNodeId, setLastFocusedNodeId] = React.useState<\n    string | null\n  >(null);\n\n  // Track nodes that are currently loading children\n  const [loadingNodes, setLoadingNodes] = React.useState<Set<string>>(\n    () => new Set(),\n  );\n\n  // Track nodes that have already loaded their children\n  const loadedNodesRef = React.useRef<Set<string>>(new Set());\n\n  // Store dynamically loaded children\n  const [loadedChildren, setLoadedChildren] = React.useState<\n    Map<string, TreeNode<TData>[]>\n  >(() => new Map());\n\n  const expandedNodes = React.useMemo(() => {\n    return expanded ? new Set(expanded) : internalExpanded;\n  }, [expanded, internalExpanded]);\n\n  // Merge loaded children into the tree data\n  const mergedData = React.useMemo(() => {\n    if (loadedChildren.size === 0) return data;\n\n    const mergeChildren = (nodes: TreeNode<TData>[]): TreeNode<TData>[] => {\n      return nodes.map((node) => {\n        const loaded = loadedChildren.get(node.id);\n        if (loaded) {\n          return { ...node, children: loaded };\n        }\n        if (node.children) {\n          return { ...node, children: mergeChildren(node.children) };\n        }\n        return node;\n      });\n    };\n\n    return mergeChildren(data);\n  }, [data, loadedChildren]);\n\n  const handleToggleNode = React.useCallback(\n    async (nodeId: string) => {\n      const isCurrentlyExpanded = expandedNodes.has(nodeId);\n      const isExpanding = !isCurrentlyExpanded;\n\n      // Find the node to check if it needs to load children\n      const findNode = (\n        nodes: TreeNode<TData>[],\n      ): TreeNode<TData> | undefined => {\n        for (const node of nodes) {\n          if (node.id === nodeId) return node;\n          if (node.children) {\n            const found = findNode(node.children);\n            if (found) return found;\n          }\n        }\n        return undefined;\n      };\n\n      const node = findNode(mergedData);\n      const needsToLoad =\n        isExpanding &&\n        node &&\n        \"onLoadChildren\" in node &&\n        node.onLoadChildren &&\n        !loadedNodesRef.current.has(nodeId);\n\n      // If we need to load children, delay expansion until loaded\n      if (needsToLoad) {\n        setLoadingNodes((prev) => new Set(prev).add(nodeId));\n        loadedNodesRef.current.add(nodeId);\n\n        try {\n          const children = await node.onLoadChildren!();\n          setLoadedChildren((prev) => {\n            const next = new Map(prev);\n            next.set(nodeId, children);\n            return next;\n          });\n\n          // NOW expand the node after children are loaded\n          const newExpanded = new Set(expandedNodes);\n          newExpanded.add(nodeId);\n          if (expanded && onExpandedChange) {\n            onExpandedChange(Array.from(newExpanded));\n          } else {\n            setInternalExpanded(newExpanded);\n          }\n        } catch (error) {\n          console.error(`Failed to load children for node ${nodeId}:`, error);\n          loadedNodesRef.current.delete(nodeId);\n        } finally {\n          setLoadingNodes((prev) => {\n            const next = new Set(prev);\n            next.delete(nodeId);\n            return next;\n          });\n        }\n        return;\n      }\n\n      // Standard toggle for collapsing or nodes that don't need to load\n      const newExpanded = new Set(expandedNodes);\n      if (isCurrentlyExpanded) {\n        newExpanded.delete(nodeId);\n      } else {\n        newExpanded.add(nodeId);\n      }\n\n      if (expanded && onExpandedChange) {\n        onExpandedChange(Array.from(newExpanded));\n      } else {\n        setInternalExpanded(newExpanded);\n      }\n    },\n    [expandedNodes, expanded, onExpandedChange, mergedData],\n  );\n\n  const checkedNodesSet = React.useMemo(() => {\n    return checkedNodes ? new Set(checkedNodes) : undefined;\n  }, [checkedNodes]);\n\n  // Compute parent node map for ALL nodes (not just visible ones)\n  const parentNodeMap = React.useMemo(\n    () => buildParentMap(mergedData),\n    [mergedData],\n  );\n\n  const { visibleNodeIds, disabledNodesMap } = React.useMemo(\n    () => collectVisibleIds(mergedData, expandedNodes),\n    [mergedData, expandedNodes],\n  );\n\n  // Create loading nodes map\n  const loadingNodesMap = React.useMemo(() => {\n    const map = new Map<string, boolean>();\n    loadingNodes.forEach((id) => map.set(id, true));\n    return map;\n  }, [loadingNodes]);\n\n  // Focus restoration: when data changes and focused node is removed, focus first node\n  React.useEffect(() => {\n    if (!lastFocusedNodeId || visibleNodeIds.includes(lastFocusedNodeId))\n      return;\n\n    const firstId = visibleNodeIds[0];\n    if (firstId) {\n      setLastFocusedNodeId(firstId);\n      setTimeout(() => focusableNodes.current.get(firstId)?.focus(), 0);\n    } else {\n      setLastFocusedNodeId(null);\n    }\n  }, [visibleNodeIds, lastFocusedNodeId]);\n\n  const contextValue = React.useMemo(\n    () => ({\n      selectedNode,\n      onNodeSelect,\n      expandedNodes,\n      onToggleNode: handleToggleNode,\n      checkedNodes: checkedNodesSet,\n      onCheckedNodesChange,\n      renderItem: ((item: TreeNode<Record<string, unknown>>) =>\n        renderItemRef.current(item as TreeNode<TData>)) as (\n        item: TreeNode<Record<string, unknown>>,\n      ) => React.ReactElement,\n      variant,\n      showLines,\n      enableBulkActions,\n      disableSelection,\n      focusableNodes,\n      visibleNodeIds,\n      disabledNodesMap,\n      loadingNodesMap,\n      parentNodeMap,\n      lastFocusedNodeId,\n      setLastFocusedNodeId,\n      data: mergedData,\n    }),\n    [\n      selectedNode,\n      onNodeSelect,\n      expandedNodes,\n      handleToggleNode,\n      checkedNodesSet,\n      onCheckedNodesChange,\n      variant,\n      showLines,\n      enableBulkActions,\n      disableSelection,\n      visibleNodeIds,\n      disabledNodesMap,\n      loadingNodesMap,\n      parentNodeMap,\n      lastFocusedNodeId,\n      setLastFocusedNodeId,\n      mergedData,\n    ],\n  );\n\n  const defaultProps = {\n    \"data-slot\": \"tree\",\n    className: cn(\n      \"w-full min-w-0 text-sm\",\n      variant === \"filled\" &&\n        \"ring ring-border/60 ring-1 bg-muted rounded-2xl p-2 shadow-sm\",\n      variant === \"outline\" &&\n        \"overflow-hidden rounded-2xl ring ring-border/60 bg-card p-2 shadow-sm\",\n      className,\n    ),\n    role: \"tree\",\n    \"aria-multiselectable\": enableBulkActions,\n    children: (\n      <TreeContext.Provider value={contextValue}>\n        {mergedData.map((node, index) => (\n          <TreeItemInternal\n            key={node.id}\n            node={node}\n            depth={0}\n            positionInSet={index + 1}\n            setSize={mergedData.length}\n          />\n        ))}\n      </TreeContext.Provider>\n    ),\n  };\n\n  const element = useRender({\n    defaultTagName: \"div\",\n    render: render,\n    props: mergeProps<\"div\">(defaultProps, props),\n  });\n\n  return element;\n}\n\n// ============================================================================\n// Constants\n// ============================================================================\n\nconst INDENT_SIZE = 20;\nconst INDENT_SIZE_WITH_CHECKBOX = 12;\nconst VERTICAL_LINE_OFFSET = 4.5;\nconst CHILD_VERTICAL_LINE_OFFSET = 15.5;\nconst BADGE_TEXT_SIZE = \"text-[10px]\";\n\n// ============================================================================\n// Helper Functions - Defined outside component for stable references\n// ============================================================================\n\n/**\n * Updates parent nodes based on their children's checked state.\n * A parent is checked if all its leaf descendants are checked.\n */\nfunction updateParentCheckStates<\n  TData extends Record<string, unknown> = Record<string, unknown>,\n>(nodes: TreeNode<TData>[], checkedSet: Set<string>): void {\n  for (const node of nodes) {\n    if (node.children && node.children.length > 0) {\n      // Recursively update children first (bottom-up)\n      updateParentCheckStates(node.children, checkedSet);\n\n      // Get all leaf descendants of this parent\n      const leafIds = getLeafNodeIds(node.children);\n\n      // Parent should be checked if all leaf descendants are checked\n      const allLeavesChecked = leafIds.every((id) => checkedSet.has(id));\n\n      if (allLeavesChecked) {\n        checkedSet.add(node.id);\n      } else {\n        checkedSet.delete(node.id);\n      }\n    }\n  }\n}\n\n// ============================================================================\n// Custom Hooks\n// ============================================================================\n\ninterface UseTreeCheckboxStateParams<\n  TData extends Record<string, unknown> = Record<string, unknown>,\n> {\n  node: TreeNode<TData>;\n  hasChildren: boolean;\n  context: TreeContextValue<TData>;\n}\n\ninterface UseTreeCheckboxStateReturn {\n  allDescendantIds: string[];\n  localChildValues: string[];\n  handleLocalCheckboxChange: (newValues: string[]) => void;\n}\n\nfunction useTreeCheckboxState<\n  TData extends Record<string, unknown> = Record<string, unknown>,\n>({\n  node,\n  hasChildren,\n  context,\n}: UseTreeCheckboxStateParams<TData>): UseTreeCheckboxStateReturn {\n  const allDescendantIds = React.useMemo(\n    () => (hasChildren ? getAllDescendantIds(node) : []),\n    [hasChildren, node],\n  );\n\n  const allLeafIds = React.useMemo(\n    () => (hasChildren ? getLeafNodeIds(node.children || []) : []),\n    [hasChildren, node.children],\n  );\n\n  const localChildValues = React.useMemo(() => {\n    if (!hasChildren || !context.checkedNodes || !context.enableBulkActions)\n      return [];\n    return allDescendantIds.filter((id) => context.checkedNodes!.has(id));\n  }, [\n    hasChildren,\n    context.checkedNodes,\n    allDescendantIds,\n    context.enableBulkActions,\n  ]);\n\n  const handleLocalCheckboxChange = React.useCallback(\n    (newValues: string[]) => {\n      if (!context.onCheckedNodesChange || !context.checkedNodes) return;\n\n      const currentSet = new Set(context.checkedNodes);\n\n      // Remove all descendants\n      for (const id of allDescendantIds) {\n        currentSet.delete(id);\n      }\n\n      // Add back the selected values (these are all descendants now)\n      for (const id of newValues) {\n        currentSet.add(id);\n      }\n\n      // Update all parent nodes based on their children's checked state\n      // This will correctly set all ancestors (parent, grandparent, etc.)\n      updateParentCheckStates(context.data, currentSet);\n\n      context.onCheckedNodesChange(Array.from(currentSet));\n    },\n    [context, allDescendantIds],\n  );\n\n  return {\n    allDescendantIds,\n    localChildValues,\n    handleLocalCheckboxChange,\n  };\n}\n\n// ============================================================================\n// TreeItemInternal - Handles recursion internally\n// ============================================================================\n\ninterface TreeItemInternalProps<\n  TData extends Record<string, unknown> = Record<string, unknown>,\n> {\n  node: TreeNode<TData>;\n  depth: number;\n  positionInSet?: number;\n  setSize?: number;\n}\n\nfunction TreeItemInternal<\n  TData extends Record<string, unknown> = Record<string, unknown>,\n>({\n  node,\n  depth,\n  positionInSet,\n  setSize,\n}: TreeItemInternalProps<TData>): React.ReactElement {\n  const context = useTreeContext<TData>();\n\n  const hasChildren = Boolean(\n    (node.children && node.children.length > 0) ||\n      (\"onLoadChildren\" in node && node.onLoadChildren),\n  );\n  const isExpanded = context.expandedNodes.has(node.id);\n  const isSelected = context.selectedNode === node.id;\n  const isDisabled = node.disabled || false;\n  const isLoading =\n    context.loadingNodesMap.has(node.id) || node.loading || false;\n  const isChecked =\n    context.enableBulkActions && context.checkedNodes\n      ? context.checkedNodes.has(node.id)\n      : false;\n\n  // Roving tabindex: only the last focused node should be tabbable\n  // If no node has been focused yet, the first node is tabbable\n  const isFirstNode = context.visibleNodeIds[0] === node.id;\n  const isLastFocused = context.lastFocusedNodeId === node.id;\n  const isTabbable =\n    isLastFocused || (!context.lastFocusedNodeId && isFirstNode);\n\n  // Create merged context value with item-level state\n  const mergedContextValue = React.useMemo(\n    () => ({\n      ...context,\n      item: node,\n      depth,\n      isExpanded,\n      isSelected,\n      hasChildren,\n      isLoading,\n    }),\n    [context, node, depth, isExpanded, isSelected, hasChildren, isLoading],\n  );\n\n  const handleToggleChecked = React.useCallback(() => {\n    if (!context.onCheckedNodesChange || !context.checkedNodes) return;\n\n    const currentSet = new Set(context.checkedNodes);\n    const allDescendantIds = hasChildren ? getAllDescendantIds(node) : [];\n\n    if (isChecked) {\n      // Uncheck this node and all descendants\n      currentSet.delete(node.id);\n      for (const id of allDescendantIds) {\n        currentSet.delete(id);\n      }\n    } else {\n      // Check this node and all descendants\n      currentSet.add(node.id);\n      for (const id of allDescendantIds) {\n        currentSet.add(id);\n      }\n    }\n\n    // Update all parent nodes based on their children's checked state\n    updateParentCheckStates(context.data, currentSet);\n\n    context.onCheckedNodesChange(Array.from(currentSet));\n  }, [context, isChecked, node, hasChildren]);\n\n  const handleClick = React.useCallback(\n    (e: React.MouseEvent) => {\n      if (isDisabled) return;\n      e.stopPropagation();\n\n      if (context.enableBulkActions) {\n        handleToggleChecked();\n      } else if (!context.disableSelection) {\n        context.onNodeSelect?.(node.id);\n      }\n    },\n    [context, node.id, isDisabled, handleToggleChecked],\n  );\n\n  const handleKeyDown = React.useCallback(\n    (e: React.KeyboardEvent) => {\n      handleTreeKeyboardNavigation(e, {\n        nodeId: node.id,\n        hasChildren,\n        isExpanded,\n        isDisabled,\n        node,\n        visibleNodeIds: context.visibleNodeIds,\n        disabledNodesMap: context.disabledNodesMap,\n        parentNodeMap: context.parentNodeMap,\n        focusableNodes: context.focusableNodes.current,\n        enableBulkActions: context.enableBulkActions,\n        disableSelection: context.disableSelection,\n        onToggleNode: context.onToggleNode,\n        onNodeSelect: context.onNodeSelect,\n        setLastFocusedNodeId: context.setLastFocusedNodeId,\n        handleToggleChecked,\n      });\n    },\n    [\n      node,\n      hasChildren,\n      isExpanded,\n      isDisabled,\n      context.visibleNodeIds,\n      context.disabledNodesMap,\n      context.parentNodeMap,\n      context.focusableNodes,\n      context.enableBulkActions,\n      context.disableSelection,\n      context.onToggleNode,\n      context.onNodeSelect,\n      context.setLastFocusedNodeId,\n      handleToggleChecked,\n    ],\n  );\n\n  const paddingLeft =\n    depth *\n    (context.enableBulkActions ? INDENT_SIZE_WITH_CHECKBOX : INDENT_SIZE);\n\n  // Checkbox state management\n  const { allDescendantIds, localChildValues, handleLocalCheckboxChange } =\n    useTreeCheckboxState({\n      node,\n      hasChildren,\n      context,\n    });\n\n  // Render leaf node (no children)\n  if (!hasChildren) {\n    return (\n      <TreeContext.Provider value={mergedContextValue as TreeContextValue}>\n        <div className={cn(\"mt-0.5 first:mt-0\")}>\n          <div\n            className=\"group relative flex select-none\"\n            style={{ paddingLeft }}\n          >\n            {context.showLines && depth > 0 && (\n              <div\n                className=\"absolute top-0 bottom-0 left-0\"\n                style={{ left: paddingLeft - VERTICAL_LINE_OFFSET }}\n              >\n                <div className=\"bg-border h-full w-px\" />\n              </div>\n            )}\n            <div\n              className={cn(\n                \"flex flex-1 items-center gap-2 rounded-md px-2 py-1.5 text-sm transition-colors\",\n                \"hover:bg-accent\",\n                isSelected &&\n                  !context.disableSelection &&\n                  \"bg-accent text-accent-foreground\",\n                isDisabled && \"cursor-not-allowed opacity-50\",\n              )}\n            >\n              <div\n                ref={(el) => {\n                  if (el) {\n                    context.focusableNodes.current.set(node.id, el);\n                  } else {\n                    context.focusableNodes.current.delete(node.id);\n                  }\n                }}\n                className={cn(\n                  \"-my-1.5 flex flex-1 items-center gap-2 rounded-md px-2 py-1.5 transition-colors outline-none select-none\",\n                  \"-mx-2\",\n                  \"focus-visible:bg-accent focus-visible:ring-ring/50 focus-visible:ring-2\",\n                  !isDisabled && \"cursor-pointer\",\n                )}\n                onClick={handleClick}\n                onKeyDown={(e) => {\n                  if (e.key === \" \" || e.key === \"Enter\") {\n                    e.stopPropagation();\n                  }\n                  handleKeyDown(e);\n                }}\n                onFocus={() => {\n                  context.setLastFocusedNodeId(node.id);\n                }}\n                role=\"treeitem\"\n                aria-level={depth + 1}\n                aria-setsize={setSize}\n                aria-posinset={positionInSet}\n                aria-selected={\n                  context.enableBulkActions ? undefined : isSelected\n                }\n                aria-checked={context.enableBulkActions ? isChecked : undefined}\n                aria-disabled={isDisabled}\n                tabIndex={isDisabled ? -1 : isTabbable ? 0 : -1}\n              >\n                {context.enableBulkActions && (\n                  <Checkbox\n                    value={node.id}\n                    checked={isChecked}\n                    disabled={isDisabled}\n                    tabIndex={-1}\n                    className=\"pointer-events-none\"\n                  />\n                )}\n                {context.renderItem(node)}\n              </div>\n            </div>\n          </div>\n        </div>\n      </TreeContext.Provider>\n    );\n  }\n\n  // Render parent node (has children)\n\n  const parentContent = (\n    <TreeContext.Provider value={mergedContextValue as TreeContextValue}>\n      <div\n        role=\"treeitem\"\n        aria-expanded={isExpanded}\n        aria-level={depth + 1}\n        aria-setsize={setSize}\n        aria-posinset={positionInSet}\n        aria-selected={context.enableBulkActions ? undefined : isSelected}\n        aria-checked={context.enableBulkActions ? isChecked : undefined}\n        aria-disabled={isDisabled}\n        className={cn(\"mt-0.5 first:mt-0\")}\n      >\n        <BaseCollapsible.Root\n          open={isExpanded}\n          onOpenChange={() => !isDisabled && context.onToggleNode(node.id)}\n        >\n          <div\n            className=\"group relative flex select-none\"\n            style={{ paddingLeft }}\n          >\n            {context.showLines && depth > 0 && (\n              <div\n                className=\"absolute top-0 bottom-0 left-0\"\n                style={{ left: paddingLeft - VERTICAL_LINE_OFFSET }}\n              >\n                <div className=\"bg-border h-full w-px\" />\n              </div>\n            )}\n            <div\n              className={cn(\n                \"flex flex-1 items-center gap-2 rounded-md px-2 py-1.5 text-sm transition-colors\",\n                \"hover:bg-accent\",\n                isSelected &&\n                  !context.disableSelection &&\n                  \"bg-accent text-accent-foreground\",\n                isDisabled && \"cursor-not-allowed opacity-50\",\n              )}\n            >\n              {context.enableBulkActions ? (\n                // In bulk actions mode, use plain div to avoid Collapsible.Trigger keyboard handling\n                <div\n                  ref={(el) => {\n                    if (el) {\n                      context.focusableNodes.current.set(node.id, el);\n                    } else {\n                      context.focusableNodes.current.delete(node.id);\n                    }\n                  }}\n                  className={cn(\n                    \"group/trigger -mx-2 -my-1.5 flex flex-1 items-center gap-2 rounded-md border-0 bg-transparent px-2 py-1.5 text-left transition-colors outline-none select-none\",\n                    \"focus-visible:bg-accent focus-visible:ring-ring/50 focus-visible:ring-2\",\n                    !isDisabled && \"cursor-pointer\",\n                  )}\n                  onClick={() => {\n                    // Clicking node text/content expands/collapses\n                    if (!isDisabled) {\n                      context.onToggleNode(node.id);\n                    }\n                  }}\n                  onKeyDown={handleKeyDown}\n                  onFocus={() => {\n                    context.setLastFocusedNodeId(node.id);\n                  }}\n                  tabIndex={isDisabled ? -1 : isTabbable ? 0 : -1}\n                >\n                  <span\n                    onClick={(e: React.MouseEvent) => {\n                      // Clicking checkbox toggles checked state\n                      e.stopPropagation();\n                      handleToggleChecked();\n                    }}\n                  >\n                    <Checkbox\n                      parent\n                      disabled={isDisabled}\n                      tabIndex={-1}\n                      className=\"pointer-events-auto cursor-pointer\"\n                    />\n                  </span>\n                  <ChevronRightIcon\n                    aria-hidden=\"true\"\n                    className={cn(\n                      \"text-muted-foreground ease-out-cubic size-4 shrink-0 transition-transform duration-[325ms]\",\n                      isExpanded && \"rotate-90\",\n                      isDisabled && \"opacity-50\",\n                    )}\n                  />\n                  {context.renderItem(node)}\n                </div>\n              ) : (\n                // In navigation/selection mode, use Collapsible.Trigger for built-in behavior\n                <BaseCollapsible.Trigger\n                  ref={(el) => {\n                    if (el) {\n                      context.focusableNodes.current.set(node.id, el);\n                    } else {\n                      context.focusableNodes.current.delete(node.id);\n                    }\n                  }}\n                  className={cn(\n                    \"group/trigger -mx-2 -my-1.5 flex flex-1 items-center gap-2 rounded-md border-0 bg-transparent px-2 py-1.5 text-left transition-colors outline-none select-none\",\n                    \"focus-visible:bg-accent focus-visible:ring-ring/50 focus-visible:ring-2\",\n                    !isDisabled && \"cursor-pointer\",\n                  )}\n                  onClick={(e) => {\n                    if (!isDisabled && !context.disableSelection) {\n                      handleClick(e);\n                    }\n                  }}\n                  onKeyDown={handleKeyDown}\n                  onFocus={() => {\n                    context.setLastFocusedNodeId(node.id);\n                  }}\n                  disabled={isDisabled}\n                  tabIndex={isDisabled ? -1 : isTabbable ? 0 : -1}\n                >\n                  <ChevronRightIcon\n                    aria-hidden=\"true\"\n                    className={cn(\n                      \"text-muted-foreground ease-out-cubic size-4 shrink-0 transition-transform duration-[325ms]\",\n                      isExpanded && \"rotate-90\",\n                      isDisabled && \"opacity-50\",\n                    )}\n                  />\n                  {context.renderItem(node)}\n                </BaseCollapsible.Trigger>\n              )}\n            </div>\n          </div>\n\n          <BaseCollapsible.Panel\n            className={cn(\n              \"ease-out-cubic h-[var(--collapsible-panel-height)] overflow-y-clip transition-all duration-[325ms]\",\n              \"data-[ending-style]:h-0 data-[ending-style]:opacity-0\",\n              \"data-[starting-style]:h-0 data-[starting-style]:opacity-0\",\n            )}\n          >\n            {node.children && node.children.length > 0 && (\n              <div\n                className={cn(\n                  context.showLines && \"relative\",\n                  \"pt-0.5 pb-0.5 pl-0\",\n                )}\n              >\n                {context.showLines && (\n                  <div\n                    className=\"bg-border absolute top-0 bottom-0 w-px\"\n                    style={{ left: paddingLeft + CHILD_VERTICAL_LINE_OFFSET }}\n                  />\n                )}\n                {node.children.map((child, index) => (\n                  <TreeItemInternal\n                    key={child.id}\n                    node={child}\n                    depth={depth + 1}\n                    positionInSet={index + 1}\n                    setSize={node.children?.length}\n                  />\n                ))}\n              </div>\n            )}\n          </BaseCollapsible.Panel>\n        </BaseCollapsible.Root>\n      </div>\n    </TreeContext.Provider>\n  );\n\n  if (context.enableBulkActions) {\n    return (\n      <CheckboxGroup\n        value={localChildValues}\n        onValueChange={handleLocalCheckboxChange}\n        allValues={allDescendantIds}\n      >\n        {parentContent}\n      </CheckboxGroup>\n    );\n  }\n\n  return parentContent;\n}\n\n// ============================================================================\n// TreeItem Component (Public API)\n// ============================================================================\n\nexport interface TreeItemProps extends useRender.ComponentProps<\"div\"> {\n  children: React.ReactNode;\n}\n\nfunction TreeItem({\n  className,\n  children,\n  render,\n  ...props\n}: TreeItemProps) {\n  const defaultProps = {\n    \"data-slot\": \"tree-item\",\n    className: cn(\"flex flex-1 items-center gap-2\", className),\n    children,\n  };\n\n  const element = useRender({\n    defaultTagName: \"div\",\n    render,\n    props: mergeProps<\"div\">(defaultProps, props),\n  });\n\n  return element;\n}\n\n// ============================================================================\n// TreeItemIcon Component\n// ============================================================================\n\nexport interface TreeItemIconProps extends useRender.ComponentProps<\"span\"> {\n  children?: React.ReactNode;\n}\n\nfunction TreeItemIcon({\n  children,\n  className,\n  render,\n  ...props\n}: TreeItemIconProps) {\n  const { item, isExpanded, isLoading } = useTreeItemContext();\n\n  // Show loading spinner if node is loading\n  let displayIcon: React.ReactNode;\n  if (isLoading) {\n    displayIcon = <Loader2Icon className=\"animate-spin\" />;\n  } else {\n    displayIcon =\n      isExpanded && \"iconOpen\" in item && item.iconOpen\n        ? item.iconOpen\n        : children;\n  }\n\n  if (!displayIcon) return null;\n\n  const defaultProps = {\n    \"data-slot\": \"tree-item-icon\",\n    className: cn(\"text-muted-foreground shrink-0 [&>svg]:size-4\", className),\n    children: displayIcon,\n  };\n\n  const element = useRender({\n    defaultTagName: \"span\",\n    render,\n    props: mergeProps<\"span\">(defaultProps, props),\n  });\n\n  return element;\n}\n\n// ============================================================================\n// TreeItemLabel Component\n// ============================================================================\n\nexport interface TreeItemLabelProps extends useRender.ComponentProps<\"span\"> {\n  children: React.ReactNode;\n}\n\nfunction TreeItemLabel({\n  children,\n  className,\n  render,\n  ...props\n}: TreeItemLabelProps) {\n  if (!children) return null;\n\n  const defaultProps = {\n    \"data-slot\": \"tree-item-label\",\n    className: cn(\"truncate\", className),\n    children,\n  };\n\n  const element = useRender({\n    defaultTagName: \"span\",\n    render,\n    props: mergeProps<\"span\">(defaultProps, props),\n  });\n\n  return element;\n}\n\n// ============================================================================\n// TreeItemBadge Component\n// ============================================================================\n\nexport interface TreeItemBadgeProps extends useRender.ComponentProps<\"span\"> {\n  children?: React.ReactNode;\n}\n\nfunction TreeItemBadge({\n  children,\n  className,\n  render,\n  ...props\n}: TreeItemBadgeProps) {\n  if (!children) return null;\n\n  const defaultProps = {\n    \"data-slot\": \"tree-item-badge\",\n    className: cn(\n      \"ml-auto flex shrink-0 items-center\",\n      // Scale down badges to match tree text size and prevent height increase\n      `[&_[data-slot=badge]]:py-0.5 [&_[data-slot=badge]]:${BADGE_TEXT_SIZE} [&_[data-slot=badge]]:leading-tight`,\n      className,\n    ),\n    children,\n  };\n\n  const element = useRender({\n    defaultTagName: \"span\",\n    render,\n    props: mergeProps<\"span\">(defaultProps, props),\n  });\n\n  return element;\n}\n\n// ============================================================================\n// Exports\n// ============================================================================\n\nexport {\n  Tree,\n  TreeItem,\n  TreeItemIcon,\n  TreeItemLabel,\n  TreeItemBadge,\n  type TreeVariant,\n  type TreeMode,\n};\n\nexport * as TreeUtils from \"./lib/tree-utils\";\n",
      "type": "registry:ui",
      "target": "components/ui/cubby-ui/tree.tsx"
    },
    {
      "path": "registry/default/tree/lib/tree-utils.ts",
      "content": "import type { TreeNode } from \"../tree\";\n\n/**\n * Validate tree structure for circular references and duplicate IDs\n * @param nodes - The tree data array\n * @param seen - Set of IDs already seen (for internal use)\n * @throws Error if circular reference or duplicate ID is detected\n */\nexport function validateTreeStructure<\n  TData extends Record<string, unknown> = Record<string, unknown>,\n>(nodes: TreeNode<TData>[], seen = new Set<string>()): void {\n  const idsInLevel = new Set<string>();\n\n  for (const node of nodes) {\n    // Check for duplicate IDs\n    if (idsInLevel.has(node.id)) {\n      throw new Error(`Tree validation error: Duplicate node ID \"${node.id}\"`);\n    }\n    idsInLevel.add(node.id);\n\n    // Check for circular references\n    if (seen.has(node.id)) {\n      throw new Error(\n        `Tree validation error: Circular reference detected for node ID \"${node.id}\"`,\n      );\n    }\n\n    const newSeen = new Set(seen);\n    newSeen.add(node.id);\n\n    if (node.children && node.children.length > 0) {\n      validateTreeStructure(node.children, newSeen);\n    }\n  }\n}\n\n/**\n * Get all descendant IDs of a node (recursive)\n * @param node - The parent node\n * @returns Array of all descendant node IDs\n */\nexport function getAllDescendantIds<\n  TData extends Record<string, unknown> = Record<string, unknown>,\n>(node: TreeNode<TData>): string[] {\n  const ids: string[] = [];\n  if (node.children) {\n    for (const child of node.children) {\n      ids.push(child.id);\n      if (child.children && child.children.length > 0) {\n        ids.push(...getAllDescendantIds(child));\n      }\n    }\n  }\n  return ids;\n}\n\n/**\n * Get IDs of all leaf nodes (nodes without children)\n * @param nodes - Array of tree nodes\n * @returns Array of leaf node IDs\n */\nexport function getLeafNodeIds<\n  TData extends Record<string, unknown> = Record<string, unknown>,\n>(nodes: TreeNode<TData>[]): string[] {\n  const leafIds: string[] = [];\n  for (const node of nodes) {\n    if (!node.children || node.children.length === 0) {\n      leafIds.push(node.id);\n    } else {\n      leafIds.push(...getLeafNodeIds(node.children));\n    }\n  }\n  return leafIds;\n}\n\n/**\n * Build a map of child node IDs to their parent node IDs\n * @param nodes - The tree data array\n * @param parentMap - Map to populate (for internal use)\n * @param parentId - Current parent ID (for internal use)\n * @returns Map of child ID to parent ID\n */\nexport function buildParentMap<\n  TData extends Record<string, unknown> = Record<string, unknown>,\n>(\n  nodes: TreeNode<TData>[],\n  parentMap = new Map<string, string>(),\n  parentId?: string,\n): Map<string, string> {\n  for (const node of nodes) {\n    if (parentId) {\n      parentMap.set(node.id, parentId);\n    }\n    if (node.children) {\n      buildParentMap(node.children, parentMap, node.id);\n    }\n  }\n  return parentMap;\n}\n\n/**\n * Collect IDs of all visible nodes (including children of expanded nodes)\n * @param nodes - The tree data array\n * @param expandedNodes - Set of expanded node IDs\n * @param ids - Array to populate (for internal use)\n * @param disabledMap - Map to track disabled nodes (for internal use)\n * @returns Object with visible node IDs and disabled nodes map\n */\nexport function collectVisibleIds<\n  TData extends Record<string, unknown> = Record<string, unknown>,\n>(\n  nodes: TreeNode<TData>[],\n  expandedNodes: Set<string>,\n  ids: string[] = [],\n  disabledMap = new Map<string, boolean>(),\n): { visibleNodeIds: string[]; disabledNodesMap: Map<string, boolean> } {\n  for (const node of nodes) {\n    ids.push(node.id);\n    if (node.disabled) {\n      disabledMap.set(node.id, true);\n    }\n    if (node.children && expandedNodes.has(node.id)) {\n      collectVisibleIds(node.children, expandedNodes, ids, disabledMap);\n    }\n  }\n  return { visibleNodeIds: ids, disabledNodesMap: disabledMap };\n}\n\n/**\n * Handle keyboard navigation for tree nodes\n * @param e - Keyboard event\n * @param params - Navigation parameters\n */\nexport function handleTreeKeyboardNavigation<\n  TData extends Record<string, unknown> = Record<string, unknown>,\n>(\n  e: React.KeyboardEvent,\n  params: {\n    nodeId: string;\n    hasChildren: boolean;\n    isExpanded: boolean;\n    isDisabled: boolean;\n    node: TreeNode<TData>;\n    visibleNodeIds: string[];\n    disabledNodesMap: Map<string, boolean>;\n    parentNodeMap: Map<string, string>;\n    focusableNodes: Map<string, HTMLElement>;\n    enableBulkActions: boolean;\n    disableSelection: boolean;\n    onToggleNode: (nodeId: string) => void;\n    onNodeSelect?: (nodeId: string) => void;\n    setLastFocusedNodeId: (nodeId: string | null) => void;\n    handleToggleChecked: () => void;\n  },\n): void {\n  const {\n    nodeId,\n    hasChildren,\n    isExpanded,\n    isDisabled,\n    node,\n    visibleNodeIds,\n    disabledNodesMap,\n    parentNodeMap,\n    focusableNodes,\n    enableBulkActions,\n    disableSelection,\n    onToggleNode,\n    onNodeSelect,\n    setLastFocusedNodeId,\n    handleToggleChecked,\n  } = params;\n\n  if (isDisabled) return;\n\n  const currentIndex = visibleNodeIds.indexOf(nodeId);\n\n  switch (e.key) {\n    case \" \":\n      e.preventDefault();\n      e.stopPropagation();\n      if (enableBulkActions) {\n        handleToggleChecked();\n      } else {\n        if (hasChildren) {\n          onToggleNode(nodeId);\n        }\n        if (!disableSelection) {\n          onNodeSelect?.(nodeId);\n        }\n      }\n      break;\n\n    case \"Enter\":\n      e.preventDefault();\n      e.stopPropagation();\n      if (enableBulkActions) {\n        if (hasChildren) {\n          onToggleNode(nodeId);\n        } else {\n          handleToggleChecked();\n        }\n      } else {\n        if (hasChildren) {\n          onToggleNode(nodeId);\n        }\n        if (!disableSelection) {\n          onNodeSelect?.(nodeId);\n        }\n      }\n      break;\n\n    case \"ArrowRight\":\n      e.preventDefault();\n      if (hasChildren) {\n        if (!isExpanded) {\n          onToggleNode(nodeId);\n        } else {\n          const firstChildId = node.children?.[0]?.id;\n          if (firstChildId && !disabledNodesMap.has(firstChildId)) {\n            const firstChildElement = focusableNodes.get(firstChildId);\n            if (firstChildElement) {\n              firstChildElement.focus();\n              setLastFocusedNodeId(firstChildId);\n            }\n          }\n        }\n      }\n      break;\n\n    case \"ArrowLeft\":\n      e.preventDefault();\n      if (hasChildren && isExpanded) {\n        onToggleNode(nodeId);\n      } else {\n        const parentId = parentNodeMap.get(nodeId);\n        if (parentId) {\n          const parentElement = focusableNodes.get(parentId);\n          if (parentElement) {\n            parentElement.focus();\n            setLastFocusedNodeId(parentId);\n          }\n        }\n      }\n      break;\n\n    case \"ArrowDown\": {\n      e.preventDefault();\n      let nextIndex = currentIndex + 1;\n      while (nextIndex < visibleNodeIds.length) {\n        const nextId = visibleNodeIds[nextIndex];\n        if (disabledNodesMap.has(nextId)) {\n          nextIndex++;\n          continue;\n        }\n        const nextElement = focusableNodes.get(nextId);\n        if (nextElement) {\n          nextElement.focus();\n          setLastFocusedNodeId(nextId);\n          break;\n        }\n        nextIndex++;\n      }\n      break;\n    }\n\n    case \"ArrowUp\": {\n      e.preventDefault();\n      let prevIndex = currentIndex - 1;\n      while (prevIndex >= 0) {\n        const prevId = visibleNodeIds[prevIndex];\n        if (disabledNodesMap.has(prevId)) {\n          prevIndex--;\n          continue;\n        }\n        const prevElement = focusableNodes.get(prevId);\n        if (prevElement) {\n          prevElement.focus();\n          setLastFocusedNodeId(prevId);\n          break;\n        }\n        prevIndex--;\n      }\n      break;\n    }\n\n    case \"Home\": {\n      e.preventDefault();\n      for (let i = 0; i < visibleNodeIds.length; i++) {\n        const firstId = visibleNodeIds[i];\n        if (disabledNodesMap.has(firstId)) continue;\n        const firstElement = focusableNodes.get(firstId);\n        if (firstElement) {\n          firstElement.focus();\n          setLastFocusedNodeId(firstId);\n          break;\n        }\n      }\n      break;\n    }\n\n    case \"End\": {\n      e.preventDefault();\n      for (let i = visibleNodeIds.length - 1; i >= 0; i--) {\n        const lastId = visibleNodeIds[i];\n        if (disabledNodesMap.has(lastId)) continue;\n        const lastElement = focusableNodes.get(lastId);\n        if (lastElement) {\n          lastElement.focus();\n          setLastFocusedNodeId(lastId);\n          break;\n        }\n      }\n      break;\n    }\n  }\n}\n",
      "type": "registry:lib",
      "target": "lib/cubby-ui/tree-utils.ts"
    }
  ]
}