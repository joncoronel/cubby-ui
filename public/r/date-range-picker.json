{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "date-range-picker",
  "type": "registry:ui",
  "title": "Date-range-picker",
  "description": "A date-range-picker component.",
  "dependencies": [
    "dayjs",
    "lucide-react",
    "react-day-picker"
  ],
  "registryDependencies": [
    "@cubby-ui/button",
    "@cubby-ui/calendar",
    "@cubby-ui/popover"
  ],
  "files": [
    {
      "path": "registry/default/date-range-picker/date-range-picker.tsx",
      "content": "import * as React from \"react\";\r\nimport dayjs from \"dayjs\";\r\nimport { CalendarIcon, ChevronsUpDownIcon } from \"lucide-react\";\r\n\r\nimport { Button } from \"@/registry/default/button/button\";\r\nimport { Calendar } from \"@/registry/default/calendar/calendar\";\r\nimport {\r\n  Popover,\r\n  PopoverContent,\r\n  PopoverTrigger,\r\n} from \"@/registry/default/popover/popover\";\r\nimport { cn } from \"@/lib/utils\";\r\n\r\nimport type { DateRange } from \"react-day-picker\";\r\n\r\nexport interface DateRangePickerProps {\r\n  value?: DateRange;\r\n  onSelect?: (range: DateRange | undefined) => void;\r\n  placeholder?: string;\r\n  className?: string;\r\n  disabled?: boolean;\r\n  format?: string;\r\n  numberOfMonths?: number;\r\n  fixedWeeks?: boolean;\r\n}\r\n\r\nexport function DateRangePicker({\r\n  value,\r\n  onSelect,\r\n  placeholder = \"Select date range\",\r\n  className,\r\n  disabled = false,\r\n  format = \"DD MMM YYYY\",\r\n  numberOfMonths = 1,\r\n  fixedWeeks = false,\r\n}: DateRangePickerProps) {\r\n  const [open, setOpen] = React.useState(false);\r\n  const [tempRange, setTempRange] = React.useState<DateRange | undefined>(\r\n    undefined,\r\n  );\r\n  const [hoverDate, setHoverDate] = React.useState<Date | undefined>(undefined);\r\n  const previousTempRangeRef = React.useRef<DateRange | undefined>(undefined);\r\n\r\n  // Initialize temp range with current value when popover opens\r\n  React.useEffect(() => {\r\n    if (open) {\r\n      setTempRange(value);\r\n      previousTempRangeRef.current = value;\r\n      setHoverDate(undefined);\r\n    }\r\n  }, [open, value]);\r\n\r\n  const formatDateRange = () => {\r\n    if (!value?.from) return placeholder;\r\n    if (!value.to) return dayjs(value.from).format(format);\r\n    return `${dayjs(value.from).format(format)} - ${dayjs(value.to).format(format)}`;\r\n  };\r\n\r\n  const displayRange = React.useMemo(() => {\r\n    // Show hover preview when selecting second date\r\n    if (tempRange?.from && !tempRange?.to && hoverDate) {\r\n      // Ensure proper range order\r\n      const start = tempRange.from;\r\n      const end = hoverDate;\r\n      if (start.getTime() <= end.getTime()) {\r\n        return { from: start, to: end };\r\n      } else {\r\n        return { from: end, to: start };\r\n      }\r\n    }\r\n    return tempRange;\r\n  }, [tempRange, hoverDate]);\r\n\r\n  const handleSelect = (range: DateRange | undefined) => {\r\n    const prevRange = previousTempRangeRef.current;\r\n\r\n    // Clear hover state when a selection is made\r\n    setHoverDate(undefined);\r\n\r\n    // Prevent deselecting all dates - if range is undefined or empty, ignore\r\n    if (!range?.from) {\r\n      return;\r\n    }\r\n\r\n    // Detect if user is starting a new selection\r\n    if (prevRange?.from && prevRange?.to) {\r\n      // Had a complete range before\r\n      if (range?.from && range?.to) {\r\n        // Still have a complete range\r\n        if (range.from.getTime() === range.to.getTime()) {\r\n          // Single date clicked - start new selection\r\n          setTempRange({ from: range.from, to: undefined });\r\n          previousTempRangeRef.current = { from: range.from, to: undefined };\r\n          return;\r\n        } else if (\r\n          // Check if it's just extending/modifying the existing range\r\n          range.from.getTime() === prevRange.from.getTime() ||\r\n          range.to.getTime() === prevRange.to.getTime()\r\n        ) {\r\n          // This is modifying the existing range, but we want to start fresh\r\n          // So we need to clear and start over with just the newly clicked date\r\n          const clickedDate =\r\n            range.from.getTime() !== prevRange.from.getTime()\r\n              ? range.from\r\n              : range.to;\r\n          setTempRange({ from: clickedDate, to: undefined });\r\n          previousTempRangeRef.current = { from: clickedDate, to: undefined };\r\n          return;\r\n        }\r\n      }\r\n\r\n      // Special case: if we had a single-day range and user clicks on a single date\r\n      // This happens when Calendar is in range mode but user clicks on the same date that was selected\r\n      if (range?.from && !range?.to) {\r\n        // Check if this is clicking on the same single-day range\r\n        if (\r\n          prevRange.from.getTime() === prevRange.to.getTime() &&\r\n          range.from.getTime() === prevRange.from.getTime()\r\n        ) {\r\n          // Clicking on the same single-day range - start new selection\r\n          setTempRange({ from: range.from, to: undefined });\r\n          previousTempRangeRef.current = { from: range.from, to: undefined };\r\n          return;\r\n        }\r\n      }\r\n    }\r\n\r\n    // If user is selecting a second date\r\n    if (range.from && !range.to && prevRange?.from && !prevRange?.to) {\r\n      // User clicked on the first date again - create single-day range\r\n      if (range.from.getTime() === prevRange.from.getTime()) {\r\n        const singleDayRange = { from: range.from, to: range.from };\r\n        setTempRange(singleDayRange);\r\n        previousTempRangeRef.current = singleDayRange;\r\n        onSelect?.(singleDayRange);\r\n        setOpen(false);\r\n        return;\r\n      }\r\n    }\r\n\r\n    setTempRange(range);\r\n    previousTempRangeRef.current = range;\r\n\r\n    // Update the actual value and close when both dates are selected\r\n    if (range?.from && range?.to) {\r\n      // Ensure proper range order - from should be earlier than to\r\n      const normalizedRange = {\r\n        from:\r\n          range.from.getTime() <= range.to.getTime() ? range.from : range.to,\r\n        to: range.from.getTime() <= range.to.getTime() ? range.to : range.from,\r\n      };\r\n      onSelect?.(normalizedRange);\r\n      setOpen(false);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <Popover open={open} onOpenChange={setOpen}>\r\n      <PopoverTrigger\r\n        render={(props) => (\r\n          <Button\r\n            {...props}\r\n            variant=\"outline\"\r\n            className={cn(\"w-[300px] justify-between\", className)}\r\n            disabled={disabled}\r\n          >\r\n            <span className=\"flex w-full items-center\">\r\n              <CalendarIcon className=\"mr-2 size-4\" />\r\n              <span className={cn(!value?.from && \"text-muted-foreground\")}>\r\n                {formatDateRange()}\r\n              </span>\r\n            </span>\r\n            <ChevronsUpDownIcon className=\"ml-2 size-4 shrink-0 opacity-50\" />\r\n          </Button>\r\n        )}\r\n      />\r\n      <PopoverContent\r\n        className=\"w-auto border-none p-0 outline-none\"\r\n        sideOffset={4}\r\n        arrow={false}\r\n        onMouseLeave={() => {\r\n          // Clear hover when leaving the popover content\r\n          setHoverDate(undefined);\r\n        }}\r\n      >\r\n        <Calendar\r\n          className=\"border-0\"\r\n          mode=\"range\"\r\n          numberOfMonths={numberOfMonths}\r\n          showOutsideDays\r\n          fixedWeeks={fixedWeeks}\r\n          selected={displayRange}\r\n          onSelect={(range) => {\r\n            // Prevent auto-completion when starting fresh (no existing tempRange)\r\n            if (\r\n              !tempRange?.from &&\r\n              range?.from &&\r\n              range?.to &&\r\n              range.from.getTime() === range.to.getTime()\r\n            ) {\r\n              // This is a fresh selection where Calendar auto-set both dates - convert to single date selection\r\n              setTempRange({ from: range.from, to: undefined });\r\n              previousTempRangeRef.current = {\r\n                from: range.from,\r\n                to: undefined,\r\n              };\r\n              return;\r\n            }\r\n\r\n            // Important: when we have a hover preview active, we need to handle the selection differently\r\n            if (tempRange?.from && !tempRange?.to && hoverDate && range?.to) {\r\n              // This is the second date selection with hover preview\r\n              // Use the actual clicked date, not the hover preview\r\n              const actualRange = {\r\n                from:\r\n                  tempRange.from.getTime() <= range.to.getTime()\r\n                    ? tempRange.from\r\n                    : range.to,\r\n                to:\r\n                  tempRange.from.getTime() <= range.to.getTime()\r\n                    ? range.to\r\n                    : tempRange.from,\r\n              };\r\n              handleSelect(actualRange);\r\n            } else {\r\n              handleSelect(range);\r\n            }\r\n          }}\r\n          onDayClick={(date) => {\r\n            // Handle case where there's no existing selection - start new range selection\r\n            if (!tempRange?.from) {\r\n              setTempRange({ from: date, to: undefined });\r\n              previousTempRangeRef.current = { from: date, to: undefined };\r\n              return;\r\n            }\r\n\r\n            // Handle case where user clicks the same date while selecting\r\n            if (\r\n              tempRange?.from &&\r\n              !tempRange?.to &&\r\n              date.getTime() === tempRange.from.getTime()\r\n            ) {\r\n              handleSelect({ from: date, to: date });\r\n              return;\r\n            }\r\n\r\n            // Handle case where user clicks on a single-day range to start new selection\r\n            if (\r\n              tempRange?.from &&\r\n              tempRange?.to &&\r\n              tempRange.from.getTime() === tempRange.to.getTime() &&\r\n              date.getTime() === tempRange.from.getTime()\r\n            ) {\r\n              // Clicking on the same single-day range - start new selection\r\n              setTempRange({ from: date, to: undefined });\r\n              previousTempRangeRef.current = { from: date, to: undefined };\r\n              return;\r\n            }\r\n          }}\r\n          onDayMouseEnter={(date) => {\r\n            // Only show hover preview when selecting the second date\r\n            if (tempRange?.from && !tempRange?.to) {\r\n              setHoverDate(date);\r\n            }\r\n          }}\r\n          onDayMouseLeave={() => {\r\n            // Let the Calendar handle its own mouse leave\r\n          }}\r\n        />\r\n      </PopoverContent>\r\n    </Popover>\r\n  );\r\n}\r\n",
      "type": "registry:ui",
      "target": "components/ui/cubby-ui/date-range-picker.tsx"
    }
  ]
}