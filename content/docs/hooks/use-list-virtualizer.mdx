---
title: useListVirtualizer
description: Virtualization hook for rendering large lists efficiently
---

## Installation

<ComponentInstall component="use-list-virtualizer" />

## Overview

`useListVirtualizer` provides virtualization for large lists using [TanStack Virtual](https://tanstack.com/virtual). It handles scroll positioning, item measurement, and keyboard navigation, making it easy to render thousands of items without performance issues.

**When to use:**
- Lists with 100+ items
- Command menus, autocompletes, or selects with large datasets
- Any scrollable list where DOM node count impacts performance

## Usage

```tsx
import { useListVirtualizer } from "@/hooks/cubby-ui/use-list-virtualizer";

const {
  rootProps,       // Spread on root component
  scrollRef,       // Attach to scroll container
  measureRef,      // Attach to each item for dynamic heights
  totalSize,       // Total height for virtual container
  virtualItems,    // Array to map over
  getItem,         // Get data for virtual item
  getItemStyle,    // Get positioning styles
  getItemProps,    // Get aria attributes
} = useListVirtualizer({
  items,           // All items (for aria-setsize)
  filteredItems,   // Items to display
  estimateSize: 40, // Item height in px
});
```

## Example with Command

```tsx
import { useListVirtualizer } from "@/hooks/cubby-ui/use-list-virtualizer";
import {
  Command,
  CommandVirtualizedList,
  CommandItem,
} from "@/lib/cubby-ui/command";

// Helper to extract searchable text from items
const getItemLabel = (item: Item | null) => item?.label ?? "";

function VirtualizedCommand({ items, filteredItems }) {
  const {
    rootProps,
    scrollRef,
    measureRef,
    totalSize,
    virtualItems,
    getItem,
    getItemStyle,
    getItemProps,
  } = useListVirtualizer({
    items,
    filteredItems,
    estimateSize: 40,
  });

  return (
    <Command {...rootProps} filter={null} itemToStringValue={getItemLabel}>
      <CommandVirtualizedList scrollRef={scrollRef} totalSize={totalSize} nativeScroll>
        {virtualItems.map((virtualItem) => {
          const item = getItem(virtualItem);
          return (
            <CommandItem
              key={virtualItem.key}
              ref={measureRef}
              value={item}
              style={getItemStyle(virtualItem)}
              {...getItemProps(virtualItem)}
            >
              {item.label}
            </CommandItem>
          );
        })}
      </CommandVirtualizedList>
    </Command>
  );
}
```

## Usage with useFilteredItems

When using Base UI's `useFilteredItems()` hook, filtered items come from inside the Root component. This requires a child component pattern with `virtualizerRef` + `useHighlightHandler`:

```tsx
import {
  AutocompleteRoot,
  AutocompleteVirtualizedList,
  useAutocompleteFilteredItems,
} from "@/components/ui/cubby-ui/autocomplete";
import {
  useListVirtualizer,
  useHighlightHandler,
  type ListVirtualizerInstance,
} from "@/hooks/cubby-ui/use-list-virtualizer";

function MyAutocomplete({ items }) {
  const virtualizerRef = React.useRef<ListVirtualizerInstance>(null);
  const onItemHighlighted = useHighlightHandler(virtualizerRef);

  return (
    <AutocompleteRoot
      items={items}
      virtualized
      itemToStringValue={getLabel}
      onItemHighlighted={onItemHighlighted}
    >
      {/* Input, positioner, etc. */}
      <VirtualizedContent items={items} virtualizerRef={virtualizerRef} />
    </AutocompleteRoot>
  );
}

function VirtualizedContent({ items, virtualizerRef }) {
  const filteredItems = useAutocompleteFilteredItems();
  const { scrollRef, measureRef, totalSize, virtualItems, getItem, getItemStyle, getItemProps } =
    useListVirtualizer({ items, filteredItems, virtualizerRef });

  return (
    <AutocompleteVirtualizedList scrollRef={scrollRef} totalSize={totalSize}>
      {virtualItems.map((vi) => { /* ... */ })}
    </AutocompleteVirtualizedList>
  );
}
```

This eliminates manual query state, `useDeferredValue`, `useFilter()`, and `useMemo` filtering. The Root handles filtering internally, and `useFilteredItems()` provides the result to the virtualizer.

## Performance Tips

For optimal scroll performance with large lists:

1. **Use `useDeferredValue` for search queries** - Prevents filtering from blocking scroll rendering. Use the resolved pattern to avoid stale results when clearing:
   ```tsx
   const deferredQuery = React.useDeferredValue(query);
   // Use immediate value when empty to avoid stale results
   const resolvedQuery =
     query === "" || deferredQuery === "" ? query : deferredQuery;

   const filteredItems = React.useMemo(
     () => items.filter((item) => contains(item, resolvedQuery, getLabel)),
     [contains, resolvedQuery],
   );
   ```

2. **Use `nativeScroll` on `CommandVirtualizedList`** - Avoids custom scroll container overhead for smoother fast scrolling.

## API Reference

### Options

<ApiPropsList>

<ApiProp name="items" fullType="T[]" required>
  All items in the list (unfiltered). Used for proper `aria-setsize` accessibility attribute.
</ApiProp>

<ApiProp name="filteredItems" fullType="T[]" required>
  The filtered items to display. Can equal `items` for server-side filtering.
</ApiProp>

<ApiProp name="enabled" fullType="boolean" defaultValue="true">
  Whether virtualization is active. Typically tied to dialog/popover open state.
</ApiProp>

<ApiProp name="estimateSize" fullType="number | ((index: number, item: T) => number)" defaultValue="40">
  Estimated height of each item in pixels. Use a function for variable heights based on item content.
</ApiProp>

<ApiProp name="overscan" fullType="number" defaultValue="20">
  Number of items to render outside the visible area. Higher values improve scroll smoothness but use more memory.
</ApiProp>

<ApiProp name="paddingStart" fullType="number" defaultValue="8">
  Padding at the start of the list in pixels. Should match your list container's padding.
</ApiProp>

<ApiProp name="paddingEnd" fullType="number" defaultValue="8">
  Padding at the end of the list in pixels.
</ApiProp>

<ApiProp name="virtualizerRef" fullType="React.RefObject<ListVirtualizerInstance | null>">
  Ref to expose the virtualizer instance to a parent component via `useImperativeHandle`. Use with `useHighlightHandler` for the `useFilteredItems` pattern.
</ApiProp>

</ApiPropsList>

### useHighlightHandler

```ts
function useHighlightHandler(
  virtualizerRef: React.RefObject<ListVirtualizerInstance | null>,
): (item: unknown, details: { reason: string; index: number }) => void;
```

Returns a stable `onItemHighlighted` callback that scrolls the virtualizer to the highlighted item on keyboard navigation. Use this on the Root component when the virtualizer lives in a child component.

### ListVirtualizerInstance

```ts
type ListVirtualizerInstance = ReturnType<typeof useVirtualizer>;
```

Type alias for the virtualizer instance. Use to type the `virtualizerRef`.

### Return Value

| Property | Type | Description |
|----------|------|-------------|
| `rootProps` | `object` | Spread on root component. Includes `virtualized`, `items`, `filteredItems`, `onItemHighlighted` |
| `scrollRef` | `(el: HTMLDivElement \| null) => void` | Ref callback for the scroll container |
| `measureRef` | `(el: HTMLDivElement \| null) => void` | Ref callback for each item (enables dynamic heights) |
| `totalSize` | `number` | Total height of all virtual items in pixels |
| `virtualItems` | `VirtualItem[]` | Array of virtual items to render |
| `getItem` | `(virtualItem) => T \| undefined` | Get the data item for a virtual item |
| `getItemStyle` | `(virtualItem) => CSSProperties` | Get positioning styles for a virtual item |
| `getItemProps` | `(virtualItem) => object` | Get aria attributes (`aria-setsize`, `aria-posinset`, `data-index`, `index`) |

## Used By

- [Command](/docs/components/command) - For virtualized command menus
- [Autocomplete](/docs/components/autocomplete) - For virtualized autocomplete lists
- [Combobox](/docs/components/combobox) - For virtualized combobox lists
